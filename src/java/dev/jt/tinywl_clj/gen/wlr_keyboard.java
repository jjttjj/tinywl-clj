// Generated by jextract

package dev.jt.tinywl_clj.gen;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct wlr_keyboard {
 *     struct wlr_input_device base;
 *     const struct wlr_keyboard_impl *impl;
 *     struct wlr_keyboard_group *group;
 *     char *keymap_string;
 *     size_t keymap_size;
 *     int keymap_fd;
 *     struct xkb_keymap *keymap;
 *     struct xkb_state *xkb_state;
 *     xkb_led_index_t led_indexes[3];
 *     xkb_mod_index_t mod_indexes[8];
 *     uint32_t leds;
 *     uint32_t keycodes[32];
 *     size_t num_keycodes;
 *     struct wlr_keyboard_modifiers modifiers;
 *     struct {
 *         int32_t rate;
 *         int32_t delay;
 *     } repeat_info;
 *     struct {
 *         struct wl_signal key;
 *         struct wl_signal modifiers;
 *         struct wl_signal keymap;
 *         struct wl_signal repeat_info;
 *     } events;
 *     void *data;
 * }
 * }
 */
public class wlr_keyboard {

    wlr_keyboard() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        wlr_input_device.layout().withName("base"),
        C.C_POINTER.withName("impl"),
        C.C_POINTER.withName("group"),
        C.C_POINTER.withName("keymap_string"),
        C.C_LONG.withName("keymap_size"),
        C.C_INT.withName("keymap_fd"),
        MemoryLayout.paddingLayout(4),
        C.C_POINTER.withName("keymap"),
        C.C_POINTER.withName("xkb_state"),
        MemoryLayout.sequenceLayout(3, C.C_INT).withName("led_indexes"),
        MemoryLayout.sequenceLayout(8, C.C_INT).withName("mod_indexes"),
        C.C_INT.withName("leds"),
        MemoryLayout.sequenceLayout(32, C.C_INT).withName("keycodes"),
        C.C_LONG.withName("num_keycodes"),
        wlr_keyboard_modifiers.layout().withName("modifiers"),
        wlr_keyboard.repeat_info.layout().withName("repeat_info"),
        wlr_keyboard.events.layout().withName("events"),
        C.C_POINTER.withName("data")
    ).withName("wlr_keyboard");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final GroupLayout base$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("base"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct wlr_input_device base
     * }
     */
    public static final GroupLayout base$layout() {
        return base$LAYOUT;
    }

    private static final long base$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct wlr_input_device base
     * }
     */
    public static final long base$offset() {
        return base$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct wlr_input_device base
     * }
     */
    public static MemorySegment base(MemorySegment struct) {
        return struct.asSlice(base$OFFSET, base$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct wlr_input_device base
     * }
     */
    public static void base(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, base$OFFSET, base$LAYOUT.byteSize());
    }

    private static final AddressLayout impl$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("impl"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const struct wlr_keyboard_impl *impl
     * }
     */
    public static final AddressLayout impl$layout() {
        return impl$LAYOUT;
    }

    private static final long impl$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const struct wlr_keyboard_impl *impl
     * }
     */
    public static final long impl$offset() {
        return impl$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const struct wlr_keyboard_impl *impl
     * }
     */
    public static MemorySegment impl(MemorySegment struct) {
        return struct.get(impl$LAYOUT, impl$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const struct wlr_keyboard_impl *impl
     * }
     */
    public static void impl(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(impl$LAYOUT, impl$OFFSET, fieldValue);
    }

    private static final AddressLayout group$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("group"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct wlr_keyboard_group *group
     * }
     */
    public static final AddressLayout group$layout() {
        return group$LAYOUT;
    }

    private static final long group$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct wlr_keyboard_group *group
     * }
     */
    public static final long group$offset() {
        return group$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct wlr_keyboard_group *group
     * }
     */
    public static MemorySegment group(MemorySegment struct) {
        return struct.get(group$LAYOUT, group$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct wlr_keyboard_group *group
     * }
     */
    public static void group(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(group$LAYOUT, group$OFFSET, fieldValue);
    }

    private static final AddressLayout keymap_string$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("keymap_string"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *keymap_string
     * }
     */
    public static final AddressLayout keymap_string$layout() {
        return keymap_string$LAYOUT;
    }

    private static final long keymap_string$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *keymap_string
     * }
     */
    public static final long keymap_string$offset() {
        return keymap_string$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *keymap_string
     * }
     */
    public static MemorySegment keymap_string(MemorySegment struct) {
        return struct.get(keymap_string$LAYOUT, keymap_string$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *keymap_string
     * }
     */
    public static void keymap_string(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(keymap_string$LAYOUT, keymap_string$OFFSET, fieldValue);
    }

    private static final OfLong keymap_size$LAYOUT = (OfLong)$LAYOUT.select(groupElement("keymap_size"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t keymap_size
     * }
     */
    public static final OfLong keymap_size$layout() {
        return keymap_size$LAYOUT;
    }

    private static final long keymap_size$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t keymap_size
     * }
     */
    public static final long keymap_size$offset() {
        return keymap_size$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t keymap_size
     * }
     */
    public static long keymap_size(MemorySegment struct) {
        return struct.get(keymap_size$LAYOUT, keymap_size$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t keymap_size
     * }
     */
    public static void keymap_size(MemorySegment struct, long fieldValue) {
        struct.set(keymap_size$LAYOUT, keymap_size$OFFSET, fieldValue);
    }

    private static final OfInt keymap_fd$LAYOUT = (OfInt)$LAYOUT.select(groupElement("keymap_fd"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int keymap_fd
     * }
     */
    public static final OfInt keymap_fd$layout() {
        return keymap_fd$LAYOUT;
    }

    private static final long keymap_fd$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int keymap_fd
     * }
     */
    public static final long keymap_fd$offset() {
        return keymap_fd$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int keymap_fd
     * }
     */
    public static int keymap_fd(MemorySegment struct) {
        return struct.get(keymap_fd$LAYOUT, keymap_fd$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int keymap_fd
     * }
     */
    public static void keymap_fd(MemorySegment struct, int fieldValue) {
        struct.set(keymap_fd$LAYOUT, keymap_fd$OFFSET, fieldValue);
    }

    private static final AddressLayout keymap$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("keymap"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct xkb_keymap *keymap
     * }
     */
    public static final AddressLayout keymap$layout() {
        return keymap$LAYOUT;
    }

    private static final long keymap$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct xkb_keymap *keymap
     * }
     */
    public static final long keymap$offset() {
        return keymap$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct xkb_keymap *keymap
     * }
     */
    public static MemorySegment keymap(MemorySegment struct) {
        return struct.get(keymap$LAYOUT, keymap$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct xkb_keymap *keymap
     * }
     */
    public static void keymap(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(keymap$LAYOUT, keymap$OFFSET, fieldValue);
    }

    private static final AddressLayout xkb_state$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xkb_state"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct xkb_state *xkb_state
     * }
     */
    public static final AddressLayout xkb_state$layout() {
        return xkb_state$LAYOUT;
    }

    private static final long xkb_state$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct xkb_state *xkb_state
     * }
     */
    public static final long xkb_state$offset() {
        return xkb_state$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct xkb_state *xkb_state
     * }
     */
    public static MemorySegment xkb_state(MemorySegment struct) {
        return struct.get(xkb_state$LAYOUT, xkb_state$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct xkb_state *xkb_state
     * }
     */
    public static void xkb_state(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xkb_state$LAYOUT, xkb_state$OFFSET, fieldValue);
    }

    private static final SequenceLayout led_indexes$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("led_indexes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * xkb_led_index_t led_indexes[3]
     * }
     */
    public static final SequenceLayout led_indexes$layout() {
        return led_indexes$LAYOUT;
    }

    private static final long led_indexes$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * xkb_led_index_t led_indexes[3]
     * }
     */
    public static final long led_indexes$offset() {
        return led_indexes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * xkb_led_index_t led_indexes[3]
     * }
     */
    public static MemorySegment led_indexes(MemorySegment struct) {
        return struct.asSlice(led_indexes$OFFSET, led_indexes$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * xkb_led_index_t led_indexes[3]
     * }
     */
    public static void led_indexes(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, led_indexes$OFFSET, led_indexes$LAYOUT.byteSize());
    }

    private static long[] led_indexes$DIMS = { 3 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * xkb_led_index_t led_indexes[3]
     * }
     */
    public static long[] led_indexes$dimensions() {
        return led_indexes$DIMS;
    }
    private static final VarHandle led_indexes$ELEM_HANDLE = led_indexes$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * xkb_led_index_t led_indexes[3]
     * }
     */
    public static int led_indexes(MemorySegment struct, long index0) {
        return (int)led_indexes$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * xkb_led_index_t led_indexes[3]
     * }
     */
    public static void led_indexes(MemorySegment struct, long index0, int fieldValue) {
        led_indexes$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final SequenceLayout mod_indexes$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("mod_indexes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * xkb_mod_index_t mod_indexes[8]
     * }
     */
    public static final SequenceLayout mod_indexes$layout() {
        return mod_indexes$LAYOUT;
    }

    private static final long mod_indexes$OFFSET = 116;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * xkb_mod_index_t mod_indexes[8]
     * }
     */
    public static final long mod_indexes$offset() {
        return mod_indexes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * xkb_mod_index_t mod_indexes[8]
     * }
     */
    public static MemorySegment mod_indexes(MemorySegment struct) {
        return struct.asSlice(mod_indexes$OFFSET, mod_indexes$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * xkb_mod_index_t mod_indexes[8]
     * }
     */
    public static void mod_indexes(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, mod_indexes$OFFSET, mod_indexes$LAYOUT.byteSize());
    }

    private static long[] mod_indexes$DIMS = { 8 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * xkb_mod_index_t mod_indexes[8]
     * }
     */
    public static long[] mod_indexes$dimensions() {
        return mod_indexes$DIMS;
    }
    private static final VarHandle mod_indexes$ELEM_HANDLE = mod_indexes$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * xkb_mod_index_t mod_indexes[8]
     * }
     */
    public static int mod_indexes(MemorySegment struct, long index0) {
        return (int)mod_indexes$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * xkb_mod_index_t mod_indexes[8]
     * }
     */
    public static void mod_indexes(MemorySegment struct, long index0, int fieldValue) {
        mod_indexes$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final OfInt leds$LAYOUT = (OfInt)$LAYOUT.select(groupElement("leds"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t leds
     * }
     */
    public static final OfInt leds$layout() {
        return leds$LAYOUT;
    }

    private static final long leds$OFFSET = 148;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t leds
     * }
     */
    public static final long leds$offset() {
        return leds$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t leds
     * }
     */
    public static int leds(MemorySegment struct) {
        return struct.get(leds$LAYOUT, leds$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t leds
     * }
     */
    public static void leds(MemorySegment struct, int fieldValue) {
        struct.set(leds$LAYOUT, leds$OFFSET, fieldValue);
    }

    private static final SequenceLayout keycodes$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("keycodes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t keycodes[32]
     * }
     */
    public static final SequenceLayout keycodes$layout() {
        return keycodes$LAYOUT;
    }

    private static final long keycodes$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t keycodes[32]
     * }
     */
    public static final long keycodes$offset() {
        return keycodes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t keycodes[32]
     * }
     */
    public static MemorySegment keycodes(MemorySegment struct) {
        return struct.asSlice(keycodes$OFFSET, keycodes$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t keycodes[32]
     * }
     */
    public static void keycodes(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, keycodes$OFFSET, keycodes$LAYOUT.byteSize());
    }

    private static long[] keycodes$DIMS = { 32 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * uint32_t keycodes[32]
     * }
     */
    public static long[] keycodes$dimensions() {
        return keycodes$DIMS;
    }
    private static final VarHandle keycodes$ELEM_HANDLE = keycodes$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * uint32_t keycodes[32]
     * }
     */
    public static int keycodes(MemorySegment struct, long index0) {
        return (int)keycodes$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * uint32_t keycodes[32]
     * }
     */
    public static void keycodes(MemorySegment struct, long index0, int fieldValue) {
        keycodes$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final OfLong num_keycodes$LAYOUT = (OfLong)$LAYOUT.select(groupElement("num_keycodes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t num_keycodes
     * }
     */
    public static final OfLong num_keycodes$layout() {
        return num_keycodes$LAYOUT;
    }

    private static final long num_keycodes$OFFSET = 280;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t num_keycodes
     * }
     */
    public static final long num_keycodes$offset() {
        return num_keycodes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t num_keycodes
     * }
     */
    public static long num_keycodes(MemorySegment struct) {
        return struct.get(num_keycodes$LAYOUT, num_keycodes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t num_keycodes
     * }
     */
    public static void num_keycodes(MemorySegment struct, long fieldValue) {
        struct.set(num_keycodes$LAYOUT, num_keycodes$OFFSET, fieldValue);
    }

    private static final GroupLayout modifiers$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("modifiers"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct wlr_keyboard_modifiers modifiers
     * }
     */
    public static final GroupLayout modifiers$layout() {
        return modifiers$LAYOUT;
    }

    private static final long modifiers$OFFSET = 288;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct wlr_keyboard_modifiers modifiers
     * }
     */
    public static final long modifiers$offset() {
        return modifiers$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct wlr_keyboard_modifiers modifiers
     * }
     */
    public static MemorySegment modifiers(MemorySegment struct) {
        return struct.asSlice(modifiers$OFFSET, modifiers$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct wlr_keyboard_modifiers modifiers
     * }
     */
    public static void modifiers(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, modifiers$OFFSET, modifiers$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     int32_t rate;
     *     int32_t delay;
     * }
     * }
     */
    public static class repeat_info {

        repeat_info() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            C.C_INT.withName("rate"),
            C.C_INT.withName("delay")
        ).withName("$anon$70:2");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final OfInt rate$LAYOUT = (OfInt)$LAYOUT.select(groupElement("rate"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * int32_t rate
         * }
         */
        public static final OfInt rate$layout() {
            return rate$LAYOUT;
        }

        private static final long rate$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * int32_t rate
         * }
         */
        public static final long rate$offset() {
            return rate$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * int32_t rate
         * }
         */
        public static int rate(MemorySegment struct) {
            return struct.get(rate$LAYOUT, rate$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * int32_t rate
         * }
         */
        public static void rate(MemorySegment struct, int fieldValue) {
            struct.set(rate$LAYOUT, rate$OFFSET, fieldValue);
        }

        private static final OfInt delay$LAYOUT = (OfInt)$LAYOUT.select(groupElement("delay"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * int32_t delay
         * }
         */
        public static final OfInt delay$layout() {
            return delay$LAYOUT;
        }

        private static final long delay$OFFSET = 4;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * int32_t delay
         * }
         */
        public static final long delay$offset() {
            return delay$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * int32_t delay
         * }
         */
        public static int delay(MemorySegment struct) {
            return struct.get(delay$LAYOUT, delay$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * int32_t delay
         * }
         */
        public static void delay(MemorySegment struct, int fieldValue) {
            struct.set(delay$LAYOUT, delay$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout repeat_info$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("repeat_info"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     int32_t rate;
     *     int32_t delay;
     * } repeat_info
     * }
     */
    public static final GroupLayout repeat_info$layout() {
        return repeat_info$LAYOUT;
    }

    private static final long repeat_info$OFFSET = 304;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     int32_t rate;
     *     int32_t delay;
     * } repeat_info
     * }
     */
    public static final long repeat_info$offset() {
        return repeat_info$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     int32_t rate;
     *     int32_t delay;
     * } repeat_info
     * }
     */
    public static MemorySegment repeat_info(MemorySegment struct) {
        return struct.asSlice(repeat_info$OFFSET, repeat_info$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     int32_t rate;
     *     int32_t delay;
     * } repeat_info
     * }
     */
    public static void repeat_info(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, repeat_info$OFFSET, repeat_info$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     struct wl_signal key;
     *     struct wl_signal modifiers;
     *     struct wl_signal keymap;
     *     struct wl_signal repeat_info;
     * }
     * }
     */
    public static class events {

        events() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            wl_signal.layout().withName("key"),
            wl_signal.layout().withName("modifiers"),
            wl_signal.layout().withName("keymap"),
            wl_signal.layout().withName("repeat_info")
        ).withName("$anon$75:2");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final GroupLayout key$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("key"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct wl_signal key
         * }
         */
        public static final GroupLayout key$layout() {
            return key$LAYOUT;
        }

        private static final long key$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct wl_signal key
         * }
         */
        public static final long key$offset() {
            return key$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct wl_signal key
         * }
         */
        public static MemorySegment key(MemorySegment struct) {
            return struct.asSlice(key$OFFSET, key$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct wl_signal key
         * }
         */
        public static void key(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, key$OFFSET, key$LAYOUT.byteSize());
        }

        private static final GroupLayout modifiers$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("modifiers"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct wl_signal modifiers
         * }
         */
        public static final GroupLayout modifiers$layout() {
            return modifiers$LAYOUT;
        }

        private static final long modifiers$OFFSET = 16;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct wl_signal modifiers
         * }
         */
        public static final long modifiers$offset() {
            return modifiers$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct wl_signal modifiers
         * }
         */
        public static MemorySegment modifiers(MemorySegment struct) {
            return struct.asSlice(modifiers$OFFSET, modifiers$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct wl_signal modifiers
         * }
         */
        public static void modifiers(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, modifiers$OFFSET, modifiers$LAYOUT.byteSize());
        }

        private static final GroupLayout keymap$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("keymap"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct wl_signal keymap
         * }
         */
        public static final GroupLayout keymap$layout() {
            return keymap$LAYOUT;
        }

        private static final long keymap$OFFSET = 32;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct wl_signal keymap
         * }
         */
        public static final long keymap$offset() {
            return keymap$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct wl_signal keymap
         * }
         */
        public static MemorySegment keymap(MemorySegment struct) {
            return struct.asSlice(keymap$OFFSET, keymap$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct wl_signal keymap
         * }
         */
        public static void keymap(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, keymap$OFFSET, keymap$LAYOUT.byteSize());
        }

        private static final GroupLayout repeat_info$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("repeat_info"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct wl_signal repeat_info
         * }
         */
        public static final GroupLayout repeat_info$layout() {
            return repeat_info$LAYOUT;
        }

        private static final long repeat_info$OFFSET = 48;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct wl_signal repeat_info
         * }
         */
        public static final long repeat_info$offset() {
            return repeat_info$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct wl_signal repeat_info
         * }
         */
        public static MemorySegment repeat_info(MemorySegment struct) {
            return struct.asSlice(repeat_info$OFFSET, repeat_info$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct wl_signal repeat_info
         * }
         */
        public static void repeat_info(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, repeat_info$OFFSET, repeat_info$LAYOUT.byteSize());
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout events$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("events"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     struct wl_signal key;
     *     struct wl_signal modifiers;
     *     struct wl_signal keymap;
     *     struct wl_signal repeat_info;
     * } events
     * }
     */
    public static final GroupLayout events$layout() {
        return events$LAYOUT;
    }

    private static final long events$OFFSET = 312;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     struct wl_signal key;
     *     struct wl_signal modifiers;
     *     struct wl_signal keymap;
     *     struct wl_signal repeat_info;
     * } events
     * }
     */
    public static final long events$offset() {
        return events$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     struct wl_signal key;
     *     struct wl_signal modifiers;
     *     struct wl_signal keymap;
     *     struct wl_signal repeat_info;
     * } events
     * }
     */
    public static MemorySegment events(MemorySegment struct) {
        return struct.asSlice(events$OFFSET, events$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     struct wl_signal key;
     *     struct wl_signal modifiers;
     *     struct wl_signal keymap;
     *     struct wl_signal repeat_info;
     * } events
     * }
     */
    public static void events(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, events$OFFSET, events$LAYOUT.byteSize());
    }

    private static final AddressLayout data$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("data"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *data
     * }
     */
    public static final AddressLayout data$layout() {
        return data$LAYOUT;
    }

    private static final long data$OFFSET = 376;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *data
     * }
     */
    public static final long data$offset() {
        return data$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *data
     * }
     */
    public static MemorySegment data(MemorySegment struct) {
        return struct.get(data$LAYOUT, data$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *data
     * }
     */
    public static void data(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(data$LAYOUT, data$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

