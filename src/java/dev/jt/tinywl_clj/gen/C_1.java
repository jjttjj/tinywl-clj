// Generated by jextract

package dev.jt.tinywl_clj.gen;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class C_1 extends C_2 {

    C_1() {
        // Should not be called directly
    }
    private static final int XDG_TOPLEVEL_STATE_TILED_BOTTOM = (int)8L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_state.XDG_TOPLEVEL_STATE_TILED_BOTTOM = 8
     * }
     */
    public static int XDG_TOPLEVEL_STATE_TILED_BOTTOM() {
        return XDG_TOPLEVEL_STATE_TILED_BOTTOM;
    }
    private static final int XDG_TOPLEVEL_STATE_SUSPENDED = (int)9L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_state.XDG_TOPLEVEL_STATE_SUSPENDED = 9
     * }
     */
    public static int XDG_TOPLEVEL_STATE_SUSPENDED() {
        return XDG_TOPLEVEL_STATE_SUSPENDED;
    }
    private static final int XDG_TOPLEVEL_WM_CAPABILITIES_WINDOW_MENU = (int)1L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_wm_capabilities.XDG_TOPLEVEL_WM_CAPABILITIES_WINDOW_MENU = 1
     * }
     */
    public static int XDG_TOPLEVEL_WM_CAPABILITIES_WINDOW_MENU() {
        return XDG_TOPLEVEL_WM_CAPABILITIES_WINDOW_MENU;
    }
    private static final int XDG_TOPLEVEL_WM_CAPABILITIES_MAXIMIZE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_wm_capabilities.XDG_TOPLEVEL_WM_CAPABILITIES_MAXIMIZE = 2
     * }
     */
    public static int XDG_TOPLEVEL_WM_CAPABILITIES_MAXIMIZE() {
        return XDG_TOPLEVEL_WM_CAPABILITIES_MAXIMIZE;
    }
    private static final int XDG_TOPLEVEL_WM_CAPABILITIES_FULLSCREEN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_wm_capabilities.XDG_TOPLEVEL_WM_CAPABILITIES_FULLSCREEN = 3
     * }
     */
    public static int XDG_TOPLEVEL_WM_CAPABILITIES_FULLSCREEN() {
        return XDG_TOPLEVEL_WM_CAPABILITIES_FULLSCREEN;
    }
    private static final int XDG_TOPLEVEL_WM_CAPABILITIES_MINIMIZE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_wm_capabilities.XDG_TOPLEVEL_WM_CAPABILITIES_MINIMIZE = 4
     * }
     */
    public static int XDG_TOPLEVEL_WM_CAPABILITIES_MINIMIZE() {
        return XDG_TOPLEVEL_WM_CAPABILITIES_MINIMIZE;
    }
    private static final int XDG_POPUP_ERROR_INVALID_GRAB = (int)0L;
    /**
     * {@snippet lang=c :
     * enum xdg_popup_error.XDG_POPUP_ERROR_INVALID_GRAB = 0
     * }
     */
    public static int XDG_POPUP_ERROR_INVALID_GRAB() {
        return XDG_POPUP_ERROR_INVALID_GRAB;
    }

    private static class wlr_backend_autocreate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_backend_autocreate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_backend *wlr_backend_autocreate(struct wl_display *display, struct wlr_session **session_ptr)
     * }
     */
    public static FunctionDescriptor wlr_backend_autocreate$descriptor() {
        return wlr_backend_autocreate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_backend *wlr_backend_autocreate(struct wl_display *display, struct wlr_session **session_ptr)
     * }
     */
    public static MethodHandle wlr_backend_autocreate$handle() {
        return wlr_backend_autocreate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_backend *wlr_backend_autocreate(struct wl_display *display, struct wlr_session **session_ptr)
     * }
     */
    public static MemorySegment wlr_backend_autocreate$address() {
        return wlr_backend_autocreate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_backend *wlr_backend_autocreate(struct wl_display *display, struct wlr_session **session_ptr)
     * }
     */
    public static MemorySegment wlr_backend_autocreate(MemorySegment display, MemorySegment session_ptr) {
        var mh$ = wlr_backend_autocreate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_backend_autocreate", display, session_ptr);
            }
            return (MemorySegment)mh$.invokeExact(display, session_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_backend_start {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_backend_start");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_backend_start(struct wlr_backend *backend)
     * }
     */
    public static FunctionDescriptor wlr_backend_start$descriptor() {
        return wlr_backend_start.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_backend_start(struct wlr_backend *backend)
     * }
     */
    public static MethodHandle wlr_backend_start$handle() {
        return wlr_backend_start.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_backend_start(struct wlr_backend *backend)
     * }
     */
    public static MemorySegment wlr_backend_start$address() {
        return wlr_backend_start.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_backend_start(struct wlr_backend *backend)
     * }
     */
    public static boolean wlr_backend_start(MemorySegment backend) {
        var mh$ = wlr_backend_start.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_backend_start", backend);
            }
            return (boolean)mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_backend_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_backend_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_backend_destroy(struct wlr_backend *backend)
     * }
     */
    public static FunctionDescriptor wlr_backend_destroy$descriptor() {
        return wlr_backend_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_backend_destroy(struct wlr_backend *backend)
     * }
     */
    public static MethodHandle wlr_backend_destroy$handle() {
        return wlr_backend_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_backend_destroy(struct wlr_backend *backend)
     * }
     */
    public static MemorySegment wlr_backend_destroy$address() {
        return wlr_backend_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_backend_destroy(struct wlr_backend *backend)
     * }
     */
    public static void wlr_backend_destroy(MemorySegment backend) {
        var mh$ = wlr_backend_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_backend_destroy", backend);
            }
            mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_backend_get_drm_fd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_backend_get_drm_fd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wlr_backend_get_drm_fd(struct wlr_backend *backend)
     * }
     */
    public static FunctionDescriptor wlr_backend_get_drm_fd$descriptor() {
        return wlr_backend_get_drm_fd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wlr_backend_get_drm_fd(struct wlr_backend *backend)
     * }
     */
    public static MethodHandle wlr_backend_get_drm_fd$handle() {
        return wlr_backend_get_drm_fd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wlr_backend_get_drm_fd(struct wlr_backend *backend)
     * }
     */
    public static MemorySegment wlr_backend_get_drm_fd$address() {
        return wlr_backend_get_drm_fd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wlr_backend_get_drm_fd(struct wlr_backend *backend)
     * }
     */
    public static int wlr_backend_get_drm_fd(MemorySegment backend) {
        var mh$ = wlr_backend_get_drm_fd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_backend_get_drm_fd", backend);
            }
            return (int)mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_allocator_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_allocator_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_allocator_init(struct wlr_allocator *alloc, const struct wlr_allocator_interface *impl, uint32_t buffer_caps)
     * }
     */
    public static FunctionDescriptor wlr_allocator_init$descriptor() {
        return wlr_allocator_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_allocator_init(struct wlr_allocator *alloc, const struct wlr_allocator_interface *impl, uint32_t buffer_caps)
     * }
     */
    public static MethodHandle wlr_allocator_init$handle() {
        return wlr_allocator_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_allocator_init(struct wlr_allocator *alloc, const struct wlr_allocator_interface *impl, uint32_t buffer_caps)
     * }
     */
    public static MemorySegment wlr_allocator_init$address() {
        return wlr_allocator_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_allocator_init(struct wlr_allocator *alloc, const struct wlr_allocator_interface *impl, uint32_t buffer_caps)
     * }
     */
    public static void wlr_allocator_init(MemorySegment alloc, MemorySegment impl, int buffer_caps) {
        var mh$ = wlr_allocator_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_allocator_init", alloc, impl, buffer_caps);
            }
            mh$.invokeExact(alloc, impl, buffer_caps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_allocator_autocreate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_allocator_autocreate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_allocator *wlr_allocator_autocreate(struct wlr_backend *backend, struct wlr_renderer *renderer)
     * }
     */
    public static FunctionDescriptor wlr_allocator_autocreate$descriptor() {
        return wlr_allocator_autocreate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_allocator *wlr_allocator_autocreate(struct wlr_backend *backend, struct wlr_renderer *renderer)
     * }
     */
    public static MethodHandle wlr_allocator_autocreate$handle() {
        return wlr_allocator_autocreate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_allocator *wlr_allocator_autocreate(struct wlr_backend *backend, struct wlr_renderer *renderer)
     * }
     */
    public static MemorySegment wlr_allocator_autocreate$address() {
        return wlr_allocator_autocreate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_allocator *wlr_allocator_autocreate(struct wlr_backend *backend, struct wlr_renderer *renderer)
     * }
     */
    public static MemorySegment wlr_allocator_autocreate(MemorySegment backend, MemorySegment renderer) {
        var mh$ = wlr_allocator_autocreate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_allocator_autocreate", backend, renderer);
            }
            return (MemorySegment)mh$.invokeExact(backend, renderer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_allocator_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_allocator_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_allocator_destroy(struct wlr_allocator *alloc)
     * }
     */
    public static FunctionDescriptor wlr_allocator_destroy$descriptor() {
        return wlr_allocator_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_allocator_destroy(struct wlr_allocator *alloc)
     * }
     */
    public static MethodHandle wlr_allocator_destroy$handle() {
        return wlr_allocator_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_allocator_destroy(struct wlr_allocator *alloc)
     * }
     */
    public static MemorySegment wlr_allocator_destroy$address() {
        return wlr_allocator_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_allocator_destroy(struct wlr_allocator *alloc)
     * }
     */
    public static void wlr_allocator_destroy(MemorySegment alloc) {
        var mh$ = wlr_allocator_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_allocator_destroy", alloc);
            }
            mh$.invokeExact(alloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_allocator_create_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_allocator_create_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_buffer *wlr_allocator_create_buffer(struct wlr_allocator *alloc, int width, int height, const struct wlr_drm_format *format)
     * }
     */
    public static FunctionDescriptor wlr_allocator_create_buffer$descriptor() {
        return wlr_allocator_create_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_buffer *wlr_allocator_create_buffer(struct wlr_allocator *alloc, int width, int height, const struct wlr_drm_format *format)
     * }
     */
    public static MethodHandle wlr_allocator_create_buffer$handle() {
        return wlr_allocator_create_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_buffer *wlr_allocator_create_buffer(struct wlr_allocator *alloc, int width, int height, const struct wlr_drm_format *format)
     * }
     */
    public static MemorySegment wlr_allocator_create_buffer$address() {
        return wlr_allocator_create_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_buffer *wlr_allocator_create_buffer(struct wlr_allocator *alloc, int width, int height, const struct wlr_drm_format *format)
     * }
     */
    public static MemorySegment wlr_allocator_create_buffer(MemorySegment alloc, int width, int height, MemorySegment format) {
        var mh$ = wlr_allocator_create_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_allocator_create_buffer", alloc, width, height, format);
            }
            return (MemorySegment)mh$.invokeExact(alloc, width, height, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int pixman_bool_t
     * }
     */
    public static final OfInt pixman_bool_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t pixman_fixed_32_32_t
     * }
     */
    public static final OfLong pixman_fixed_32_32_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef pixman_fixed_32_32_t pixman_fixed_48_16_t
     * }
     */
    public static final OfLong pixman_fixed_48_16_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint32_t pixman_fixed_1_31_t
     * }
     */
    public static final OfInt pixman_fixed_1_31_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t pixman_fixed_1_16_t
     * }
     */
    public static final OfInt pixman_fixed_1_16_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int32_t pixman_fixed_16_16_t
     * }
     */
    public static final OfInt pixman_fixed_16_16_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef pixman_fixed_16_16_t pixman_fixed_t
     * }
     */
    public static final OfInt pixman_fixed_t = C.C_INT;

    private static class pixman_transform_init_identity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_transform_init_identity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_transform_init_identity(struct pixman_transform *matrix)
     * }
     */
    public static FunctionDescriptor pixman_transform_init_identity$descriptor() {
        return pixman_transform_init_identity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_transform_init_identity(struct pixman_transform *matrix)
     * }
     */
    public static MethodHandle pixman_transform_init_identity$handle() {
        return pixman_transform_init_identity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_transform_init_identity(struct pixman_transform *matrix)
     * }
     */
    public static MemorySegment pixman_transform_init_identity$address() {
        return pixman_transform_init_identity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_transform_init_identity(struct pixman_transform *matrix)
     * }
     */
    public static void pixman_transform_init_identity(MemorySegment matrix) {
        var mh$ = pixman_transform_init_identity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_transform_init_identity", matrix);
            }
            mh$.invokeExact(matrix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_transform_point_3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_transform_point_3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_point_3d(const struct pixman_transform *transform, struct pixman_vector *vector)
     * }
     */
    public static FunctionDescriptor pixman_transform_point_3d$descriptor() {
        return pixman_transform_point_3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_point_3d(const struct pixman_transform *transform, struct pixman_vector *vector)
     * }
     */
    public static MethodHandle pixman_transform_point_3d$handle() {
        return pixman_transform_point_3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_point_3d(const struct pixman_transform *transform, struct pixman_vector *vector)
     * }
     */
    public static MemorySegment pixman_transform_point_3d$address() {
        return pixman_transform_point_3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_point_3d(const struct pixman_transform *transform, struct pixman_vector *vector)
     * }
     */
    public static int pixman_transform_point_3d(MemorySegment transform, MemorySegment vector) {
        var mh$ = pixman_transform_point_3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_transform_point_3d", transform, vector);
            }
            return (int)mh$.invokeExact(transform, vector);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_transform_point {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_transform_point");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_point(const struct pixman_transform *transform, struct pixman_vector *vector)
     * }
     */
    public static FunctionDescriptor pixman_transform_point$descriptor() {
        return pixman_transform_point.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_point(const struct pixman_transform *transform, struct pixman_vector *vector)
     * }
     */
    public static MethodHandle pixman_transform_point$handle() {
        return pixman_transform_point.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_point(const struct pixman_transform *transform, struct pixman_vector *vector)
     * }
     */
    public static MemorySegment pixman_transform_point$address() {
        return pixman_transform_point.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_point(const struct pixman_transform *transform, struct pixman_vector *vector)
     * }
     */
    public static int pixman_transform_point(MemorySegment transform, MemorySegment vector) {
        var mh$ = pixman_transform_point.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_transform_point", transform, vector);
            }
            return (int)mh$.invokeExact(transform, vector);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_transform_multiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_transform_multiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_multiply(struct pixman_transform *dst, const struct pixman_transform *l, const struct pixman_transform *r)
     * }
     */
    public static FunctionDescriptor pixman_transform_multiply$descriptor() {
        return pixman_transform_multiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_multiply(struct pixman_transform *dst, const struct pixman_transform *l, const struct pixman_transform *r)
     * }
     */
    public static MethodHandle pixman_transform_multiply$handle() {
        return pixman_transform_multiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_multiply(struct pixman_transform *dst, const struct pixman_transform *l, const struct pixman_transform *r)
     * }
     */
    public static MemorySegment pixman_transform_multiply$address() {
        return pixman_transform_multiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_multiply(struct pixman_transform *dst, const struct pixman_transform *l, const struct pixman_transform *r)
     * }
     */
    public static int pixman_transform_multiply(MemorySegment dst, MemorySegment l, MemorySegment r) {
        var mh$ = pixman_transform_multiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_transform_multiply", dst, l, r);
            }
            return (int)mh$.invokeExact(dst, l, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_transform_init_scale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_transform_init_scale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_transform_init_scale(struct pixman_transform *t, pixman_fixed_t sx, pixman_fixed_t sy)
     * }
     */
    public static FunctionDescriptor pixman_transform_init_scale$descriptor() {
        return pixman_transform_init_scale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_transform_init_scale(struct pixman_transform *t, pixman_fixed_t sx, pixman_fixed_t sy)
     * }
     */
    public static MethodHandle pixman_transform_init_scale$handle() {
        return pixman_transform_init_scale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_transform_init_scale(struct pixman_transform *t, pixman_fixed_t sx, pixman_fixed_t sy)
     * }
     */
    public static MemorySegment pixman_transform_init_scale$address() {
        return pixman_transform_init_scale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_transform_init_scale(struct pixman_transform *t, pixman_fixed_t sx, pixman_fixed_t sy)
     * }
     */
    public static void pixman_transform_init_scale(MemorySegment t, int sx, int sy) {
        var mh$ = pixman_transform_init_scale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_transform_init_scale", t, sx, sy);
            }
            mh$.invokeExact(t, sx, sy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_transform_scale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_transform_scale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_scale(struct pixman_transform *forward, struct pixman_transform *reverse, pixman_fixed_t sx, pixman_fixed_t sy)
     * }
     */
    public static FunctionDescriptor pixman_transform_scale$descriptor() {
        return pixman_transform_scale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_scale(struct pixman_transform *forward, struct pixman_transform *reverse, pixman_fixed_t sx, pixman_fixed_t sy)
     * }
     */
    public static MethodHandle pixman_transform_scale$handle() {
        return pixman_transform_scale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_scale(struct pixman_transform *forward, struct pixman_transform *reverse, pixman_fixed_t sx, pixman_fixed_t sy)
     * }
     */
    public static MemorySegment pixman_transform_scale$address() {
        return pixman_transform_scale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_scale(struct pixman_transform *forward, struct pixman_transform *reverse, pixman_fixed_t sx, pixman_fixed_t sy)
     * }
     */
    public static int pixman_transform_scale(MemorySegment forward, MemorySegment reverse, int sx, int sy) {
        var mh$ = pixman_transform_scale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_transform_scale", forward, reverse, sx, sy);
            }
            return (int)mh$.invokeExact(forward, reverse, sx, sy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_transform_init_rotate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_transform_init_rotate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_transform_init_rotate(struct pixman_transform *t, pixman_fixed_t cos, pixman_fixed_t sin)
     * }
     */
    public static FunctionDescriptor pixman_transform_init_rotate$descriptor() {
        return pixman_transform_init_rotate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_transform_init_rotate(struct pixman_transform *t, pixman_fixed_t cos, pixman_fixed_t sin)
     * }
     */
    public static MethodHandle pixman_transform_init_rotate$handle() {
        return pixman_transform_init_rotate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_transform_init_rotate(struct pixman_transform *t, pixman_fixed_t cos, pixman_fixed_t sin)
     * }
     */
    public static MemorySegment pixman_transform_init_rotate$address() {
        return pixman_transform_init_rotate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_transform_init_rotate(struct pixman_transform *t, pixman_fixed_t cos, pixman_fixed_t sin)
     * }
     */
    public static void pixman_transform_init_rotate(MemorySegment t, int cos, int sin) {
        var mh$ = pixman_transform_init_rotate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_transform_init_rotate", t, cos, sin);
            }
            mh$.invokeExact(t, cos, sin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_transform_rotate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_transform_rotate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_rotate(struct pixman_transform *forward, struct pixman_transform *reverse, pixman_fixed_t c, pixman_fixed_t s)
     * }
     */
    public static FunctionDescriptor pixman_transform_rotate$descriptor() {
        return pixman_transform_rotate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_rotate(struct pixman_transform *forward, struct pixman_transform *reverse, pixman_fixed_t c, pixman_fixed_t s)
     * }
     */
    public static MethodHandle pixman_transform_rotate$handle() {
        return pixman_transform_rotate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_rotate(struct pixman_transform *forward, struct pixman_transform *reverse, pixman_fixed_t c, pixman_fixed_t s)
     * }
     */
    public static MemorySegment pixman_transform_rotate$address() {
        return pixman_transform_rotate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_rotate(struct pixman_transform *forward, struct pixman_transform *reverse, pixman_fixed_t c, pixman_fixed_t s)
     * }
     */
    public static int pixman_transform_rotate(MemorySegment forward, MemorySegment reverse, int c, int s) {
        var mh$ = pixman_transform_rotate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_transform_rotate", forward, reverse, c, s);
            }
            return (int)mh$.invokeExact(forward, reverse, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_transform_init_translate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_transform_init_translate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_transform_init_translate(struct pixman_transform *t, pixman_fixed_t tx, pixman_fixed_t ty)
     * }
     */
    public static FunctionDescriptor pixman_transform_init_translate$descriptor() {
        return pixman_transform_init_translate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_transform_init_translate(struct pixman_transform *t, pixman_fixed_t tx, pixman_fixed_t ty)
     * }
     */
    public static MethodHandle pixman_transform_init_translate$handle() {
        return pixman_transform_init_translate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_transform_init_translate(struct pixman_transform *t, pixman_fixed_t tx, pixman_fixed_t ty)
     * }
     */
    public static MemorySegment pixman_transform_init_translate$address() {
        return pixman_transform_init_translate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_transform_init_translate(struct pixman_transform *t, pixman_fixed_t tx, pixman_fixed_t ty)
     * }
     */
    public static void pixman_transform_init_translate(MemorySegment t, int tx, int ty) {
        var mh$ = pixman_transform_init_translate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_transform_init_translate", t, tx, ty);
            }
            mh$.invokeExact(t, tx, ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_transform_translate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_transform_translate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_translate(struct pixman_transform *forward, struct pixman_transform *reverse, pixman_fixed_t tx, pixman_fixed_t ty)
     * }
     */
    public static FunctionDescriptor pixman_transform_translate$descriptor() {
        return pixman_transform_translate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_translate(struct pixman_transform *forward, struct pixman_transform *reverse, pixman_fixed_t tx, pixman_fixed_t ty)
     * }
     */
    public static MethodHandle pixman_transform_translate$handle() {
        return pixman_transform_translate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_translate(struct pixman_transform *forward, struct pixman_transform *reverse, pixman_fixed_t tx, pixman_fixed_t ty)
     * }
     */
    public static MemorySegment pixman_transform_translate$address() {
        return pixman_transform_translate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_translate(struct pixman_transform *forward, struct pixman_transform *reverse, pixman_fixed_t tx, pixman_fixed_t ty)
     * }
     */
    public static int pixman_transform_translate(MemorySegment forward, MemorySegment reverse, int tx, int ty) {
        var mh$ = pixman_transform_translate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_transform_translate", forward, reverse, tx, ty);
            }
            return (int)mh$.invokeExact(forward, reverse, tx, ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_transform_bounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_transform_bounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_bounds(const struct pixman_transform *matrix, struct pixman_box16 *b)
     * }
     */
    public static FunctionDescriptor pixman_transform_bounds$descriptor() {
        return pixman_transform_bounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_bounds(const struct pixman_transform *matrix, struct pixman_box16 *b)
     * }
     */
    public static MethodHandle pixman_transform_bounds$handle() {
        return pixman_transform_bounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_bounds(const struct pixman_transform *matrix, struct pixman_box16 *b)
     * }
     */
    public static MemorySegment pixman_transform_bounds$address() {
        return pixman_transform_bounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_bounds(const struct pixman_transform *matrix, struct pixman_box16 *b)
     * }
     */
    public static int pixman_transform_bounds(MemorySegment matrix, MemorySegment b) {
        var mh$ = pixman_transform_bounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_transform_bounds", matrix, b);
            }
            return (int)mh$.invokeExact(matrix, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_transform_invert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_transform_invert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_invert(struct pixman_transform *dst, const struct pixman_transform *src)
     * }
     */
    public static FunctionDescriptor pixman_transform_invert$descriptor() {
        return pixman_transform_invert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_invert(struct pixman_transform *dst, const struct pixman_transform *src)
     * }
     */
    public static MethodHandle pixman_transform_invert$handle() {
        return pixman_transform_invert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_invert(struct pixman_transform *dst, const struct pixman_transform *src)
     * }
     */
    public static MemorySegment pixman_transform_invert$address() {
        return pixman_transform_invert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_invert(struct pixman_transform *dst, const struct pixman_transform *src)
     * }
     */
    public static int pixman_transform_invert(MemorySegment dst, MemorySegment src) {
        var mh$ = pixman_transform_invert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_transform_invert", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_transform_is_identity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_transform_is_identity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_is_identity(const struct pixman_transform *t)
     * }
     */
    public static FunctionDescriptor pixman_transform_is_identity$descriptor() {
        return pixman_transform_is_identity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_is_identity(const struct pixman_transform *t)
     * }
     */
    public static MethodHandle pixman_transform_is_identity$handle() {
        return pixman_transform_is_identity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_is_identity(const struct pixman_transform *t)
     * }
     */
    public static MemorySegment pixman_transform_is_identity$address() {
        return pixman_transform_is_identity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_is_identity(const struct pixman_transform *t)
     * }
     */
    public static int pixman_transform_is_identity(MemorySegment t) {
        var mh$ = pixman_transform_is_identity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_transform_is_identity", t);
            }
            return (int)mh$.invokeExact(t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_transform_is_scale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_transform_is_scale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_is_scale(const struct pixman_transform *t)
     * }
     */
    public static FunctionDescriptor pixman_transform_is_scale$descriptor() {
        return pixman_transform_is_scale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_is_scale(const struct pixman_transform *t)
     * }
     */
    public static MethodHandle pixman_transform_is_scale$handle() {
        return pixman_transform_is_scale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_is_scale(const struct pixman_transform *t)
     * }
     */
    public static MemorySegment pixman_transform_is_scale$address() {
        return pixman_transform_is_scale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_is_scale(const struct pixman_transform *t)
     * }
     */
    public static int pixman_transform_is_scale(MemorySegment t) {
        var mh$ = pixman_transform_is_scale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_transform_is_scale", t);
            }
            return (int)mh$.invokeExact(t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_transform_is_int_translate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_transform_is_int_translate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_is_int_translate(const struct pixman_transform *t)
     * }
     */
    public static FunctionDescriptor pixman_transform_is_int_translate$descriptor() {
        return pixman_transform_is_int_translate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_is_int_translate(const struct pixman_transform *t)
     * }
     */
    public static MethodHandle pixman_transform_is_int_translate$handle() {
        return pixman_transform_is_int_translate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_is_int_translate(const struct pixman_transform *t)
     * }
     */
    public static MemorySegment pixman_transform_is_int_translate$address() {
        return pixman_transform_is_int_translate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_is_int_translate(const struct pixman_transform *t)
     * }
     */
    public static int pixman_transform_is_int_translate(MemorySegment t) {
        var mh$ = pixman_transform_is_int_translate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_transform_is_int_translate", t);
            }
            return (int)mh$.invokeExact(t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_transform_is_inverse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_transform_is_inverse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_is_inverse(const struct pixman_transform *a, const struct pixman_transform *b)
     * }
     */
    public static FunctionDescriptor pixman_transform_is_inverse$descriptor() {
        return pixman_transform_is_inverse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_is_inverse(const struct pixman_transform *a, const struct pixman_transform *b)
     * }
     */
    public static MethodHandle pixman_transform_is_inverse$handle() {
        return pixman_transform_is_inverse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_is_inverse(const struct pixman_transform *a, const struct pixman_transform *b)
     * }
     */
    public static MemorySegment pixman_transform_is_inverse$address() {
        return pixman_transform_is_inverse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_is_inverse(const struct pixman_transform *a, const struct pixman_transform *b)
     * }
     */
    public static int pixman_transform_is_inverse(MemorySegment a, MemorySegment b) {
        var mh$ = pixman_transform_is_inverse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_transform_is_inverse", a, b);
            }
            return (int)mh$.invokeExact(a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_transform_from_pixman_f_transform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_transform_from_pixman_f_transform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_from_pixman_f_transform(struct pixman_transform *t, const struct pixman_f_transform *ft)
     * }
     */
    public static FunctionDescriptor pixman_transform_from_pixman_f_transform$descriptor() {
        return pixman_transform_from_pixman_f_transform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_from_pixman_f_transform(struct pixman_transform *t, const struct pixman_f_transform *ft)
     * }
     */
    public static MethodHandle pixman_transform_from_pixman_f_transform$handle() {
        return pixman_transform_from_pixman_f_transform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_from_pixman_f_transform(struct pixman_transform *t, const struct pixman_f_transform *ft)
     * }
     */
    public static MemorySegment pixman_transform_from_pixman_f_transform$address() {
        return pixman_transform_from_pixman_f_transform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_transform_from_pixman_f_transform(struct pixman_transform *t, const struct pixman_f_transform *ft)
     * }
     */
    public static int pixman_transform_from_pixman_f_transform(MemorySegment t, MemorySegment ft) {
        var mh$ = pixman_transform_from_pixman_f_transform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_transform_from_pixman_f_transform", t, ft);
            }
            return (int)mh$.invokeExact(t, ft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_f_transform_from_pixman_transform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_f_transform_from_pixman_transform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_f_transform_from_pixman_transform(struct pixman_f_transform *ft, const struct pixman_transform *t)
     * }
     */
    public static FunctionDescriptor pixman_f_transform_from_pixman_transform$descriptor() {
        return pixman_f_transform_from_pixman_transform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_f_transform_from_pixman_transform(struct pixman_f_transform *ft, const struct pixman_transform *t)
     * }
     */
    public static MethodHandle pixman_f_transform_from_pixman_transform$handle() {
        return pixman_f_transform_from_pixman_transform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_f_transform_from_pixman_transform(struct pixman_f_transform *ft, const struct pixman_transform *t)
     * }
     */
    public static MemorySegment pixman_f_transform_from_pixman_transform$address() {
        return pixman_f_transform_from_pixman_transform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_f_transform_from_pixman_transform(struct pixman_f_transform *ft, const struct pixman_transform *t)
     * }
     */
    public static void pixman_f_transform_from_pixman_transform(MemorySegment ft, MemorySegment t) {
        var mh$ = pixman_f_transform_from_pixman_transform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_f_transform_from_pixman_transform", ft, t);
            }
            mh$.invokeExact(ft, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_f_transform_invert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_f_transform_invert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_invert(struct pixman_f_transform *dst, const struct pixman_f_transform *src)
     * }
     */
    public static FunctionDescriptor pixman_f_transform_invert$descriptor() {
        return pixman_f_transform_invert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_invert(struct pixman_f_transform *dst, const struct pixman_f_transform *src)
     * }
     */
    public static MethodHandle pixman_f_transform_invert$handle() {
        return pixman_f_transform_invert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_invert(struct pixman_f_transform *dst, const struct pixman_f_transform *src)
     * }
     */
    public static MemorySegment pixman_f_transform_invert$address() {
        return pixman_f_transform_invert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_invert(struct pixman_f_transform *dst, const struct pixman_f_transform *src)
     * }
     */
    public static int pixman_f_transform_invert(MemorySegment dst, MemorySegment src) {
        var mh$ = pixman_f_transform_invert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_f_transform_invert", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_f_transform_point {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_f_transform_point");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_point(const struct pixman_f_transform *t, struct pixman_f_vector *v)
     * }
     */
    public static FunctionDescriptor pixman_f_transform_point$descriptor() {
        return pixman_f_transform_point.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_point(const struct pixman_f_transform *t, struct pixman_f_vector *v)
     * }
     */
    public static MethodHandle pixman_f_transform_point$handle() {
        return pixman_f_transform_point.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_point(const struct pixman_f_transform *t, struct pixman_f_vector *v)
     * }
     */
    public static MemorySegment pixman_f_transform_point$address() {
        return pixman_f_transform_point.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_point(const struct pixman_f_transform *t, struct pixman_f_vector *v)
     * }
     */
    public static int pixman_f_transform_point(MemorySegment t, MemorySegment v) {
        var mh$ = pixman_f_transform_point.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_f_transform_point", t, v);
            }
            return (int)mh$.invokeExact(t, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_f_transform_point_3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_f_transform_point_3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_f_transform_point_3d(const struct pixman_f_transform *t, struct pixman_f_vector *v)
     * }
     */
    public static FunctionDescriptor pixman_f_transform_point_3d$descriptor() {
        return pixman_f_transform_point_3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_f_transform_point_3d(const struct pixman_f_transform *t, struct pixman_f_vector *v)
     * }
     */
    public static MethodHandle pixman_f_transform_point_3d$handle() {
        return pixman_f_transform_point_3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_f_transform_point_3d(const struct pixman_f_transform *t, struct pixman_f_vector *v)
     * }
     */
    public static MemorySegment pixman_f_transform_point_3d$address() {
        return pixman_f_transform_point_3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_f_transform_point_3d(const struct pixman_f_transform *t, struct pixman_f_vector *v)
     * }
     */
    public static void pixman_f_transform_point_3d(MemorySegment t, MemorySegment v) {
        var mh$ = pixman_f_transform_point_3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_f_transform_point_3d", t, v);
            }
            mh$.invokeExact(t, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_f_transform_multiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_f_transform_multiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_f_transform_multiply(struct pixman_f_transform *dst, const struct pixman_f_transform *l, const struct pixman_f_transform *r)
     * }
     */
    public static FunctionDescriptor pixman_f_transform_multiply$descriptor() {
        return pixman_f_transform_multiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_f_transform_multiply(struct pixman_f_transform *dst, const struct pixman_f_transform *l, const struct pixman_f_transform *r)
     * }
     */
    public static MethodHandle pixman_f_transform_multiply$handle() {
        return pixman_f_transform_multiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_f_transform_multiply(struct pixman_f_transform *dst, const struct pixman_f_transform *l, const struct pixman_f_transform *r)
     * }
     */
    public static MemorySegment pixman_f_transform_multiply$address() {
        return pixman_f_transform_multiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_f_transform_multiply(struct pixman_f_transform *dst, const struct pixman_f_transform *l, const struct pixman_f_transform *r)
     * }
     */
    public static void pixman_f_transform_multiply(MemorySegment dst, MemorySegment l, MemorySegment r) {
        var mh$ = pixman_f_transform_multiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_f_transform_multiply", dst, l, r);
            }
            mh$.invokeExact(dst, l, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_f_transform_init_scale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_f_transform_init_scale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_f_transform_init_scale(struct pixman_f_transform *t, double sx, double sy)
     * }
     */
    public static FunctionDescriptor pixman_f_transform_init_scale$descriptor() {
        return pixman_f_transform_init_scale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_f_transform_init_scale(struct pixman_f_transform *t, double sx, double sy)
     * }
     */
    public static MethodHandle pixman_f_transform_init_scale$handle() {
        return pixman_f_transform_init_scale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_f_transform_init_scale(struct pixman_f_transform *t, double sx, double sy)
     * }
     */
    public static MemorySegment pixman_f_transform_init_scale$address() {
        return pixman_f_transform_init_scale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_f_transform_init_scale(struct pixman_f_transform *t, double sx, double sy)
     * }
     */
    public static void pixman_f_transform_init_scale(MemorySegment t, double sx, double sy) {
        var mh$ = pixman_f_transform_init_scale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_f_transform_init_scale", t, sx, sy);
            }
            mh$.invokeExact(t, sx, sy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_f_transform_scale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_f_transform_scale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_scale(struct pixman_f_transform *forward, struct pixman_f_transform *reverse, double sx, double sy)
     * }
     */
    public static FunctionDescriptor pixman_f_transform_scale$descriptor() {
        return pixman_f_transform_scale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_scale(struct pixman_f_transform *forward, struct pixman_f_transform *reverse, double sx, double sy)
     * }
     */
    public static MethodHandle pixman_f_transform_scale$handle() {
        return pixman_f_transform_scale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_scale(struct pixman_f_transform *forward, struct pixman_f_transform *reverse, double sx, double sy)
     * }
     */
    public static MemorySegment pixman_f_transform_scale$address() {
        return pixman_f_transform_scale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_scale(struct pixman_f_transform *forward, struct pixman_f_transform *reverse, double sx, double sy)
     * }
     */
    public static int pixman_f_transform_scale(MemorySegment forward, MemorySegment reverse, double sx, double sy) {
        var mh$ = pixman_f_transform_scale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_f_transform_scale", forward, reverse, sx, sy);
            }
            return (int)mh$.invokeExact(forward, reverse, sx, sy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_f_transform_init_rotate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_f_transform_init_rotate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_f_transform_init_rotate(struct pixman_f_transform *t, double cos, double sin)
     * }
     */
    public static FunctionDescriptor pixman_f_transform_init_rotate$descriptor() {
        return pixman_f_transform_init_rotate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_f_transform_init_rotate(struct pixman_f_transform *t, double cos, double sin)
     * }
     */
    public static MethodHandle pixman_f_transform_init_rotate$handle() {
        return pixman_f_transform_init_rotate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_f_transform_init_rotate(struct pixman_f_transform *t, double cos, double sin)
     * }
     */
    public static MemorySegment pixman_f_transform_init_rotate$address() {
        return pixman_f_transform_init_rotate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_f_transform_init_rotate(struct pixman_f_transform *t, double cos, double sin)
     * }
     */
    public static void pixman_f_transform_init_rotate(MemorySegment t, double cos, double sin) {
        var mh$ = pixman_f_transform_init_rotate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_f_transform_init_rotate", t, cos, sin);
            }
            mh$.invokeExact(t, cos, sin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_f_transform_rotate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_f_transform_rotate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_rotate(struct pixman_f_transform *forward, struct pixman_f_transform *reverse, double c, double s)
     * }
     */
    public static FunctionDescriptor pixman_f_transform_rotate$descriptor() {
        return pixman_f_transform_rotate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_rotate(struct pixman_f_transform *forward, struct pixman_f_transform *reverse, double c, double s)
     * }
     */
    public static MethodHandle pixman_f_transform_rotate$handle() {
        return pixman_f_transform_rotate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_rotate(struct pixman_f_transform *forward, struct pixman_f_transform *reverse, double c, double s)
     * }
     */
    public static MemorySegment pixman_f_transform_rotate$address() {
        return pixman_f_transform_rotate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_rotate(struct pixman_f_transform *forward, struct pixman_f_transform *reverse, double c, double s)
     * }
     */
    public static int pixman_f_transform_rotate(MemorySegment forward, MemorySegment reverse, double c, double s) {
        var mh$ = pixman_f_transform_rotate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_f_transform_rotate", forward, reverse, c, s);
            }
            return (int)mh$.invokeExact(forward, reverse, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_f_transform_init_translate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_f_transform_init_translate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_f_transform_init_translate(struct pixman_f_transform *t, double tx, double ty)
     * }
     */
    public static FunctionDescriptor pixman_f_transform_init_translate$descriptor() {
        return pixman_f_transform_init_translate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_f_transform_init_translate(struct pixman_f_transform *t, double tx, double ty)
     * }
     */
    public static MethodHandle pixman_f_transform_init_translate$handle() {
        return pixman_f_transform_init_translate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_f_transform_init_translate(struct pixman_f_transform *t, double tx, double ty)
     * }
     */
    public static MemorySegment pixman_f_transform_init_translate$address() {
        return pixman_f_transform_init_translate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_f_transform_init_translate(struct pixman_f_transform *t, double tx, double ty)
     * }
     */
    public static void pixman_f_transform_init_translate(MemorySegment t, double tx, double ty) {
        var mh$ = pixman_f_transform_init_translate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_f_transform_init_translate", t, tx, ty);
            }
            mh$.invokeExact(t, tx, ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_f_transform_translate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_f_transform_translate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_translate(struct pixman_f_transform *forward, struct pixman_f_transform *reverse, double tx, double ty)
     * }
     */
    public static FunctionDescriptor pixman_f_transform_translate$descriptor() {
        return pixman_f_transform_translate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_translate(struct pixman_f_transform *forward, struct pixman_f_transform *reverse, double tx, double ty)
     * }
     */
    public static MethodHandle pixman_f_transform_translate$handle() {
        return pixman_f_transform_translate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_translate(struct pixman_f_transform *forward, struct pixman_f_transform *reverse, double tx, double ty)
     * }
     */
    public static MemorySegment pixman_f_transform_translate$address() {
        return pixman_f_transform_translate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_translate(struct pixman_f_transform *forward, struct pixman_f_transform *reverse, double tx, double ty)
     * }
     */
    public static int pixman_f_transform_translate(MemorySegment forward, MemorySegment reverse, double tx, double ty) {
        var mh$ = pixman_f_transform_translate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_f_transform_translate", forward, reverse, tx, ty);
            }
            return (int)mh$.invokeExact(forward, reverse, tx, ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_f_transform_bounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_f_transform_bounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_bounds(const struct pixman_f_transform *t, struct pixman_box16 *b)
     * }
     */
    public static FunctionDescriptor pixman_f_transform_bounds$descriptor() {
        return pixman_f_transform_bounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_bounds(const struct pixman_f_transform *t, struct pixman_box16 *b)
     * }
     */
    public static MethodHandle pixman_f_transform_bounds$handle() {
        return pixman_f_transform_bounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_bounds(const struct pixman_f_transform *t, struct pixman_box16 *b)
     * }
     */
    public static MemorySegment pixman_f_transform_bounds$address() {
        return pixman_f_transform_bounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_f_transform_bounds(const struct pixman_f_transform *t, struct pixman_box16 *b)
     * }
     */
    public static int pixman_f_transform_bounds(MemorySegment t, MemorySegment b) {
        var mh$ = pixman_f_transform_bounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_f_transform_bounds", t, b);
            }
            return (int)mh$.invokeExact(t, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_f_transform_init_identity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_f_transform_init_identity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_f_transform_init_identity(struct pixman_f_transform *t)
     * }
     */
    public static FunctionDescriptor pixman_f_transform_init_identity$descriptor() {
        return pixman_f_transform_init_identity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_f_transform_init_identity(struct pixman_f_transform *t)
     * }
     */
    public static MethodHandle pixman_f_transform_init_identity$handle() {
        return pixman_f_transform_init_identity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_f_transform_init_identity(struct pixman_f_transform *t)
     * }
     */
    public static MemorySegment pixman_f_transform_init_identity$address() {
        return pixman_f_transform_init_identity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_f_transform_init_identity(struct pixman_f_transform *t)
     * }
     */
    public static void pixman_f_transform_init_identity(MemorySegment t) {
        var mh$ = pixman_f_transform_init_identity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_f_transform_init_identity", t);
            }
            mh$.invokeExact(t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PIXMAN_REPEAT_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_REPEAT_NONE = 0
     * }
     */
    public static int PIXMAN_REPEAT_NONE() {
        return PIXMAN_REPEAT_NONE;
    }
    private static final int PIXMAN_REPEAT_NORMAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_REPEAT_NORMAL = 1
     * }
     */
    public static int PIXMAN_REPEAT_NORMAL() {
        return PIXMAN_REPEAT_NORMAL;
    }
    private static final int PIXMAN_REPEAT_PAD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_REPEAT_PAD = 2
     * }
     */
    public static int PIXMAN_REPEAT_PAD() {
        return PIXMAN_REPEAT_PAD;
    }
    private static final int PIXMAN_REPEAT_REFLECT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_REPEAT_REFLECT = 3
     * }
     */
    public static int PIXMAN_REPEAT_REFLECT() {
        return PIXMAN_REPEAT_REFLECT;
    }
    private static final int PIXMAN_DITHER_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_DITHER_NONE = 0
     * }
     */
    public static int PIXMAN_DITHER_NONE() {
        return PIXMAN_DITHER_NONE;
    }
    private static final int PIXMAN_DITHER_FAST = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_DITHER_FAST = 1
     * }
     */
    public static int PIXMAN_DITHER_FAST() {
        return PIXMAN_DITHER_FAST;
    }
    private static final int PIXMAN_DITHER_GOOD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_DITHER_GOOD = 2
     * }
     */
    public static int PIXMAN_DITHER_GOOD() {
        return PIXMAN_DITHER_GOOD;
    }
    private static final int PIXMAN_DITHER_BEST = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_DITHER_BEST = 3
     * }
     */
    public static int PIXMAN_DITHER_BEST() {
        return PIXMAN_DITHER_BEST;
    }
    private static final int PIXMAN_DITHER_ORDERED_BAYER_8 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_DITHER_ORDERED_BAYER_8 = 4
     * }
     */
    public static int PIXMAN_DITHER_ORDERED_BAYER_8() {
        return PIXMAN_DITHER_ORDERED_BAYER_8;
    }
    private static final int PIXMAN_DITHER_ORDERED_BLUE_NOISE_64 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_DITHER_ORDERED_BLUE_NOISE_64 = 5
     * }
     */
    public static int PIXMAN_DITHER_ORDERED_BLUE_NOISE_64() {
        return PIXMAN_DITHER_ORDERED_BLUE_NOISE_64;
    }
    private static final int PIXMAN_FILTER_FAST = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_FILTER_FAST = 0
     * }
     */
    public static int PIXMAN_FILTER_FAST() {
        return PIXMAN_FILTER_FAST;
    }
    private static final int PIXMAN_FILTER_GOOD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_FILTER_GOOD = 1
     * }
     */
    public static int PIXMAN_FILTER_GOOD() {
        return PIXMAN_FILTER_GOOD;
    }
    private static final int PIXMAN_FILTER_BEST = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_FILTER_BEST = 2
     * }
     */
    public static int PIXMAN_FILTER_BEST() {
        return PIXMAN_FILTER_BEST;
    }
    private static final int PIXMAN_FILTER_NEAREST = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_FILTER_NEAREST = 3
     * }
     */
    public static int PIXMAN_FILTER_NEAREST() {
        return PIXMAN_FILTER_NEAREST;
    }
    private static final int PIXMAN_FILTER_BILINEAR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_FILTER_BILINEAR = 4
     * }
     */
    public static int PIXMAN_FILTER_BILINEAR() {
        return PIXMAN_FILTER_BILINEAR;
    }
    private static final int PIXMAN_FILTER_CONVOLUTION = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_FILTER_CONVOLUTION = 5
     * }
     */
    public static int PIXMAN_FILTER_CONVOLUTION() {
        return PIXMAN_FILTER_CONVOLUTION;
    }
    private static final int PIXMAN_FILTER_SEPARABLE_CONVOLUTION = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_FILTER_SEPARABLE_CONVOLUTION = 6
     * }
     */
    public static int PIXMAN_FILTER_SEPARABLE_CONVOLUTION() {
        return PIXMAN_FILTER_SEPARABLE_CONVOLUTION;
    }
    private static final int PIXMAN_OP_CLEAR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_CLEAR = 0
     * }
     */
    public static int PIXMAN_OP_CLEAR() {
        return PIXMAN_OP_CLEAR;
    }
    private static final int PIXMAN_OP_SRC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_SRC = 1
     * }
     */
    public static int PIXMAN_OP_SRC() {
        return PIXMAN_OP_SRC;
    }
    private static final int PIXMAN_OP_DST = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_DST = 2
     * }
     */
    public static int PIXMAN_OP_DST() {
        return PIXMAN_OP_DST;
    }
    private static final int PIXMAN_OP_OVER = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_OVER = 3
     * }
     */
    public static int PIXMAN_OP_OVER() {
        return PIXMAN_OP_OVER;
    }
    private static final int PIXMAN_OP_OVER_REVERSE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_OVER_REVERSE = 4
     * }
     */
    public static int PIXMAN_OP_OVER_REVERSE() {
        return PIXMAN_OP_OVER_REVERSE;
    }
    private static final int PIXMAN_OP_IN = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_IN = 5
     * }
     */
    public static int PIXMAN_OP_IN() {
        return PIXMAN_OP_IN;
    }
    private static final int PIXMAN_OP_IN_REVERSE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_IN_REVERSE = 6
     * }
     */
    public static int PIXMAN_OP_IN_REVERSE() {
        return PIXMAN_OP_IN_REVERSE;
    }
    private static final int PIXMAN_OP_OUT = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_OUT = 7
     * }
     */
    public static int PIXMAN_OP_OUT() {
        return PIXMAN_OP_OUT;
    }
    private static final int PIXMAN_OP_OUT_REVERSE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_OUT_REVERSE = 8
     * }
     */
    public static int PIXMAN_OP_OUT_REVERSE() {
        return PIXMAN_OP_OUT_REVERSE;
    }
    private static final int PIXMAN_OP_ATOP = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_ATOP = 9
     * }
     */
    public static int PIXMAN_OP_ATOP() {
        return PIXMAN_OP_ATOP;
    }
    private static final int PIXMAN_OP_ATOP_REVERSE = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_ATOP_REVERSE = 10
     * }
     */
    public static int PIXMAN_OP_ATOP_REVERSE() {
        return PIXMAN_OP_ATOP_REVERSE;
    }
    private static final int PIXMAN_OP_XOR = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_XOR = 11
     * }
     */
    public static int PIXMAN_OP_XOR() {
        return PIXMAN_OP_XOR;
    }
    private static final int PIXMAN_OP_ADD = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_ADD = 12
     * }
     */
    public static int PIXMAN_OP_ADD() {
        return PIXMAN_OP_ADD;
    }
    private static final int PIXMAN_OP_SATURATE = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_SATURATE = 13
     * }
     */
    public static int PIXMAN_OP_SATURATE() {
        return PIXMAN_OP_SATURATE;
    }
    private static final int PIXMAN_OP_DISJOINT_CLEAR = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_DISJOINT_CLEAR = 16
     * }
     */
    public static int PIXMAN_OP_DISJOINT_CLEAR() {
        return PIXMAN_OP_DISJOINT_CLEAR;
    }
    private static final int PIXMAN_OP_DISJOINT_SRC = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_DISJOINT_SRC = 17
     * }
     */
    public static int PIXMAN_OP_DISJOINT_SRC() {
        return PIXMAN_OP_DISJOINT_SRC;
    }
    private static final int PIXMAN_OP_DISJOINT_DST = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_DISJOINT_DST = 18
     * }
     */
    public static int PIXMAN_OP_DISJOINT_DST() {
        return PIXMAN_OP_DISJOINT_DST;
    }
    private static final int PIXMAN_OP_DISJOINT_OVER = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_DISJOINT_OVER = 19
     * }
     */
    public static int PIXMAN_OP_DISJOINT_OVER() {
        return PIXMAN_OP_DISJOINT_OVER;
    }
    private static final int PIXMAN_OP_DISJOINT_OVER_REVERSE = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_DISJOINT_OVER_REVERSE = 20
     * }
     */
    public static int PIXMAN_OP_DISJOINT_OVER_REVERSE() {
        return PIXMAN_OP_DISJOINT_OVER_REVERSE;
    }
    private static final int PIXMAN_OP_DISJOINT_IN = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_DISJOINT_IN = 21
     * }
     */
    public static int PIXMAN_OP_DISJOINT_IN() {
        return PIXMAN_OP_DISJOINT_IN;
    }
    private static final int PIXMAN_OP_DISJOINT_IN_REVERSE = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_DISJOINT_IN_REVERSE = 22
     * }
     */
    public static int PIXMAN_OP_DISJOINT_IN_REVERSE() {
        return PIXMAN_OP_DISJOINT_IN_REVERSE;
    }
    private static final int PIXMAN_OP_DISJOINT_OUT = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_DISJOINT_OUT = 23
     * }
     */
    public static int PIXMAN_OP_DISJOINT_OUT() {
        return PIXMAN_OP_DISJOINT_OUT;
    }
    private static final int PIXMAN_OP_DISJOINT_OUT_REVERSE = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_DISJOINT_OUT_REVERSE = 24
     * }
     */
    public static int PIXMAN_OP_DISJOINT_OUT_REVERSE() {
        return PIXMAN_OP_DISJOINT_OUT_REVERSE;
    }
    private static final int PIXMAN_OP_DISJOINT_ATOP = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_DISJOINT_ATOP = 25
     * }
     */
    public static int PIXMAN_OP_DISJOINT_ATOP() {
        return PIXMAN_OP_DISJOINT_ATOP;
    }
    private static final int PIXMAN_OP_DISJOINT_ATOP_REVERSE = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_DISJOINT_ATOP_REVERSE = 26
     * }
     */
    public static int PIXMAN_OP_DISJOINT_ATOP_REVERSE() {
        return PIXMAN_OP_DISJOINT_ATOP_REVERSE;
    }
    private static final int PIXMAN_OP_DISJOINT_XOR = (int)27L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_DISJOINT_XOR = 27
     * }
     */
    public static int PIXMAN_OP_DISJOINT_XOR() {
        return PIXMAN_OP_DISJOINT_XOR;
    }
    private static final int PIXMAN_OP_CONJOINT_CLEAR = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_CONJOINT_CLEAR = 32
     * }
     */
    public static int PIXMAN_OP_CONJOINT_CLEAR() {
        return PIXMAN_OP_CONJOINT_CLEAR;
    }
    private static final int PIXMAN_OP_CONJOINT_SRC = (int)33L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_CONJOINT_SRC = 33
     * }
     */
    public static int PIXMAN_OP_CONJOINT_SRC() {
        return PIXMAN_OP_CONJOINT_SRC;
    }
    private static final int PIXMAN_OP_CONJOINT_DST = (int)34L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_CONJOINT_DST = 34
     * }
     */
    public static int PIXMAN_OP_CONJOINT_DST() {
        return PIXMAN_OP_CONJOINT_DST;
    }
    private static final int PIXMAN_OP_CONJOINT_OVER = (int)35L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_CONJOINT_OVER = 35
     * }
     */
    public static int PIXMAN_OP_CONJOINT_OVER() {
        return PIXMAN_OP_CONJOINT_OVER;
    }
    private static final int PIXMAN_OP_CONJOINT_OVER_REVERSE = (int)36L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_CONJOINT_OVER_REVERSE = 36
     * }
     */
    public static int PIXMAN_OP_CONJOINT_OVER_REVERSE() {
        return PIXMAN_OP_CONJOINT_OVER_REVERSE;
    }
    private static final int PIXMAN_OP_CONJOINT_IN = (int)37L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_CONJOINT_IN = 37
     * }
     */
    public static int PIXMAN_OP_CONJOINT_IN() {
        return PIXMAN_OP_CONJOINT_IN;
    }
    private static final int PIXMAN_OP_CONJOINT_IN_REVERSE = (int)38L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_CONJOINT_IN_REVERSE = 38
     * }
     */
    public static int PIXMAN_OP_CONJOINT_IN_REVERSE() {
        return PIXMAN_OP_CONJOINT_IN_REVERSE;
    }
    private static final int PIXMAN_OP_CONJOINT_OUT = (int)39L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_CONJOINT_OUT = 39
     * }
     */
    public static int PIXMAN_OP_CONJOINT_OUT() {
        return PIXMAN_OP_CONJOINT_OUT;
    }
    private static final int PIXMAN_OP_CONJOINT_OUT_REVERSE = (int)40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_CONJOINT_OUT_REVERSE = 40
     * }
     */
    public static int PIXMAN_OP_CONJOINT_OUT_REVERSE() {
        return PIXMAN_OP_CONJOINT_OUT_REVERSE;
    }
    private static final int PIXMAN_OP_CONJOINT_ATOP = (int)41L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_CONJOINT_ATOP = 41
     * }
     */
    public static int PIXMAN_OP_CONJOINT_ATOP() {
        return PIXMAN_OP_CONJOINT_ATOP;
    }
    private static final int PIXMAN_OP_CONJOINT_ATOP_REVERSE = (int)42L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_CONJOINT_ATOP_REVERSE = 42
     * }
     */
    public static int PIXMAN_OP_CONJOINT_ATOP_REVERSE() {
        return PIXMAN_OP_CONJOINT_ATOP_REVERSE;
    }
    private static final int PIXMAN_OP_CONJOINT_XOR = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_CONJOINT_XOR = 43
     * }
     */
    public static int PIXMAN_OP_CONJOINT_XOR() {
        return PIXMAN_OP_CONJOINT_XOR;
    }
    private static final int PIXMAN_OP_MULTIPLY = (int)48L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_MULTIPLY = 48
     * }
     */
    public static int PIXMAN_OP_MULTIPLY() {
        return PIXMAN_OP_MULTIPLY;
    }
    private static final int PIXMAN_OP_SCREEN = (int)49L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_SCREEN = 49
     * }
     */
    public static int PIXMAN_OP_SCREEN() {
        return PIXMAN_OP_SCREEN;
    }
    private static final int PIXMAN_OP_OVERLAY = (int)50L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_OVERLAY = 50
     * }
     */
    public static int PIXMAN_OP_OVERLAY() {
        return PIXMAN_OP_OVERLAY;
    }
    private static final int PIXMAN_OP_DARKEN = (int)51L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_DARKEN = 51
     * }
     */
    public static int PIXMAN_OP_DARKEN() {
        return PIXMAN_OP_DARKEN;
    }
    private static final int PIXMAN_OP_LIGHTEN = (int)52L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_LIGHTEN = 52
     * }
     */
    public static int PIXMAN_OP_LIGHTEN() {
        return PIXMAN_OP_LIGHTEN;
    }
    private static final int PIXMAN_OP_COLOR_DODGE = (int)53L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_COLOR_DODGE = 53
     * }
     */
    public static int PIXMAN_OP_COLOR_DODGE() {
        return PIXMAN_OP_COLOR_DODGE;
    }
    private static final int PIXMAN_OP_COLOR_BURN = (int)54L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_COLOR_BURN = 54
     * }
     */
    public static int PIXMAN_OP_COLOR_BURN() {
        return PIXMAN_OP_COLOR_BURN;
    }
    private static final int PIXMAN_OP_HARD_LIGHT = (int)55L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_HARD_LIGHT = 55
     * }
     */
    public static int PIXMAN_OP_HARD_LIGHT() {
        return PIXMAN_OP_HARD_LIGHT;
    }
    private static final int PIXMAN_OP_SOFT_LIGHT = (int)56L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_SOFT_LIGHT = 56
     * }
     */
    public static int PIXMAN_OP_SOFT_LIGHT() {
        return PIXMAN_OP_SOFT_LIGHT;
    }
    private static final int PIXMAN_OP_DIFFERENCE = (int)57L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_DIFFERENCE = 57
     * }
     */
    public static int PIXMAN_OP_DIFFERENCE() {
        return PIXMAN_OP_DIFFERENCE;
    }
    private static final int PIXMAN_OP_EXCLUSION = (int)58L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_EXCLUSION = 58
     * }
     */
    public static int PIXMAN_OP_EXCLUSION() {
        return PIXMAN_OP_EXCLUSION;
    }
    private static final int PIXMAN_OP_HSL_HUE = (int)59L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_HSL_HUE = 59
     * }
     */
    public static int PIXMAN_OP_HSL_HUE() {
        return PIXMAN_OP_HSL_HUE;
    }
    private static final int PIXMAN_OP_HSL_SATURATION = (int)60L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_HSL_SATURATION = 60
     * }
     */
    public static int PIXMAN_OP_HSL_SATURATION() {
        return PIXMAN_OP_HSL_SATURATION;
    }
    private static final int PIXMAN_OP_HSL_COLOR = (int)61L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_HSL_COLOR = 61
     * }
     */
    public static int PIXMAN_OP_HSL_COLOR() {
        return PIXMAN_OP_HSL_COLOR;
    }
    private static final int PIXMAN_OP_HSL_LUMINOSITY = (int)62L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_OP_HSL_LUMINOSITY = 62
     * }
     */
    public static int PIXMAN_OP_HSL_LUMINOSITY() {
        return PIXMAN_OP_HSL_LUMINOSITY;
    }
    private static final int PIXMAN_REGION_OUT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_REGION_OUT = 0
     * }
     */
    public static int PIXMAN_REGION_OUT() {
        return PIXMAN_REGION_OUT;
    }
    private static final int PIXMAN_REGION_IN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_REGION_IN = 1
     * }
     */
    public static int PIXMAN_REGION_IN() {
        return PIXMAN_REGION_IN;
    }
    private static final int PIXMAN_REGION_PART = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_REGION_PART = 2
     * }
     */
    public static int PIXMAN_REGION_PART() {
        return PIXMAN_REGION_PART;
    }

    private static class pixman_region_set_static_pointers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_set_static_pointers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_region_set_static_pointers(pixman_box16_t *empty_box, pixman_region16_data_t *empty_data, pixman_region16_data_t *broken_data)
     * }
     */
    public static FunctionDescriptor pixman_region_set_static_pointers$descriptor() {
        return pixman_region_set_static_pointers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_region_set_static_pointers(pixman_box16_t *empty_box, pixman_region16_data_t *empty_data, pixman_region16_data_t *broken_data)
     * }
     */
    public static MethodHandle pixman_region_set_static_pointers$handle() {
        return pixman_region_set_static_pointers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_region_set_static_pointers(pixman_box16_t *empty_box, pixman_region16_data_t *empty_data, pixman_region16_data_t *broken_data)
     * }
     */
    public static MemorySegment pixman_region_set_static_pointers$address() {
        return pixman_region_set_static_pointers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_region_set_static_pointers(pixman_box16_t *empty_box, pixman_region16_data_t *empty_data, pixman_region16_data_t *broken_data)
     * }
     */
    public static void pixman_region_set_static_pointers(MemorySegment empty_box, MemorySegment empty_data, MemorySegment broken_data) {
        var mh$ = pixman_region_set_static_pointers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_set_static_pointers", empty_box, empty_data, broken_data);
            }
            mh$.invokeExact(empty_box, empty_data, broken_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_region_init(pixman_region16_t *region)
     * }
     */
    public static FunctionDescriptor pixman_region_init$descriptor() {
        return pixman_region_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_region_init(pixman_region16_t *region)
     * }
     */
    public static MethodHandle pixman_region_init$handle() {
        return pixman_region_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_region_init(pixman_region16_t *region)
     * }
     */
    public static MemorySegment pixman_region_init$address() {
        return pixman_region_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_region_init(pixman_region16_t *region)
     * }
     */
    public static void pixman_region_init(MemorySegment region) {
        var mh$ = pixman_region_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_init", region);
            }
            mh$.invokeExact(region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_init_rect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_init_rect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_region_init_rect(pixman_region16_t *region, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static FunctionDescriptor pixman_region_init_rect$descriptor() {
        return pixman_region_init_rect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_region_init_rect(pixman_region16_t *region, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static MethodHandle pixman_region_init_rect$handle() {
        return pixman_region_init_rect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_region_init_rect(pixman_region16_t *region, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static MemorySegment pixman_region_init_rect$address() {
        return pixman_region_init_rect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_region_init_rect(pixman_region16_t *region, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static void pixman_region_init_rect(MemorySegment region, int x, int y, int width, int height) {
        var mh$ = pixman_region_init_rect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_init_rect", region, x, y, width, height);
            }
            mh$.invokeExact(region, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_init_rects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_init_rects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_init_rects(pixman_region16_t *region, const pixman_box16_t *boxes, int count)
     * }
     */
    public static FunctionDescriptor pixman_region_init_rects$descriptor() {
        return pixman_region_init_rects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_init_rects(pixman_region16_t *region, const pixman_box16_t *boxes, int count)
     * }
     */
    public static MethodHandle pixman_region_init_rects$handle() {
        return pixman_region_init_rects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_init_rects(pixman_region16_t *region, const pixman_box16_t *boxes, int count)
     * }
     */
    public static MemorySegment pixman_region_init_rects$address() {
        return pixman_region_init_rects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_init_rects(pixman_region16_t *region, const pixman_box16_t *boxes, int count)
     * }
     */
    public static int pixman_region_init_rects(MemorySegment region, MemorySegment boxes, int count) {
        var mh$ = pixman_region_init_rects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_init_rects", region, boxes, count);
            }
            return (int)mh$.invokeExact(region, boxes, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_init_with_extents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_init_with_extents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_region_init_with_extents(pixman_region16_t *region, const pixman_box16_t *extents)
     * }
     */
    public static FunctionDescriptor pixman_region_init_with_extents$descriptor() {
        return pixman_region_init_with_extents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_region_init_with_extents(pixman_region16_t *region, const pixman_box16_t *extents)
     * }
     */
    public static MethodHandle pixman_region_init_with_extents$handle() {
        return pixman_region_init_with_extents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_region_init_with_extents(pixman_region16_t *region, const pixman_box16_t *extents)
     * }
     */
    public static MemorySegment pixman_region_init_with_extents$address() {
        return pixman_region_init_with_extents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_region_init_with_extents(pixman_region16_t *region, const pixman_box16_t *extents)
     * }
     */
    public static void pixman_region_init_with_extents(MemorySegment region, MemorySegment extents) {
        var mh$ = pixman_region_init_with_extents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_init_with_extents", region, extents);
            }
            mh$.invokeExact(region, extents);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_init_from_image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_init_from_image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_region_init_from_image(pixman_region16_t *region, pixman_image_t *image)
     * }
     */
    public static FunctionDescriptor pixman_region_init_from_image$descriptor() {
        return pixman_region_init_from_image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_region_init_from_image(pixman_region16_t *region, pixman_image_t *image)
     * }
     */
    public static MethodHandle pixman_region_init_from_image$handle() {
        return pixman_region_init_from_image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_region_init_from_image(pixman_region16_t *region, pixman_image_t *image)
     * }
     */
    public static MemorySegment pixman_region_init_from_image$address() {
        return pixman_region_init_from_image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_region_init_from_image(pixman_region16_t *region, pixman_image_t *image)
     * }
     */
    public static void pixman_region_init_from_image(MemorySegment region, MemorySegment image) {
        var mh$ = pixman_region_init_from_image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_init_from_image", region, image);
            }
            mh$.invokeExact(region, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_region_fini(pixman_region16_t *region)
     * }
     */
    public static FunctionDescriptor pixman_region_fini$descriptor() {
        return pixman_region_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_region_fini(pixman_region16_t *region)
     * }
     */
    public static MethodHandle pixman_region_fini$handle() {
        return pixman_region_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_region_fini(pixman_region16_t *region)
     * }
     */
    public static MemorySegment pixman_region_fini$address() {
        return pixman_region_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_region_fini(pixman_region16_t *region)
     * }
     */
    public static void pixman_region_fini(MemorySegment region) {
        var mh$ = pixman_region_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_fini", region);
            }
            mh$.invokeExact(region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_translate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_translate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_region_translate(pixman_region16_t *region, int x, int y)
     * }
     */
    public static FunctionDescriptor pixman_region_translate$descriptor() {
        return pixman_region_translate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_region_translate(pixman_region16_t *region, int x, int y)
     * }
     */
    public static MethodHandle pixman_region_translate$handle() {
        return pixman_region_translate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_region_translate(pixman_region16_t *region, int x, int y)
     * }
     */
    public static MemorySegment pixman_region_translate$address() {
        return pixman_region_translate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_region_translate(pixman_region16_t *region, int x, int y)
     * }
     */
    public static void pixman_region_translate(MemorySegment region, int x, int y) {
        var mh$ = pixman_region_translate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_translate", region, x, y);
            }
            mh$.invokeExact(region, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_copy(pixman_region16_t *dest, const pixman_region16_t *source)
     * }
     */
    public static FunctionDescriptor pixman_region_copy$descriptor() {
        return pixman_region_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_copy(pixman_region16_t *dest, const pixman_region16_t *source)
     * }
     */
    public static MethodHandle pixman_region_copy$handle() {
        return pixman_region_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_copy(pixman_region16_t *dest, const pixman_region16_t *source)
     * }
     */
    public static MemorySegment pixman_region_copy$address() {
        return pixman_region_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_copy(pixman_region16_t *dest, const pixman_region16_t *source)
     * }
     */
    public static int pixman_region_copy(MemorySegment dest, MemorySegment source) {
        var mh$ = pixman_region_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_copy", dest, source);
            }
            return (int)mh$.invokeExact(dest, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_intersect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_intersect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_intersect(pixman_region16_t *new_reg, const pixman_region16_t *reg1, const pixman_region16_t *reg2)
     * }
     */
    public static FunctionDescriptor pixman_region_intersect$descriptor() {
        return pixman_region_intersect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_intersect(pixman_region16_t *new_reg, const pixman_region16_t *reg1, const pixman_region16_t *reg2)
     * }
     */
    public static MethodHandle pixman_region_intersect$handle() {
        return pixman_region_intersect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_intersect(pixman_region16_t *new_reg, const pixman_region16_t *reg1, const pixman_region16_t *reg2)
     * }
     */
    public static MemorySegment pixman_region_intersect$address() {
        return pixman_region_intersect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_intersect(pixman_region16_t *new_reg, const pixman_region16_t *reg1, const pixman_region16_t *reg2)
     * }
     */
    public static int pixman_region_intersect(MemorySegment new_reg, MemorySegment reg1, MemorySegment reg2) {
        var mh$ = pixman_region_intersect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_intersect", new_reg, reg1, reg2);
            }
            return (int)mh$.invokeExact(new_reg, reg1, reg2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_union {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_union");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_union(pixman_region16_t *new_reg, const pixman_region16_t *reg1, const pixman_region16_t *reg2)
     * }
     */
    public static FunctionDescriptor pixman_region_union$descriptor() {
        return pixman_region_union.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_union(pixman_region16_t *new_reg, const pixman_region16_t *reg1, const pixman_region16_t *reg2)
     * }
     */
    public static MethodHandle pixman_region_union$handle() {
        return pixman_region_union.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_union(pixman_region16_t *new_reg, const pixman_region16_t *reg1, const pixman_region16_t *reg2)
     * }
     */
    public static MemorySegment pixman_region_union$address() {
        return pixman_region_union.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_union(pixman_region16_t *new_reg, const pixman_region16_t *reg1, const pixman_region16_t *reg2)
     * }
     */
    public static int pixman_region_union(MemorySegment new_reg, MemorySegment reg1, MemorySegment reg2) {
        var mh$ = pixman_region_union.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_union", new_reg, reg1, reg2);
            }
            return (int)mh$.invokeExact(new_reg, reg1, reg2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_union_rect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_union_rect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_union_rect(pixman_region16_t *dest, const pixman_region16_t *source, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static FunctionDescriptor pixman_region_union_rect$descriptor() {
        return pixman_region_union_rect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_union_rect(pixman_region16_t *dest, const pixman_region16_t *source, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static MethodHandle pixman_region_union_rect$handle() {
        return pixman_region_union_rect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_union_rect(pixman_region16_t *dest, const pixman_region16_t *source, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static MemorySegment pixman_region_union_rect$address() {
        return pixman_region_union_rect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_union_rect(pixman_region16_t *dest, const pixman_region16_t *source, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static int pixman_region_union_rect(MemorySegment dest, MemorySegment source, int x, int y, int width, int height) {
        var mh$ = pixman_region_union_rect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_union_rect", dest, source, x, y, width, height);
            }
            return (int)mh$.invokeExact(dest, source, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_intersect_rect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_intersect_rect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_intersect_rect(pixman_region16_t *dest, const pixman_region16_t *source, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static FunctionDescriptor pixman_region_intersect_rect$descriptor() {
        return pixman_region_intersect_rect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_intersect_rect(pixman_region16_t *dest, const pixman_region16_t *source, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static MethodHandle pixman_region_intersect_rect$handle() {
        return pixman_region_intersect_rect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_intersect_rect(pixman_region16_t *dest, const pixman_region16_t *source, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static MemorySegment pixman_region_intersect_rect$address() {
        return pixman_region_intersect_rect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_intersect_rect(pixman_region16_t *dest, const pixman_region16_t *source, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static int pixman_region_intersect_rect(MemorySegment dest, MemorySegment source, int x, int y, int width, int height) {
        var mh$ = pixman_region_intersect_rect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_intersect_rect", dest, source, x, y, width, height);
            }
            return (int)mh$.invokeExact(dest, source, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_subtract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_subtract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_subtract(pixman_region16_t *reg_d, const pixman_region16_t *reg_m, const pixman_region16_t *reg_s)
     * }
     */
    public static FunctionDescriptor pixman_region_subtract$descriptor() {
        return pixman_region_subtract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_subtract(pixman_region16_t *reg_d, const pixman_region16_t *reg_m, const pixman_region16_t *reg_s)
     * }
     */
    public static MethodHandle pixman_region_subtract$handle() {
        return pixman_region_subtract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_subtract(pixman_region16_t *reg_d, const pixman_region16_t *reg_m, const pixman_region16_t *reg_s)
     * }
     */
    public static MemorySegment pixman_region_subtract$address() {
        return pixman_region_subtract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_subtract(pixman_region16_t *reg_d, const pixman_region16_t *reg_m, const pixman_region16_t *reg_s)
     * }
     */
    public static int pixman_region_subtract(MemorySegment reg_d, MemorySegment reg_m, MemorySegment reg_s) {
        var mh$ = pixman_region_subtract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_subtract", reg_d, reg_m, reg_s);
            }
            return (int)mh$.invokeExact(reg_d, reg_m, reg_s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_inverse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_inverse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_inverse(pixman_region16_t *new_reg, const pixman_region16_t *reg1, const pixman_box16_t *inv_rect)
     * }
     */
    public static FunctionDescriptor pixman_region_inverse$descriptor() {
        return pixman_region_inverse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_inverse(pixman_region16_t *new_reg, const pixman_region16_t *reg1, const pixman_box16_t *inv_rect)
     * }
     */
    public static MethodHandle pixman_region_inverse$handle() {
        return pixman_region_inverse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_inverse(pixman_region16_t *new_reg, const pixman_region16_t *reg1, const pixman_box16_t *inv_rect)
     * }
     */
    public static MemorySegment pixman_region_inverse$address() {
        return pixman_region_inverse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_inverse(pixman_region16_t *new_reg, const pixman_region16_t *reg1, const pixman_box16_t *inv_rect)
     * }
     */
    public static int pixman_region_inverse(MemorySegment new_reg, MemorySegment reg1, MemorySegment inv_rect) {
        var mh$ = pixman_region_inverse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_inverse", new_reg, reg1, inv_rect);
            }
            return (int)mh$.invokeExact(new_reg, reg1, inv_rect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_contains_point {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_contains_point");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_contains_point(const pixman_region16_t *region, int x, int y, pixman_box16_t *box)
     * }
     */
    public static FunctionDescriptor pixman_region_contains_point$descriptor() {
        return pixman_region_contains_point.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_contains_point(const pixman_region16_t *region, int x, int y, pixman_box16_t *box)
     * }
     */
    public static MethodHandle pixman_region_contains_point$handle() {
        return pixman_region_contains_point.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_contains_point(const pixman_region16_t *region, int x, int y, pixman_box16_t *box)
     * }
     */
    public static MemorySegment pixman_region_contains_point$address() {
        return pixman_region_contains_point.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_contains_point(const pixman_region16_t *region, int x, int y, pixman_box16_t *box)
     * }
     */
    public static int pixman_region_contains_point(MemorySegment region, int x, int y, MemorySegment box) {
        var mh$ = pixman_region_contains_point.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_contains_point", region, x, y, box);
            }
            return (int)mh$.invokeExact(region, x, y, box);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_contains_rectangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_contains_rectangle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_region_overlap_t pixman_region_contains_rectangle(const pixman_region16_t *region, const pixman_box16_t *prect)
     * }
     */
    public static FunctionDescriptor pixman_region_contains_rectangle$descriptor() {
        return pixman_region_contains_rectangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_region_overlap_t pixman_region_contains_rectangle(const pixman_region16_t *region, const pixman_box16_t *prect)
     * }
     */
    public static MethodHandle pixman_region_contains_rectangle$handle() {
        return pixman_region_contains_rectangle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_region_overlap_t pixman_region_contains_rectangle(const pixman_region16_t *region, const pixman_box16_t *prect)
     * }
     */
    public static MemorySegment pixman_region_contains_rectangle$address() {
        return pixman_region_contains_rectangle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_region_overlap_t pixman_region_contains_rectangle(const pixman_region16_t *region, const pixman_box16_t *prect)
     * }
     */
    public static int pixman_region_contains_rectangle(MemorySegment region, MemorySegment prect) {
        var mh$ = pixman_region_contains_rectangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_contains_rectangle", region, prect);
            }
            return (int)mh$.invokeExact(region, prect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_empty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_empty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_empty(const pixman_region16_t *region)
     * }
     */
    public static FunctionDescriptor pixman_region_empty$descriptor() {
        return pixman_region_empty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_empty(const pixman_region16_t *region)
     * }
     */
    public static MethodHandle pixman_region_empty$handle() {
        return pixman_region_empty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_empty(const pixman_region16_t *region)
     * }
     */
    public static MemorySegment pixman_region_empty$address() {
        return pixman_region_empty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_empty(const pixman_region16_t *region)
     * }
     */
    public static int pixman_region_empty(MemorySegment region) {
        var mh$ = pixman_region_empty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_empty", region);
            }
            return (int)mh$.invokeExact(region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_not_empty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_not_empty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_not_empty(const pixman_region16_t *region)
     * }
     */
    public static FunctionDescriptor pixman_region_not_empty$descriptor() {
        return pixman_region_not_empty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_not_empty(const pixman_region16_t *region)
     * }
     */
    public static MethodHandle pixman_region_not_empty$handle() {
        return pixman_region_not_empty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_not_empty(const pixman_region16_t *region)
     * }
     */
    public static MemorySegment pixman_region_not_empty$address() {
        return pixman_region_not_empty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_not_empty(const pixman_region16_t *region)
     * }
     */
    public static int pixman_region_not_empty(MemorySegment region) {
        var mh$ = pixman_region_not_empty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_not_empty", region);
            }
            return (int)mh$.invokeExact(region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_extents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_extents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_box16_t *pixman_region_extents(const pixman_region16_t *region)
     * }
     */
    public static FunctionDescriptor pixman_region_extents$descriptor() {
        return pixman_region_extents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_box16_t *pixman_region_extents(const pixman_region16_t *region)
     * }
     */
    public static MethodHandle pixman_region_extents$handle() {
        return pixman_region_extents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_box16_t *pixman_region_extents(const pixman_region16_t *region)
     * }
     */
    public static MemorySegment pixman_region_extents$address() {
        return pixman_region_extents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_box16_t *pixman_region_extents(const pixman_region16_t *region)
     * }
     */
    public static MemorySegment pixman_region_extents(MemorySegment region) {
        var mh$ = pixman_region_extents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_extents", region);
            }
            return (MemorySegment)mh$.invokeExact(region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_n_rects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_n_rects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pixman_region_n_rects(const pixman_region16_t *region)
     * }
     */
    public static FunctionDescriptor pixman_region_n_rects$descriptor() {
        return pixman_region_n_rects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pixman_region_n_rects(const pixman_region16_t *region)
     * }
     */
    public static MethodHandle pixman_region_n_rects$handle() {
        return pixman_region_n_rects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pixman_region_n_rects(const pixman_region16_t *region)
     * }
     */
    public static MemorySegment pixman_region_n_rects$address() {
        return pixman_region_n_rects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pixman_region_n_rects(const pixman_region16_t *region)
     * }
     */
    public static int pixman_region_n_rects(MemorySegment region) {
        var mh$ = pixman_region_n_rects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_n_rects", region);
            }
            return (int)mh$.invokeExact(region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_rectangles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_rectangles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_box16_t *pixman_region_rectangles(const pixman_region16_t *region, int *n_rects)
     * }
     */
    public static FunctionDescriptor pixman_region_rectangles$descriptor() {
        return pixman_region_rectangles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_box16_t *pixman_region_rectangles(const pixman_region16_t *region, int *n_rects)
     * }
     */
    public static MethodHandle pixman_region_rectangles$handle() {
        return pixman_region_rectangles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_box16_t *pixman_region_rectangles(const pixman_region16_t *region, int *n_rects)
     * }
     */
    public static MemorySegment pixman_region_rectangles$address() {
        return pixman_region_rectangles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_box16_t *pixman_region_rectangles(const pixman_region16_t *region, int *n_rects)
     * }
     */
    public static MemorySegment pixman_region_rectangles(MemorySegment region, MemorySegment n_rects) {
        var mh$ = pixman_region_rectangles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_rectangles", region, n_rects);
            }
            return (MemorySegment)mh$.invokeExact(region, n_rects);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_equal(const pixman_region16_t *region1, const pixman_region16_t *region2)
     * }
     */
    public static FunctionDescriptor pixman_region_equal$descriptor() {
        return pixman_region_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_equal(const pixman_region16_t *region1, const pixman_region16_t *region2)
     * }
     */
    public static MethodHandle pixman_region_equal$handle() {
        return pixman_region_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_equal(const pixman_region16_t *region1, const pixman_region16_t *region2)
     * }
     */
    public static MemorySegment pixman_region_equal$address() {
        return pixman_region_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_equal(const pixman_region16_t *region1, const pixman_region16_t *region2)
     * }
     */
    public static int pixman_region_equal(MemorySegment region1, MemorySegment region2) {
        var mh$ = pixman_region_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_equal", region1, region2);
            }
            return (int)mh$.invokeExact(region1, region2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_selfcheck {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_selfcheck");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_selfcheck(pixman_region16_t *region)
     * }
     */
    public static FunctionDescriptor pixman_region_selfcheck$descriptor() {
        return pixman_region_selfcheck.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_selfcheck(pixman_region16_t *region)
     * }
     */
    public static MethodHandle pixman_region_selfcheck$handle() {
        return pixman_region_selfcheck.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_selfcheck(pixman_region16_t *region)
     * }
     */
    public static MemorySegment pixman_region_selfcheck$address() {
        return pixman_region_selfcheck.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region_selfcheck(pixman_region16_t *region)
     * }
     */
    public static int pixman_region_selfcheck(MemorySegment region) {
        var mh$ = pixman_region_selfcheck.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_selfcheck", region);
            }
            return (int)mh$.invokeExact(region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_region_reset(pixman_region16_t *region, const pixman_box16_t *box)
     * }
     */
    public static FunctionDescriptor pixman_region_reset$descriptor() {
        return pixman_region_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_region_reset(pixman_region16_t *region, const pixman_box16_t *box)
     * }
     */
    public static MethodHandle pixman_region_reset$handle() {
        return pixman_region_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_region_reset(pixman_region16_t *region, const pixman_box16_t *box)
     * }
     */
    public static MemorySegment pixman_region_reset$address() {
        return pixman_region_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_region_reset(pixman_region16_t *region, const pixman_box16_t *box)
     * }
     */
    public static void pixman_region_reset(MemorySegment region, MemorySegment box) {
        var mh$ = pixman_region_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_reset", region, box);
            }
            mh$.invokeExact(region, box);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_region_clear(pixman_region16_t *region)
     * }
     */
    public static FunctionDescriptor pixman_region_clear$descriptor() {
        return pixman_region_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_region_clear(pixman_region16_t *region)
     * }
     */
    public static MethodHandle pixman_region_clear$handle() {
        return pixman_region_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_region_clear(pixman_region16_t *region)
     * }
     */
    public static MemorySegment pixman_region_clear$address() {
        return pixman_region_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_region_clear(pixman_region16_t *region)
     * }
     */
    public static void pixman_region_clear(MemorySegment region) {
        var mh$ = pixman_region_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region_clear", region);
            }
            mh$.invokeExact(region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_region32_init(pixman_region32_t *region)
     * }
     */
    public static FunctionDescriptor pixman_region32_init$descriptor() {
        return pixman_region32_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_region32_init(pixman_region32_t *region)
     * }
     */
    public static MethodHandle pixman_region32_init$handle() {
        return pixman_region32_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_region32_init(pixman_region32_t *region)
     * }
     */
    public static MemorySegment pixman_region32_init$address() {
        return pixman_region32_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_region32_init(pixman_region32_t *region)
     * }
     */
    public static void pixman_region32_init(MemorySegment region) {
        var mh$ = pixman_region32_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_init", region);
            }
            mh$.invokeExact(region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_init_rect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_init_rect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_region32_init_rect(pixman_region32_t *region, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static FunctionDescriptor pixman_region32_init_rect$descriptor() {
        return pixman_region32_init_rect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_region32_init_rect(pixman_region32_t *region, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static MethodHandle pixman_region32_init_rect$handle() {
        return pixman_region32_init_rect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_region32_init_rect(pixman_region32_t *region, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static MemorySegment pixman_region32_init_rect$address() {
        return pixman_region32_init_rect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_region32_init_rect(pixman_region32_t *region, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static void pixman_region32_init_rect(MemorySegment region, int x, int y, int width, int height) {
        var mh$ = pixman_region32_init_rect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_init_rect", region, x, y, width, height);
            }
            mh$.invokeExact(region, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_init_rects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_init_rects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_init_rects(pixman_region32_t *region, const pixman_box32_t *boxes, int count)
     * }
     */
    public static FunctionDescriptor pixman_region32_init_rects$descriptor() {
        return pixman_region32_init_rects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_init_rects(pixman_region32_t *region, const pixman_box32_t *boxes, int count)
     * }
     */
    public static MethodHandle pixman_region32_init_rects$handle() {
        return pixman_region32_init_rects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_init_rects(pixman_region32_t *region, const pixman_box32_t *boxes, int count)
     * }
     */
    public static MemorySegment pixman_region32_init_rects$address() {
        return pixman_region32_init_rects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_init_rects(pixman_region32_t *region, const pixman_box32_t *boxes, int count)
     * }
     */
    public static int pixman_region32_init_rects(MemorySegment region, MemorySegment boxes, int count) {
        var mh$ = pixman_region32_init_rects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_init_rects", region, boxes, count);
            }
            return (int)mh$.invokeExact(region, boxes, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_init_with_extents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_init_with_extents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_region32_init_with_extents(pixman_region32_t *region, const pixman_box32_t *extents)
     * }
     */
    public static FunctionDescriptor pixman_region32_init_with_extents$descriptor() {
        return pixman_region32_init_with_extents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_region32_init_with_extents(pixman_region32_t *region, const pixman_box32_t *extents)
     * }
     */
    public static MethodHandle pixman_region32_init_with_extents$handle() {
        return pixman_region32_init_with_extents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_region32_init_with_extents(pixman_region32_t *region, const pixman_box32_t *extents)
     * }
     */
    public static MemorySegment pixman_region32_init_with_extents$address() {
        return pixman_region32_init_with_extents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_region32_init_with_extents(pixman_region32_t *region, const pixman_box32_t *extents)
     * }
     */
    public static void pixman_region32_init_with_extents(MemorySegment region, MemorySegment extents) {
        var mh$ = pixman_region32_init_with_extents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_init_with_extents", region, extents);
            }
            mh$.invokeExact(region, extents);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_init_from_image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_init_from_image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_region32_init_from_image(pixman_region32_t *region, pixman_image_t *image)
     * }
     */
    public static FunctionDescriptor pixman_region32_init_from_image$descriptor() {
        return pixman_region32_init_from_image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_region32_init_from_image(pixman_region32_t *region, pixman_image_t *image)
     * }
     */
    public static MethodHandle pixman_region32_init_from_image$handle() {
        return pixman_region32_init_from_image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_region32_init_from_image(pixman_region32_t *region, pixman_image_t *image)
     * }
     */
    public static MemorySegment pixman_region32_init_from_image$address() {
        return pixman_region32_init_from_image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_region32_init_from_image(pixman_region32_t *region, pixman_image_t *image)
     * }
     */
    public static void pixman_region32_init_from_image(MemorySegment region, MemorySegment image) {
        var mh$ = pixman_region32_init_from_image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_init_from_image", region, image);
            }
            mh$.invokeExact(region, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_region32_fini(pixman_region32_t *region)
     * }
     */
    public static FunctionDescriptor pixman_region32_fini$descriptor() {
        return pixman_region32_fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_region32_fini(pixman_region32_t *region)
     * }
     */
    public static MethodHandle pixman_region32_fini$handle() {
        return pixman_region32_fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_region32_fini(pixman_region32_t *region)
     * }
     */
    public static MemorySegment pixman_region32_fini$address() {
        return pixman_region32_fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_region32_fini(pixman_region32_t *region)
     * }
     */
    public static void pixman_region32_fini(MemorySegment region) {
        var mh$ = pixman_region32_fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_fini", region);
            }
            mh$.invokeExact(region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_translate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_translate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_region32_translate(pixman_region32_t *region, int x, int y)
     * }
     */
    public static FunctionDescriptor pixman_region32_translate$descriptor() {
        return pixman_region32_translate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_region32_translate(pixman_region32_t *region, int x, int y)
     * }
     */
    public static MethodHandle pixman_region32_translate$handle() {
        return pixman_region32_translate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_region32_translate(pixman_region32_t *region, int x, int y)
     * }
     */
    public static MemorySegment pixman_region32_translate$address() {
        return pixman_region32_translate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_region32_translate(pixman_region32_t *region, int x, int y)
     * }
     */
    public static void pixman_region32_translate(MemorySegment region, int x, int y) {
        var mh$ = pixman_region32_translate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_translate", region, x, y);
            }
            mh$.invokeExact(region, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_copy(pixman_region32_t *dest, const pixman_region32_t *source)
     * }
     */
    public static FunctionDescriptor pixman_region32_copy$descriptor() {
        return pixman_region32_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_copy(pixman_region32_t *dest, const pixman_region32_t *source)
     * }
     */
    public static MethodHandle pixman_region32_copy$handle() {
        return pixman_region32_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_copy(pixman_region32_t *dest, const pixman_region32_t *source)
     * }
     */
    public static MemorySegment pixman_region32_copy$address() {
        return pixman_region32_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_copy(pixman_region32_t *dest, const pixman_region32_t *source)
     * }
     */
    public static int pixman_region32_copy(MemorySegment dest, MemorySegment source) {
        var mh$ = pixman_region32_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_copy", dest, source);
            }
            return (int)mh$.invokeExact(dest, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_intersect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_intersect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_intersect(pixman_region32_t *new_reg, const pixman_region32_t *reg1, const pixman_region32_t *reg2)
     * }
     */
    public static FunctionDescriptor pixman_region32_intersect$descriptor() {
        return pixman_region32_intersect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_intersect(pixman_region32_t *new_reg, const pixman_region32_t *reg1, const pixman_region32_t *reg2)
     * }
     */
    public static MethodHandle pixman_region32_intersect$handle() {
        return pixman_region32_intersect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_intersect(pixman_region32_t *new_reg, const pixman_region32_t *reg1, const pixman_region32_t *reg2)
     * }
     */
    public static MemorySegment pixman_region32_intersect$address() {
        return pixman_region32_intersect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_intersect(pixman_region32_t *new_reg, const pixman_region32_t *reg1, const pixman_region32_t *reg2)
     * }
     */
    public static int pixman_region32_intersect(MemorySegment new_reg, MemorySegment reg1, MemorySegment reg2) {
        var mh$ = pixman_region32_intersect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_intersect", new_reg, reg1, reg2);
            }
            return (int)mh$.invokeExact(new_reg, reg1, reg2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_union {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_union");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_union(pixman_region32_t *new_reg, const pixman_region32_t *reg1, const pixman_region32_t *reg2)
     * }
     */
    public static FunctionDescriptor pixman_region32_union$descriptor() {
        return pixman_region32_union.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_union(pixman_region32_t *new_reg, const pixman_region32_t *reg1, const pixman_region32_t *reg2)
     * }
     */
    public static MethodHandle pixman_region32_union$handle() {
        return pixman_region32_union.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_union(pixman_region32_t *new_reg, const pixman_region32_t *reg1, const pixman_region32_t *reg2)
     * }
     */
    public static MemorySegment pixman_region32_union$address() {
        return pixman_region32_union.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_union(pixman_region32_t *new_reg, const pixman_region32_t *reg1, const pixman_region32_t *reg2)
     * }
     */
    public static int pixman_region32_union(MemorySegment new_reg, MemorySegment reg1, MemorySegment reg2) {
        var mh$ = pixman_region32_union.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_union", new_reg, reg1, reg2);
            }
            return (int)mh$.invokeExact(new_reg, reg1, reg2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_intersect_rect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_intersect_rect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_intersect_rect(pixman_region32_t *dest, const pixman_region32_t *source, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static FunctionDescriptor pixman_region32_intersect_rect$descriptor() {
        return pixman_region32_intersect_rect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_intersect_rect(pixman_region32_t *dest, const pixman_region32_t *source, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static MethodHandle pixman_region32_intersect_rect$handle() {
        return pixman_region32_intersect_rect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_intersect_rect(pixman_region32_t *dest, const pixman_region32_t *source, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static MemorySegment pixman_region32_intersect_rect$address() {
        return pixman_region32_intersect_rect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_intersect_rect(pixman_region32_t *dest, const pixman_region32_t *source, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static int pixman_region32_intersect_rect(MemorySegment dest, MemorySegment source, int x, int y, int width, int height) {
        var mh$ = pixman_region32_intersect_rect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_intersect_rect", dest, source, x, y, width, height);
            }
            return (int)mh$.invokeExact(dest, source, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_union_rect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_union_rect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_union_rect(pixman_region32_t *dest, const pixman_region32_t *source, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static FunctionDescriptor pixman_region32_union_rect$descriptor() {
        return pixman_region32_union_rect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_union_rect(pixman_region32_t *dest, const pixman_region32_t *source, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static MethodHandle pixman_region32_union_rect$handle() {
        return pixman_region32_union_rect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_union_rect(pixman_region32_t *dest, const pixman_region32_t *source, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static MemorySegment pixman_region32_union_rect$address() {
        return pixman_region32_union_rect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_union_rect(pixman_region32_t *dest, const pixman_region32_t *source, int x, int y, unsigned int width, unsigned int height)
     * }
     */
    public static int pixman_region32_union_rect(MemorySegment dest, MemorySegment source, int x, int y, int width, int height) {
        var mh$ = pixman_region32_union_rect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_union_rect", dest, source, x, y, width, height);
            }
            return (int)mh$.invokeExact(dest, source, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_subtract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_subtract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_subtract(pixman_region32_t *reg_d, const pixman_region32_t *reg_m, const pixman_region32_t *reg_s)
     * }
     */
    public static FunctionDescriptor pixman_region32_subtract$descriptor() {
        return pixman_region32_subtract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_subtract(pixman_region32_t *reg_d, const pixman_region32_t *reg_m, const pixman_region32_t *reg_s)
     * }
     */
    public static MethodHandle pixman_region32_subtract$handle() {
        return pixman_region32_subtract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_subtract(pixman_region32_t *reg_d, const pixman_region32_t *reg_m, const pixman_region32_t *reg_s)
     * }
     */
    public static MemorySegment pixman_region32_subtract$address() {
        return pixman_region32_subtract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_subtract(pixman_region32_t *reg_d, const pixman_region32_t *reg_m, const pixman_region32_t *reg_s)
     * }
     */
    public static int pixman_region32_subtract(MemorySegment reg_d, MemorySegment reg_m, MemorySegment reg_s) {
        var mh$ = pixman_region32_subtract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_subtract", reg_d, reg_m, reg_s);
            }
            return (int)mh$.invokeExact(reg_d, reg_m, reg_s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_inverse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_inverse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_inverse(pixman_region32_t *new_reg, const pixman_region32_t *reg1, const pixman_box32_t *inv_rect)
     * }
     */
    public static FunctionDescriptor pixman_region32_inverse$descriptor() {
        return pixman_region32_inverse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_inverse(pixman_region32_t *new_reg, const pixman_region32_t *reg1, const pixman_box32_t *inv_rect)
     * }
     */
    public static MethodHandle pixman_region32_inverse$handle() {
        return pixman_region32_inverse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_inverse(pixman_region32_t *new_reg, const pixman_region32_t *reg1, const pixman_box32_t *inv_rect)
     * }
     */
    public static MemorySegment pixman_region32_inverse$address() {
        return pixman_region32_inverse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_inverse(pixman_region32_t *new_reg, const pixman_region32_t *reg1, const pixman_box32_t *inv_rect)
     * }
     */
    public static int pixman_region32_inverse(MemorySegment new_reg, MemorySegment reg1, MemorySegment inv_rect) {
        var mh$ = pixman_region32_inverse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_inverse", new_reg, reg1, inv_rect);
            }
            return (int)mh$.invokeExact(new_reg, reg1, inv_rect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_contains_point {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_contains_point");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_contains_point(const pixman_region32_t *region, int x, int y, pixman_box32_t *box)
     * }
     */
    public static FunctionDescriptor pixman_region32_contains_point$descriptor() {
        return pixman_region32_contains_point.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_contains_point(const pixman_region32_t *region, int x, int y, pixman_box32_t *box)
     * }
     */
    public static MethodHandle pixman_region32_contains_point$handle() {
        return pixman_region32_contains_point.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_contains_point(const pixman_region32_t *region, int x, int y, pixman_box32_t *box)
     * }
     */
    public static MemorySegment pixman_region32_contains_point$address() {
        return pixman_region32_contains_point.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_contains_point(const pixman_region32_t *region, int x, int y, pixman_box32_t *box)
     * }
     */
    public static int pixman_region32_contains_point(MemorySegment region, int x, int y, MemorySegment box) {
        var mh$ = pixman_region32_contains_point.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_contains_point", region, x, y, box);
            }
            return (int)mh$.invokeExact(region, x, y, box);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_contains_rectangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_contains_rectangle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_region_overlap_t pixman_region32_contains_rectangle(const pixman_region32_t *region, const pixman_box32_t *prect)
     * }
     */
    public static FunctionDescriptor pixman_region32_contains_rectangle$descriptor() {
        return pixman_region32_contains_rectangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_region_overlap_t pixman_region32_contains_rectangle(const pixman_region32_t *region, const pixman_box32_t *prect)
     * }
     */
    public static MethodHandle pixman_region32_contains_rectangle$handle() {
        return pixman_region32_contains_rectangle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_region_overlap_t pixman_region32_contains_rectangle(const pixman_region32_t *region, const pixman_box32_t *prect)
     * }
     */
    public static MemorySegment pixman_region32_contains_rectangle$address() {
        return pixman_region32_contains_rectangle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_region_overlap_t pixman_region32_contains_rectangle(const pixman_region32_t *region, const pixman_box32_t *prect)
     * }
     */
    public static int pixman_region32_contains_rectangle(MemorySegment region, MemorySegment prect) {
        var mh$ = pixman_region32_contains_rectangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_contains_rectangle", region, prect);
            }
            return (int)mh$.invokeExact(region, prect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_empty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_empty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_empty(const pixman_region32_t *region)
     * }
     */
    public static FunctionDescriptor pixman_region32_empty$descriptor() {
        return pixman_region32_empty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_empty(const pixman_region32_t *region)
     * }
     */
    public static MethodHandle pixman_region32_empty$handle() {
        return pixman_region32_empty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_empty(const pixman_region32_t *region)
     * }
     */
    public static MemorySegment pixman_region32_empty$address() {
        return pixman_region32_empty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_empty(const pixman_region32_t *region)
     * }
     */
    public static int pixman_region32_empty(MemorySegment region) {
        var mh$ = pixman_region32_empty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_empty", region);
            }
            return (int)mh$.invokeExact(region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_not_empty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_not_empty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_not_empty(const pixman_region32_t *region)
     * }
     */
    public static FunctionDescriptor pixman_region32_not_empty$descriptor() {
        return pixman_region32_not_empty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_not_empty(const pixman_region32_t *region)
     * }
     */
    public static MethodHandle pixman_region32_not_empty$handle() {
        return pixman_region32_not_empty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_not_empty(const pixman_region32_t *region)
     * }
     */
    public static MemorySegment pixman_region32_not_empty$address() {
        return pixman_region32_not_empty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_not_empty(const pixman_region32_t *region)
     * }
     */
    public static int pixman_region32_not_empty(MemorySegment region) {
        var mh$ = pixman_region32_not_empty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_not_empty", region);
            }
            return (int)mh$.invokeExact(region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_extents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_extents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_box32_t *pixman_region32_extents(const pixman_region32_t *region)
     * }
     */
    public static FunctionDescriptor pixman_region32_extents$descriptor() {
        return pixman_region32_extents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_box32_t *pixman_region32_extents(const pixman_region32_t *region)
     * }
     */
    public static MethodHandle pixman_region32_extents$handle() {
        return pixman_region32_extents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_box32_t *pixman_region32_extents(const pixman_region32_t *region)
     * }
     */
    public static MemorySegment pixman_region32_extents$address() {
        return pixman_region32_extents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_box32_t *pixman_region32_extents(const pixman_region32_t *region)
     * }
     */
    public static MemorySegment pixman_region32_extents(MemorySegment region) {
        var mh$ = pixman_region32_extents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_extents", region);
            }
            return (MemorySegment)mh$.invokeExact(region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_n_rects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_n_rects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pixman_region32_n_rects(const pixman_region32_t *region)
     * }
     */
    public static FunctionDescriptor pixman_region32_n_rects$descriptor() {
        return pixman_region32_n_rects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pixman_region32_n_rects(const pixman_region32_t *region)
     * }
     */
    public static MethodHandle pixman_region32_n_rects$handle() {
        return pixman_region32_n_rects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pixman_region32_n_rects(const pixman_region32_t *region)
     * }
     */
    public static MemorySegment pixman_region32_n_rects$address() {
        return pixman_region32_n_rects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pixman_region32_n_rects(const pixman_region32_t *region)
     * }
     */
    public static int pixman_region32_n_rects(MemorySegment region) {
        var mh$ = pixman_region32_n_rects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_n_rects", region);
            }
            return (int)mh$.invokeExact(region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_rectangles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_rectangles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_box32_t *pixman_region32_rectangles(const pixman_region32_t *region, int *n_rects)
     * }
     */
    public static FunctionDescriptor pixman_region32_rectangles$descriptor() {
        return pixman_region32_rectangles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_box32_t *pixman_region32_rectangles(const pixman_region32_t *region, int *n_rects)
     * }
     */
    public static MethodHandle pixman_region32_rectangles$handle() {
        return pixman_region32_rectangles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_box32_t *pixman_region32_rectangles(const pixman_region32_t *region, int *n_rects)
     * }
     */
    public static MemorySegment pixman_region32_rectangles$address() {
        return pixman_region32_rectangles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_box32_t *pixman_region32_rectangles(const pixman_region32_t *region, int *n_rects)
     * }
     */
    public static MemorySegment pixman_region32_rectangles(MemorySegment region, MemorySegment n_rects) {
        var mh$ = pixman_region32_rectangles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_rectangles", region, n_rects);
            }
            return (MemorySegment)mh$.invokeExact(region, n_rects);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_equal(const pixman_region32_t *region1, const pixman_region32_t *region2)
     * }
     */
    public static FunctionDescriptor pixman_region32_equal$descriptor() {
        return pixman_region32_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_equal(const pixman_region32_t *region1, const pixman_region32_t *region2)
     * }
     */
    public static MethodHandle pixman_region32_equal$handle() {
        return pixman_region32_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_equal(const pixman_region32_t *region1, const pixman_region32_t *region2)
     * }
     */
    public static MemorySegment pixman_region32_equal$address() {
        return pixman_region32_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_equal(const pixman_region32_t *region1, const pixman_region32_t *region2)
     * }
     */
    public static int pixman_region32_equal(MemorySegment region1, MemorySegment region2) {
        var mh$ = pixman_region32_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_equal", region1, region2);
            }
            return (int)mh$.invokeExact(region1, region2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_selfcheck {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_selfcheck");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_selfcheck(pixman_region32_t *region)
     * }
     */
    public static FunctionDescriptor pixman_region32_selfcheck$descriptor() {
        return pixman_region32_selfcheck.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_selfcheck(pixman_region32_t *region)
     * }
     */
    public static MethodHandle pixman_region32_selfcheck$handle() {
        return pixman_region32_selfcheck.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_selfcheck(pixman_region32_t *region)
     * }
     */
    public static MemorySegment pixman_region32_selfcheck$address() {
        return pixman_region32_selfcheck.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_region32_selfcheck(pixman_region32_t *region)
     * }
     */
    public static int pixman_region32_selfcheck(MemorySegment region) {
        var mh$ = pixman_region32_selfcheck.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_selfcheck", region);
            }
            return (int)mh$.invokeExact(region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_region32_reset(pixman_region32_t *region, const pixman_box32_t *box)
     * }
     */
    public static FunctionDescriptor pixman_region32_reset$descriptor() {
        return pixman_region32_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_region32_reset(pixman_region32_t *region, const pixman_box32_t *box)
     * }
     */
    public static MethodHandle pixman_region32_reset$handle() {
        return pixman_region32_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_region32_reset(pixman_region32_t *region, const pixman_box32_t *box)
     * }
     */
    public static MemorySegment pixman_region32_reset$address() {
        return pixman_region32_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_region32_reset(pixman_region32_t *region, const pixman_box32_t *box)
     * }
     */
    public static void pixman_region32_reset(MemorySegment region, MemorySegment box) {
        var mh$ = pixman_region32_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_reset", region, box);
            }
            mh$.invokeExact(region, box);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_region32_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_region32_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_region32_clear(pixman_region32_t *region)
     * }
     */
    public static FunctionDescriptor pixman_region32_clear$descriptor() {
        return pixman_region32_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_region32_clear(pixman_region32_t *region)
     * }
     */
    public static MethodHandle pixman_region32_clear$handle() {
        return pixman_region32_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_region32_clear(pixman_region32_t *region)
     * }
     */
    public static MemorySegment pixman_region32_clear$address() {
        return pixman_region32_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_region32_clear(pixman_region32_t *region)
     * }
     */
    public static void pixman_region32_clear(MemorySegment region) {
        var mh$ = pixman_region32_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_region32_clear", region);
            }
            mh$.invokeExact(region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_blt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_blt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_blt(uint32_t *src_bits, uint32_t *dst_bits, int src_stride, int dst_stride, int src_bpp, int dst_bpp, int src_x, int src_y, int dest_x, int dest_y, int width, int height)
     * }
     */
    public static FunctionDescriptor pixman_blt$descriptor() {
        return pixman_blt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_blt(uint32_t *src_bits, uint32_t *dst_bits, int src_stride, int dst_stride, int src_bpp, int dst_bpp, int src_x, int src_y, int dest_x, int dest_y, int width, int height)
     * }
     */
    public static MethodHandle pixman_blt$handle() {
        return pixman_blt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_blt(uint32_t *src_bits, uint32_t *dst_bits, int src_stride, int dst_stride, int src_bpp, int dst_bpp, int src_x, int src_y, int dest_x, int dest_y, int width, int height)
     * }
     */
    public static MemorySegment pixman_blt$address() {
        return pixman_blt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_blt(uint32_t *src_bits, uint32_t *dst_bits, int src_stride, int dst_stride, int src_bpp, int dst_bpp, int src_x, int src_y, int dest_x, int dest_y, int width, int height)
     * }
     */
    public static int pixman_blt(MemorySegment src_bits, MemorySegment dst_bits, int src_stride, int dst_stride, int src_bpp, int dst_bpp, int src_x, int src_y, int dest_x, int dest_y, int width, int height) {
        var mh$ = pixman_blt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_blt", src_bits, dst_bits, src_stride, dst_stride, src_bpp, dst_bpp, src_x, src_y, dest_x, dest_y, width, height);
            }
            return (int)mh$.invokeExact(src_bits, dst_bits, src_stride, dst_stride, src_bpp, dst_bpp, src_x, src_y, dest_x, dest_y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_fill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_fill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_fill(uint32_t *bits, int stride, int bpp, int x, int y, int width, int height, uint32_t _xor)
     * }
     */
    public static FunctionDescriptor pixman_fill$descriptor() {
        return pixman_fill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_fill(uint32_t *bits, int stride, int bpp, int x, int y, int width, int height, uint32_t _xor)
     * }
     */
    public static MethodHandle pixman_fill$handle() {
        return pixman_fill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_fill(uint32_t *bits, int stride, int bpp, int x, int y, int width, int height, uint32_t _xor)
     * }
     */
    public static MemorySegment pixman_fill$address() {
        return pixman_fill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_fill(uint32_t *bits, int stride, int bpp, int x, int y, int width, int height, uint32_t _xor)
     * }
     */
    public static int pixman_fill(MemorySegment bits, int stride, int bpp, int x, int y, int width, int height, int _xor) {
        var mh$ = pixman_fill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_fill", bits, stride, bpp, x, y, width, height, _xor);
            }
            return (int)mh$.invokeExact(bits, stride, bpp, x, y, width, height, _xor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT    );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pixman_version()
     * }
     */
    public static FunctionDescriptor pixman_version$descriptor() {
        return pixman_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pixman_version()
     * }
     */
    public static MethodHandle pixman_version$handle() {
        return pixman_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pixman_version()
     * }
     */
    public static MemorySegment pixman_version$address() {
        return pixman_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pixman_version()
     * }
     */
    public static int pixman_version() {
        var mh$ = pixman_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_version");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_version_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER    );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_version_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *pixman_version_string()
     * }
     */
    public static FunctionDescriptor pixman_version_string$descriptor() {
        return pixman_version_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *pixman_version_string()
     * }
     */
    public static MethodHandle pixman_version_string$handle() {
        return pixman_version_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *pixman_version_string()
     * }
     */
    public static MemorySegment pixman_version_string$address() {
        return pixman_version_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *pixman_version_string()
     * }
     */
    public static MemorySegment pixman_version_string() {
        var mh$ = pixman_version_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_version_string");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint8_t pixman_index_type
     * }
     */
    public static final OfByte pixman_index_type = C.C_CHAR;
    private static final int PIXMAN_rgba_float = (int)281756740L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_rgba_float = 281756740
     * }
     */
    public static int PIXMAN_rgba_float() {
        return PIXMAN_rgba_float;
    }
    private static final int PIXMAN_rgb_float = (int)214631492L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_rgb_float = 214631492
     * }
     */
    public static int PIXMAN_rgb_float() {
        return PIXMAN_rgb_float;
    }
    private static final int PIXMAN_a8r8g8b8 = (int)537036936L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_a8r8g8b8 = 537036936
     * }
     */
    public static int PIXMAN_a8r8g8b8() {
        return PIXMAN_a8r8g8b8;
    }
    private static final int PIXMAN_x8r8g8b8 = (int)537004168L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_x8r8g8b8 = 537004168
     * }
     */
    public static int PIXMAN_x8r8g8b8() {
        return PIXMAN_x8r8g8b8;
    }
    private static final int PIXMAN_a8b8g8r8 = (int)537102472L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_a8b8g8r8 = 537102472
     * }
     */
    public static int PIXMAN_a8b8g8r8() {
        return PIXMAN_a8b8g8r8;
    }
    private static final int PIXMAN_x8b8g8r8 = (int)537069704L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_x8b8g8r8 = 537069704
     * }
     */
    public static int PIXMAN_x8b8g8r8() {
        return PIXMAN_x8b8g8r8;
    }
    private static final int PIXMAN_b8g8r8a8 = (int)537430152L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_b8g8r8a8 = 537430152
     * }
     */
    public static int PIXMAN_b8g8r8a8() {
        return PIXMAN_b8g8r8a8;
    }
    private static final int PIXMAN_b8g8r8x8 = (int)537397384L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_b8g8r8x8 = 537397384
     * }
     */
    public static int PIXMAN_b8g8r8x8() {
        return PIXMAN_b8g8r8x8;
    }
    private static final int PIXMAN_r8g8b8a8 = (int)537495688L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_r8g8b8a8 = 537495688
     * }
     */
    public static int PIXMAN_r8g8b8a8() {
        return PIXMAN_r8g8b8a8;
    }
    private static final int PIXMAN_r8g8b8x8 = (int)537462920L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_r8g8b8x8 = 537462920
     * }
     */
    public static int PIXMAN_r8g8b8x8() {
        return PIXMAN_r8g8b8x8;
    }
    private static final int PIXMAN_x14r6g6b6 = (int)537003622L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_x14r6g6b6 = 537003622
     * }
     */
    public static int PIXMAN_x14r6g6b6() {
        return PIXMAN_x14r6g6b6;
    }
    private static final int PIXMAN_x2r10g10b10 = (int)537004714L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_x2r10g10b10 = 537004714
     * }
     */
    public static int PIXMAN_x2r10g10b10() {
        return PIXMAN_x2r10g10b10;
    }
    private static final int PIXMAN_a2r10g10b10 = (int)537012906L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_a2r10g10b10 = 537012906
     * }
     */
    public static int PIXMAN_a2r10g10b10() {
        return PIXMAN_a2r10g10b10;
    }
    private static final int PIXMAN_x2b10g10r10 = (int)537070250L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_x2b10g10r10 = 537070250
     * }
     */
    public static int PIXMAN_x2b10g10r10() {
        return PIXMAN_x2b10g10r10;
    }
    private static final int PIXMAN_a2b10g10r10 = (int)537078442L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_a2b10g10r10 = 537078442
     * }
     */
    public static int PIXMAN_a2b10g10r10() {
        return PIXMAN_a2b10g10r10;
    }
    private static final int PIXMAN_a8r8g8b8_sRGB = (int)537561224L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_a8r8g8b8_sRGB = 537561224
     * }
     */
    public static int PIXMAN_a8r8g8b8_sRGB() {
        return PIXMAN_a8r8g8b8_sRGB;
    }
    private static final int PIXMAN_r8g8b8_sRGB = (int)403310728L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_r8g8b8_sRGB = 403310728
     * }
     */
    public static int PIXMAN_r8g8b8_sRGB() {
        return PIXMAN_r8g8b8_sRGB;
    }
    private static final int PIXMAN_r8g8b8 = (int)402786440L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_r8g8b8 = 402786440
     * }
     */
    public static int PIXMAN_r8g8b8() {
        return PIXMAN_r8g8b8;
    }
    private static final int PIXMAN_b8g8r8 = (int)402851976L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_b8g8r8 = 402851976
     * }
     */
    public static int PIXMAN_b8g8r8() {
        return PIXMAN_b8g8r8;
    }
    private static final int PIXMAN_r5g6b5 = (int)268567909L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_r5g6b5 = 268567909
     * }
     */
    public static int PIXMAN_r5g6b5() {
        return PIXMAN_r5g6b5;
    }
    private static final int PIXMAN_b5g6r5 = (int)268633445L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_b5g6r5 = 268633445
     * }
     */
    public static int PIXMAN_b5g6r5() {
        return PIXMAN_b5g6r5;
    }
    private static final int PIXMAN_a1r5g5b5 = (int)268571989L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_a1r5g5b5 = 268571989
     * }
     */
    public static int PIXMAN_a1r5g5b5() {
        return PIXMAN_a1r5g5b5;
    }
    private static final int PIXMAN_x1r5g5b5 = (int)268567893L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_x1r5g5b5 = 268567893
     * }
     */
    public static int PIXMAN_x1r5g5b5() {
        return PIXMAN_x1r5g5b5;
    }
    private static final int PIXMAN_a1b5g5r5 = (int)268637525L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_a1b5g5r5 = 268637525
     * }
     */
    public static int PIXMAN_a1b5g5r5() {
        return PIXMAN_a1b5g5r5;
    }
    private static final int PIXMAN_x1b5g5r5 = (int)268633429L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_x1b5g5r5 = 268633429
     * }
     */
    public static int PIXMAN_x1b5g5r5() {
        return PIXMAN_x1b5g5r5;
    }
    private static final int PIXMAN_a4r4g4b4 = (int)268584004L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_a4r4g4b4 = 268584004
     * }
     */
    public static int PIXMAN_a4r4g4b4() {
        return PIXMAN_a4r4g4b4;
    }
    private static final int PIXMAN_x4r4g4b4 = (int)268567620L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_x4r4g4b4 = 268567620
     * }
     */
    public static int PIXMAN_x4r4g4b4() {
        return PIXMAN_x4r4g4b4;
    }
    private static final int PIXMAN_a4b4g4r4 = (int)268649540L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_a4b4g4r4 = 268649540
     * }
     */
    public static int PIXMAN_a4b4g4r4() {
        return PIXMAN_a4b4g4r4;
    }
    private static final int PIXMAN_x4b4g4r4 = (int)268633156L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_x4b4g4r4 = 268633156
     * }
     */
    public static int PIXMAN_x4b4g4r4() {
        return PIXMAN_x4b4g4r4;
    }
    private static final int PIXMAN_a8 = (int)134316032L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_a8 = 134316032
     * }
     */
    public static int PIXMAN_a8() {
        return PIXMAN_a8;
    }
    private static final int PIXMAN_r3g3b2 = (int)134349618L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_r3g3b2 = 134349618
     * }
     */
    public static int PIXMAN_r3g3b2() {
        return PIXMAN_r3g3b2;
    }
    private static final int PIXMAN_b2g3r3 = (int)134415154L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_b2g3r3 = 134415154
     * }
     */
    public static int PIXMAN_b2g3r3() {
        return PIXMAN_b2g3r3;
    }
    private static final int PIXMAN_a2r2g2b2 = (int)134357538L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_a2r2g2b2 = 134357538
     * }
     */
    public static int PIXMAN_a2r2g2b2() {
        return PIXMAN_a2r2g2b2;
    }
    private static final int PIXMAN_a2b2g2r2 = (int)134423074L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_a2b2g2r2 = 134423074
     * }
     */
    public static int PIXMAN_a2b2g2r2() {
        return PIXMAN_a2b2g2r2;
    }
    private static final int PIXMAN_c8 = (int)134479872L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_c8 = 134479872
     * }
     */
    public static int PIXMAN_c8() {
        return PIXMAN_c8;
    }
    private static final int PIXMAN_g8 = (int)134545408L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_g8 = 134545408
     * }
     */
    public static int PIXMAN_g8() {
        return PIXMAN_g8;
    }
    private static final int PIXMAN_x4a4 = (int)134299648L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_x4a4 = 134299648
     * }
     */
    public static int PIXMAN_x4a4() {
        return PIXMAN_x4a4;
    }
    private static final int PIXMAN_x4c4 = (int)134479872L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_x4c4 = 134479872
     * }
     */
    public static int PIXMAN_x4c4() {
        return PIXMAN_x4c4;
    }
    private static final int PIXMAN_x4g4 = (int)134545408L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_x4g4 = 134545408
     * }
     */
    public static int PIXMAN_x4g4() {
        return PIXMAN_x4g4;
    }
    private static final int PIXMAN_a4 = (int)67190784L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_a4 = 67190784
     * }
     */
    public static int PIXMAN_a4() {
        return PIXMAN_a4;
    }
    private static final int PIXMAN_r1g2b1 = (int)67240225L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_r1g2b1 = 67240225
     * }
     */
    public static int PIXMAN_r1g2b1() {
        return PIXMAN_r1g2b1;
    }
    private static final int PIXMAN_b1g2r1 = (int)67305761L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_b1g2r1 = 67305761
     * }
     */
    public static int PIXMAN_b1g2r1() {
        return PIXMAN_b1g2r1;
    }
    private static final int PIXMAN_a1r1g1b1 = (int)67244305L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_a1r1g1b1 = 67244305
     * }
     */
    public static int PIXMAN_a1r1g1b1() {
        return PIXMAN_a1r1g1b1;
    }
    private static final int PIXMAN_a1b1g1r1 = (int)67309841L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_a1b1g1r1 = 67309841
     * }
     */
    public static int PIXMAN_a1b1g1r1() {
        return PIXMAN_a1b1g1r1;
    }
    private static final int PIXMAN_c4 = (int)67371008L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_c4 = 67371008
     * }
     */
    public static int PIXMAN_c4() {
        return PIXMAN_c4;
    }
    private static final int PIXMAN_g4 = (int)67436544L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_g4 = 67436544
     * }
     */
    public static int PIXMAN_g4() {
        return PIXMAN_g4;
    }
    private static final int PIXMAN_a1 = (int)16846848L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_a1 = 16846848
     * }
     */
    public static int PIXMAN_a1() {
        return PIXMAN_a1;
    }
    private static final int PIXMAN_g1 = (int)17104896L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_g1 = 17104896
     * }
     */
    public static int PIXMAN_g1() {
        return PIXMAN_g1;
    }
    private static final int PIXMAN_yuy2 = (int)268828672L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_yuy2 = 268828672
     * }
     */
    public static int PIXMAN_yuy2() {
        return PIXMAN_yuy2;
    }
    private static final int PIXMAN_yv12 = (int)201785344L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_yv12 = 201785344
     * }
     */
    public static int PIXMAN_yv12() {
        return PIXMAN_yv12;
    }

    private static class pixman_format_supported_destination {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_format_supported_destination");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_format_supported_destination(pixman_format_code_t format)
     * }
     */
    public static FunctionDescriptor pixman_format_supported_destination$descriptor() {
        return pixman_format_supported_destination.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_format_supported_destination(pixman_format_code_t format)
     * }
     */
    public static MethodHandle pixman_format_supported_destination$handle() {
        return pixman_format_supported_destination.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_format_supported_destination(pixman_format_code_t format)
     * }
     */
    public static MemorySegment pixman_format_supported_destination$address() {
        return pixman_format_supported_destination.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_format_supported_destination(pixman_format_code_t format)
     * }
     */
    public static int pixman_format_supported_destination(int format) {
        var mh$ = pixman_format_supported_destination.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_format_supported_destination", format);
            }
            return (int)mh$.invokeExact(format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_format_supported_source {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_format_supported_source");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_format_supported_source(pixman_format_code_t format)
     * }
     */
    public static FunctionDescriptor pixman_format_supported_source$descriptor() {
        return pixman_format_supported_source.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_format_supported_source(pixman_format_code_t format)
     * }
     */
    public static MethodHandle pixman_format_supported_source$handle() {
        return pixman_format_supported_source.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_format_supported_source(pixman_format_code_t format)
     * }
     */
    public static MemorySegment pixman_format_supported_source$address() {
        return pixman_format_supported_source.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_format_supported_source(pixman_format_code_t format)
     * }
     */
    public static int pixman_format_supported_source(int format) {
        var mh$ = pixman_format_supported_source.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_format_supported_source", format);
            }
            return (int)mh$.invokeExact(format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_create_solid_fill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_create_solid_fill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_solid_fill(const pixman_color_t *color)
     * }
     */
    public static FunctionDescriptor pixman_image_create_solid_fill$descriptor() {
        return pixman_image_create_solid_fill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_solid_fill(const pixman_color_t *color)
     * }
     */
    public static MethodHandle pixman_image_create_solid_fill$handle() {
        return pixman_image_create_solid_fill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_solid_fill(const pixman_color_t *color)
     * }
     */
    public static MemorySegment pixman_image_create_solid_fill$address() {
        return pixman_image_create_solid_fill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_solid_fill(const pixman_color_t *color)
     * }
     */
    public static MemorySegment pixman_image_create_solid_fill(MemorySegment color) {
        var mh$ = pixman_image_create_solid_fill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_create_solid_fill", color);
            }
            return (MemorySegment)mh$.invokeExact(color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_create_linear_gradient {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_create_linear_gradient");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_linear_gradient(const pixman_point_fixed_t *p1, const pixman_point_fixed_t *p2, const pixman_gradient_stop_t *stops, int n_stops)
     * }
     */
    public static FunctionDescriptor pixman_image_create_linear_gradient$descriptor() {
        return pixman_image_create_linear_gradient.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_linear_gradient(const pixman_point_fixed_t *p1, const pixman_point_fixed_t *p2, const pixman_gradient_stop_t *stops, int n_stops)
     * }
     */
    public static MethodHandle pixman_image_create_linear_gradient$handle() {
        return pixman_image_create_linear_gradient.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_linear_gradient(const pixman_point_fixed_t *p1, const pixman_point_fixed_t *p2, const pixman_gradient_stop_t *stops, int n_stops)
     * }
     */
    public static MemorySegment pixman_image_create_linear_gradient$address() {
        return pixman_image_create_linear_gradient.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_linear_gradient(const pixman_point_fixed_t *p1, const pixman_point_fixed_t *p2, const pixman_gradient_stop_t *stops, int n_stops)
     * }
     */
    public static MemorySegment pixman_image_create_linear_gradient(MemorySegment p1, MemorySegment p2, MemorySegment stops, int n_stops) {
        var mh$ = pixman_image_create_linear_gradient.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_create_linear_gradient", p1, p2, stops, n_stops);
            }
            return (MemorySegment)mh$.invokeExact(p1, p2, stops, n_stops);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_create_radial_gradient {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_create_radial_gradient");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_radial_gradient(const pixman_point_fixed_t *inner, const pixman_point_fixed_t *outer, pixman_fixed_t inner_radius, pixman_fixed_t outer_radius, const pixman_gradient_stop_t *stops, int n_stops)
     * }
     */
    public static FunctionDescriptor pixman_image_create_radial_gradient$descriptor() {
        return pixman_image_create_radial_gradient.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_radial_gradient(const pixman_point_fixed_t *inner, const pixman_point_fixed_t *outer, pixman_fixed_t inner_radius, pixman_fixed_t outer_radius, const pixman_gradient_stop_t *stops, int n_stops)
     * }
     */
    public static MethodHandle pixman_image_create_radial_gradient$handle() {
        return pixman_image_create_radial_gradient.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_radial_gradient(const pixman_point_fixed_t *inner, const pixman_point_fixed_t *outer, pixman_fixed_t inner_radius, pixman_fixed_t outer_radius, const pixman_gradient_stop_t *stops, int n_stops)
     * }
     */
    public static MemorySegment pixman_image_create_radial_gradient$address() {
        return pixman_image_create_radial_gradient.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_radial_gradient(const pixman_point_fixed_t *inner, const pixman_point_fixed_t *outer, pixman_fixed_t inner_radius, pixman_fixed_t outer_radius, const pixman_gradient_stop_t *stops, int n_stops)
     * }
     */
    public static MemorySegment pixman_image_create_radial_gradient(MemorySegment inner, MemorySegment outer, int inner_radius, int outer_radius, MemorySegment stops, int n_stops) {
        var mh$ = pixman_image_create_radial_gradient.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_create_radial_gradient", inner, outer, inner_radius, outer_radius, stops, n_stops);
            }
            return (MemorySegment)mh$.invokeExact(inner, outer, inner_radius, outer_radius, stops, n_stops);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_create_conical_gradient {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_create_conical_gradient");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_conical_gradient(const pixman_point_fixed_t *center, pixman_fixed_t angle, const pixman_gradient_stop_t *stops, int n_stops)
     * }
     */
    public static FunctionDescriptor pixman_image_create_conical_gradient$descriptor() {
        return pixman_image_create_conical_gradient.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_conical_gradient(const pixman_point_fixed_t *center, pixman_fixed_t angle, const pixman_gradient_stop_t *stops, int n_stops)
     * }
     */
    public static MethodHandle pixman_image_create_conical_gradient$handle() {
        return pixman_image_create_conical_gradient.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_conical_gradient(const pixman_point_fixed_t *center, pixman_fixed_t angle, const pixman_gradient_stop_t *stops, int n_stops)
     * }
     */
    public static MemorySegment pixman_image_create_conical_gradient$address() {
        return pixman_image_create_conical_gradient.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_conical_gradient(const pixman_point_fixed_t *center, pixman_fixed_t angle, const pixman_gradient_stop_t *stops, int n_stops)
     * }
     */
    public static MemorySegment pixman_image_create_conical_gradient(MemorySegment center, int angle, MemorySegment stops, int n_stops) {
        var mh$ = pixman_image_create_conical_gradient.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_create_conical_gradient", center, angle, stops, n_stops);
            }
            return (MemorySegment)mh$.invokeExact(center, angle, stops, n_stops);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_create_bits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_create_bits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_bits(pixman_format_code_t format, int width, int height, uint32_t *bits, int rowstride_bytes)
     * }
     */
    public static FunctionDescriptor pixman_image_create_bits$descriptor() {
        return pixman_image_create_bits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_bits(pixman_format_code_t format, int width, int height, uint32_t *bits, int rowstride_bytes)
     * }
     */
    public static MethodHandle pixman_image_create_bits$handle() {
        return pixman_image_create_bits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_bits(pixman_format_code_t format, int width, int height, uint32_t *bits, int rowstride_bytes)
     * }
     */
    public static MemorySegment pixman_image_create_bits$address() {
        return pixman_image_create_bits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_bits(pixman_format_code_t format, int width, int height, uint32_t *bits, int rowstride_bytes)
     * }
     */
    public static MemorySegment pixman_image_create_bits(int format, int width, int height, MemorySegment bits, int rowstride_bytes) {
        var mh$ = pixman_image_create_bits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_create_bits", format, width, height, bits, rowstride_bytes);
            }
            return (MemorySegment)mh$.invokeExact(format, width, height, bits, rowstride_bytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_create_bits_no_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_create_bits_no_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_bits_no_clear(pixman_format_code_t format, int width, int height, uint32_t *bits, int rowstride_bytes)
     * }
     */
    public static FunctionDescriptor pixman_image_create_bits_no_clear$descriptor() {
        return pixman_image_create_bits_no_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_bits_no_clear(pixman_format_code_t format, int width, int height, uint32_t *bits, int rowstride_bytes)
     * }
     */
    public static MethodHandle pixman_image_create_bits_no_clear$handle() {
        return pixman_image_create_bits_no_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_bits_no_clear(pixman_format_code_t format, int width, int height, uint32_t *bits, int rowstride_bytes)
     * }
     */
    public static MemorySegment pixman_image_create_bits_no_clear$address() {
        return pixman_image_create_bits_no_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_create_bits_no_clear(pixman_format_code_t format, int width, int height, uint32_t *bits, int rowstride_bytes)
     * }
     */
    public static MemorySegment pixman_image_create_bits_no_clear(int format, int width, int height, MemorySegment bits, int rowstride_bytes) {
        var mh$ = pixman_image_create_bits_no_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_create_bits_no_clear", format, width, height, bits, rowstride_bytes);
            }
            return (MemorySegment)mh$.invokeExact(format, width, height, bits, rowstride_bytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_ref(pixman_image_t *image)
     * }
     */
    public static FunctionDescriptor pixman_image_ref$descriptor() {
        return pixman_image_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_ref(pixman_image_t *image)
     * }
     */
    public static MethodHandle pixman_image_ref$handle() {
        return pixman_image_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_ref(pixman_image_t *image)
     * }
     */
    public static MemorySegment pixman_image_ref$address() {
        return pixman_image_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_image_t *pixman_image_ref(pixman_image_t *image)
     * }
     */
    public static MemorySegment pixman_image_ref(MemorySegment image) {
        var mh$ = pixman_image_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_ref", image);
            }
            return (MemorySegment)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_unref(pixman_image_t *image)
     * }
     */
    public static FunctionDescriptor pixman_image_unref$descriptor() {
        return pixman_image_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_unref(pixman_image_t *image)
     * }
     */
    public static MethodHandle pixman_image_unref$handle() {
        return pixman_image_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_unref(pixman_image_t *image)
     * }
     */
    public static MemorySegment pixman_image_unref$address() {
        return pixman_image_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_unref(pixman_image_t *image)
     * }
     */
    public static int pixman_image_unref(MemorySegment image) {
        var mh$ = pixman_image_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_unref", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_set_destroy_function {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_set_destroy_function");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_image_set_destroy_function(pixman_image_t *image, pixman_image_destroy_func_t function, void *data)
     * }
     */
    public static FunctionDescriptor pixman_image_set_destroy_function$descriptor() {
        return pixman_image_set_destroy_function.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_image_set_destroy_function(pixman_image_t *image, pixman_image_destroy_func_t function, void *data)
     * }
     */
    public static MethodHandle pixman_image_set_destroy_function$handle() {
        return pixman_image_set_destroy_function.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_image_set_destroy_function(pixman_image_t *image, pixman_image_destroy_func_t function, void *data)
     * }
     */
    public static MemorySegment pixman_image_set_destroy_function$address() {
        return pixman_image_set_destroy_function.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_image_set_destroy_function(pixman_image_t *image, pixman_image_destroy_func_t function, void *data)
     * }
     */
    public static void pixman_image_set_destroy_function(MemorySegment image, MemorySegment function, MemorySegment data) {
        var mh$ = pixman_image_set_destroy_function.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_set_destroy_function", image, function, data);
            }
            mh$.invokeExact(image, function, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_get_destroy_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_get_destroy_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *pixman_image_get_destroy_data(pixman_image_t *image)
     * }
     */
    public static FunctionDescriptor pixman_image_get_destroy_data$descriptor() {
        return pixman_image_get_destroy_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *pixman_image_get_destroy_data(pixman_image_t *image)
     * }
     */
    public static MethodHandle pixman_image_get_destroy_data$handle() {
        return pixman_image_get_destroy_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *pixman_image_get_destroy_data(pixman_image_t *image)
     * }
     */
    public static MemorySegment pixman_image_get_destroy_data$address() {
        return pixman_image_get_destroy_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *pixman_image_get_destroy_data(pixman_image_t *image)
     * }
     */
    public static MemorySegment pixman_image_get_destroy_data(MemorySegment image) {
        var mh$ = pixman_image_get_destroy_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_get_destroy_data", image);
            }
            return (MemorySegment)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_set_clip_region {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_set_clip_region");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_set_clip_region(pixman_image_t *image, const pixman_region16_t *region)
     * }
     */
    public static FunctionDescriptor pixman_image_set_clip_region$descriptor() {
        return pixman_image_set_clip_region.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_set_clip_region(pixman_image_t *image, const pixman_region16_t *region)
     * }
     */
    public static MethodHandle pixman_image_set_clip_region$handle() {
        return pixman_image_set_clip_region.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_set_clip_region(pixman_image_t *image, const pixman_region16_t *region)
     * }
     */
    public static MemorySegment pixman_image_set_clip_region$address() {
        return pixman_image_set_clip_region.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_set_clip_region(pixman_image_t *image, const pixman_region16_t *region)
     * }
     */
    public static int pixman_image_set_clip_region(MemorySegment image, MemorySegment region) {
        var mh$ = pixman_image_set_clip_region.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_set_clip_region", image, region);
            }
            return (int)mh$.invokeExact(image, region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_set_clip_region32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_set_clip_region32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_set_clip_region32(pixman_image_t *image, const pixman_region32_t *region)
     * }
     */
    public static FunctionDescriptor pixman_image_set_clip_region32$descriptor() {
        return pixman_image_set_clip_region32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_set_clip_region32(pixman_image_t *image, const pixman_region32_t *region)
     * }
     */
    public static MethodHandle pixman_image_set_clip_region32$handle() {
        return pixman_image_set_clip_region32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_set_clip_region32(pixman_image_t *image, const pixman_region32_t *region)
     * }
     */
    public static MemorySegment pixman_image_set_clip_region32$address() {
        return pixman_image_set_clip_region32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_set_clip_region32(pixman_image_t *image, const pixman_region32_t *region)
     * }
     */
    public static int pixman_image_set_clip_region32(MemorySegment image, MemorySegment region) {
        var mh$ = pixman_image_set_clip_region32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_set_clip_region32", image, region);
            }
            return (int)mh$.invokeExact(image, region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_set_has_client_clip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_set_has_client_clip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_image_set_has_client_clip(pixman_image_t *image, pixman_bool_t clien_clip)
     * }
     */
    public static FunctionDescriptor pixman_image_set_has_client_clip$descriptor() {
        return pixman_image_set_has_client_clip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_image_set_has_client_clip(pixman_image_t *image, pixman_bool_t clien_clip)
     * }
     */
    public static MethodHandle pixman_image_set_has_client_clip$handle() {
        return pixman_image_set_has_client_clip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_image_set_has_client_clip(pixman_image_t *image, pixman_bool_t clien_clip)
     * }
     */
    public static MemorySegment pixman_image_set_has_client_clip$address() {
        return pixman_image_set_has_client_clip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_image_set_has_client_clip(pixman_image_t *image, pixman_bool_t clien_clip)
     * }
     */
    public static void pixman_image_set_has_client_clip(MemorySegment image, int clien_clip) {
        var mh$ = pixman_image_set_has_client_clip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_set_has_client_clip", image, clien_clip);
            }
            mh$.invokeExact(image, clien_clip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_set_transform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_set_transform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_set_transform(pixman_image_t *image, const pixman_transform_t *transform)
     * }
     */
    public static FunctionDescriptor pixman_image_set_transform$descriptor() {
        return pixman_image_set_transform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_set_transform(pixman_image_t *image, const pixman_transform_t *transform)
     * }
     */
    public static MethodHandle pixman_image_set_transform$handle() {
        return pixman_image_set_transform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_set_transform(pixman_image_t *image, const pixman_transform_t *transform)
     * }
     */
    public static MemorySegment pixman_image_set_transform$address() {
        return pixman_image_set_transform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_set_transform(pixman_image_t *image, const pixman_transform_t *transform)
     * }
     */
    public static int pixman_image_set_transform(MemorySegment image, MemorySegment transform) {
        var mh$ = pixman_image_set_transform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_set_transform", image, transform);
            }
            return (int)mh$.invokeExact(image, transform);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_set_repeat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_set_repeat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_image_set_repeat(pixman_image_t *image, pixman_repeat_t repeat)
     * }
     */
    public static FunctionDescriptor pixman_image_set_repeat$descriptor() {
        return pixman_image_set_repeat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_image_set_repeat(pixman_image_t *image, pixman_repeat_t repeat)
     * }
     */
    public static MethodHandle pixman_image_set_repeat$handle() {
        return pixman_image_set_repeat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_image_set_repeat(pixman_image_t *image, pixman_repeat_t repeat)
     * }
     */
    public static MemorySegment pixman_image_set_repeat$address() {
        return pixman_image_set_repeat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_image_set_repeat(pixman_image_t *image, pixman_repeat_t repeat)
     * }
     */
    public static void pixman_image_set_repeat(MemorySegment image, int repeat) {
        var mh$ = pixman_image_set_repeat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_set_repeat", image, repeat);
            }
            mh$.invokeExact(image, repeat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_set_dither {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_set_dither");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_image_set_dither(pixman_image_t *image, pixman_dither_t dither)
     * }
     */
    public static FunctionDescriptor pixman_image_set_dither$descriptor() {
        return pixman_image_set_dither.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_image_set_dither(pixman_image_t *image, pixman_dither_t dither)
     * }
     */
    public static MethodHandle pixman_image_set_dither$handle() {
        return pixman_image_set_dither.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_image_set_dither(pixman_image_t *image, pixman_dither_t dither)
     * }
     */
    public static MemorySegment pixman_image_set_dither$address() {
        return pixman_image_set_dither.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_image_set_dither(pixman_image_t *image, pixman_dither_t dither)
     * }
     */
    public static void pixman_image_set_dither(MemorySegment image, int dither) {
        var mh$ = pixman_image_set_dither.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_set_dither", image, dither);
            }
            mh$.invokeExact(image, dither);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_set_dither_offset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_set_dither_offset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_image_set_dither_offset(pixman_image_t *image, int offset_x, int offset_y)
     * }
     */
    public static FunctionDescriptor pixman_image_set_dither_offset$descriptor() {
        return pixman_image_set_dither_offset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_image_set_dither_offset(pixman_image_t *image, int offset_x, int offset_y)
     * }
     */
    public static MethodHandle pixman_image_set_dither_offset$handle() {
        return pixman_image_set_dither_offset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_image_set_dither_offset(pixman_image_t *image, int offset_x, int offset_y)
     * }
     */
    public static MemorySegment pixman_image_set_dither_offset$address() {
        return pixman_image_set_dither_offset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_image_set_dither_offset(pixman_image_t *image, int offset_x, int offset_y)
     * }
     */
    public static void pixman_image_set_dither_offset(MemorySegment image, int offset_x, int offset_y) {
        var mh$ = pixman_image_set_dither_offset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_set_dither_offset", image, offset_x, offset_y);
            }
            mh$.invokeExact(image, offset_x, offset_y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_set_filter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_set_filter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_set_filter(pixman_image_t *image, pixman_filter_t filter, const pixman_fixed_t *filter_params, int n_filter_params)
     * }
     */
    public static FunctionDescriptor pixman_image_set_filter$descriptor() {
        return pixman_image_set_filter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_set_filter(pixman_image_t *image, pixman_filter_t filter, const pixman_fixed_t *filter_params, int n_filter_params)
     * }
     */
    public static MethodHandle pixman_image_set_filter$handle() {
        return pixman_image_set_filter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_set_filter(pixman_image_t *image, pixman_filter_t filter, const pixman_fixed_t *filter_params, int n_filter_params)
     * }
     */
    public static MemorySegment pixman_image_set_filter$address() {
        return pixman_image_set_filter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_set_filter(pixman_image_t *image, pixman_filter_t filter, const pixman_fixed_t *filter_params, int n_filter_params)
     * }
     */
    public static int pixman_image_set_filter(MemorySegment image, int filter, MemorySegment filter_params, int n_filter_params) {
        var mh$ = pixman_image_set_filter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_set_filter", image, filter, filter_params, n_filter_params);
            }
            return (int)mh$.invokeExact(image, filter, filter_params, n_filter_params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_set_source_clipping {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_set_source_clipping");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_image_set_source_clipping(pixman_image_t *image, pixman_bool_t source_clipping)
     * }
     */
    public static FunctionDescriptor pixman_image_set_source_clipping$descriptor() {
        return pixman_image_set_source_clipping.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_image_set_source_clipping(pixman_image_t *image, pixman_bool_t source_clipping)
     * }
     */
    public static MethodHandle pixman_image_set_source_clipping$handle() {
        return pixman_image_set_source_clipping.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_image_set_source_clipping(pixman_image_t *image, pixman_bool_t source_clipping)
     * }
     */
    public static MemorySegment pixman_image_set_source_clipping$address() {
        return pixman_image_set_source_clipping.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_image_set_source_clipping(pixman_image_t *image, pixman_bool_t source_clipping)
     * }
     */
    public static void pixman_image_set_source_clipping(MemorySegment image, int source_clipping) {
        var mh$ = pixman_image_set_source_clipping.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_set_source_clipping", image, source_clipping);
            }
            mh$.invokeExact(image, source_clipping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_set_alpha_map {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_SHORT,
            C.C_SHORT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_set_alpha_map");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_image_set_alpha_map(pixman_image_t *image, pixman_image_t *alpha_map, int16_t x, int16_t y)
     * }
     */
    public static FunctionDescriptor pixman_image_set_alpha_map$descriptor() {
        return pixman_image_set_alpha_map.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_image_set_alpha_map(pixman_image_t *image, pixman_image_t *alpha_map, int16_t x, int16_t y)
     * }
     */
    public static MethodHandle pixman_image_set_alpha_map$handle() {
        return pixman_image_set_alpha_map.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_image_set_alpha_map(pixman_image_t *image, pixman_image_t *alpha_map, int16_t x, int16_t y)
     * }
     */
    public static MemorySegment pixman_image_set_alpha_map$address() {
        return pixman_image_set_alpha_map.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_image_set_alpha_map(pixman_image_t *image, pixman_image_t *alpha_map, int16_t x, int16_t y)
     * }
     */
    public static void pixman_image_set_alpha_map(MemorySegment image, MemorySegment alpha_map, short x, short y) {
        var mh$ = pixman_image_set_alpha_map.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_set_alpha_map", image, alpha_map, x, y);
            }
            mh$.invokeExact(image, alpha_map, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_set_component_alpha {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_set_component_alpha");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_image_set_component_alpha(pixman_image_t *image, pixman_bool_t component_alpha)
     * }
     */
    public static FunctionDescriptor pixman_image_set_component_alpha$descriptor() {
        return pixman_image_set_component_alpha.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_image_set_component_alpha(pixman_image_t *image, pixman_bool_t component_alpha)
     * }
     */
    public static MethodHandle pixman_image_set_component_alpha$handle() {
        return pixman_image_set_component_alpha.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_image_set_component_alpha(pixman_image_t *image, pixman_bool_t component_alpha)
     * }
     */
    public static MemorySegment pixman_image_set_component_alpha$address() {
        return pixman_image_set_component_alpha.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_image_set_component_alpha(pixman_image_t *image, pixman_bool_t component_alpha)
     * }
     */
    public static void pixman_image_set_component_alpha(MemorySegment image, int component_alpha) {
        var mh$ = pixman_image_set_component_alpha.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_set_component_alpha", image, component_alpha);
            }
            mh$.invokeExact(image, component_alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_get_component_alpha {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_get_component_alpha");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_get_component_alpha(pixman_image_t *image)
     * }
     */
    public static FunctionDescriptor pixman_image_get_component_alpha$descriptor() {
        return pixman_image_get_component_alpha.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_get_component_alpha(pixman_image_t *image)
     * }
     */
    public static MethodHandle pixman_image_get_component_alpha$handle() {
        return pixman_image_get_component_alpha.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_get_component_alpha(pixman_image_t *image)
     * }
     */
    public static MemorySegment pixman_image_get_component_alpha$address() {
        return pixman_image_get_component_alpha.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_get_component_alpha(pixman_image_t *image)
     * }
     */
    public static int pixman_image_get_component_alpha(MemorySegment image) {
        var mh$ = pixman_image_get_component_alpha.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_get_component_alpha", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_set_accessors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_set_accessors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_image_set_accessors(pixman_image_t *image, pixman_read_memory_func_t read_func, pixman_write_memory_func_t write_func)
     * }
     */
    public static FunctionDescriptor pixman_image_set_accessors$descriptor() {
        return pixman_image_set_accessors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_image_set_accessors(pixman_image_t *image, pixman_read_memory_func_t read_func, pixman_write_memory_func_t write_func)
     * }
     */
    public static MethodHandle pixman_image_set_accessors$handle() {
        return pixman_image_set_accessors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_image_set_accessors(pixman_image_t *image, pixman_read_memory_func_t read_func, pixman_write_memory_func_t write_func)
     * }
     */
    public static MemorySegment pixman_image_set_accessors$address() {
        return pixman_image_set_accessors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_image_set_accessors(pixman_image_t *image, pixman_read_memory_func_t read_func, pixman_write_memory_func_t write_func)
     * }
     */
    public static void pixman_image_set_accessors(MemorySegment image, MemorySegment read_func, MemorySegment write_func) {
        var mh$ = pixman_image_set_accessors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_set_accessors", image, read_func, write_func);
            }
            mh$.invokeExact(image, read_func, write_func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_set_indexed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_set_indexed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_image_set_indexed(pixman_image_t *image, const pixman_indexed_t *indexed)
     * }
     */
    public static FunctionDescriptor pixman_image_set_indexed$descriptor() {
        return pixman_image_set_indexed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_image_set_indexed(pixman_image_t *image, const pixman_indexed_t *indexed)
     * }
     */
    public static MethodHandle pixman_image_set_indexed$handle() {
        return pixman_image_set_indexed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_image_set_indexed(pixman_image_t *image, const pixman_indexed_t *indexed)
     * }
     */
    public static MemorySegment pixman_image_set_indexed$address() {
        return pixman_image_set_indexed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_image_set_indexed(pixman_image_t *image, const pixman_indexed_t *indexed)
     * }
     */
    public static void pixman_image_set_indexed(MemorySegment image, MemorySegment indexed) {
        var mh$ = pixman_image_set_indexed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_set_indexed", image, indexed);
            }
            mh$.invokeExact(image, indexed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_get_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_get_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t *pixman_image_get_data(pixman_image_t *image)
     * }
     */
    public static FunctionDescriptor pixman_image_get_data$descriptor() {
        return pixman_image_get_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t *pixman_image_get_data(pixman_image_t *image)
     * }
     */
    public static MethodHandle pixman_image_get_data$handle() {
        return pixman_image_get_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t *pixman_image_get_data(pixman_image_t *image)
     * }
     */
    public static MemorySegment pixman_image_get_data$address() {
        return pixman_image_get_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t *pixman_image_get_data(pixman_image_t *image)
     * }
     */
    public static MemorySegment pixman_image_get_data(MemorySegment image) {
        var mh$ = pixman_image_get_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_get_data", image);
            }
            return (MemorySegment)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_get_width {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_get_width");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pixman_image_get_width(pixman_image_t *image)
     * }
     */
    public static FunctionDescriptor pixman_image_get_width$descriptor() {
        return pixman_image_get_width.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pixman_image_get_width(pixman_image_t *image)
     * }
     */
    public static MethodHandle pixman_image_get_width$handle() {
        return pixman_image_get_width.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pixman_image_get_width(pixman_image_t *image)
     * }
     */
    public static MemorySegment pixman_image_get_width$address() {
        return pixman_image_get_width.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pixman_image_get_width(pixman_image_t *image)
     * }
     */
    public static int pixman_image_get_width(MemorySegment image) {
        var mh$ = pixman_image_get_width.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_get_width", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_get_height {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_get_height");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pixman_image_get_height(pixman_image_t *image)
     * }
     */
    public static FunctionDescriptor pixman_image_get_height$descriptor() {
        return pixman_image_get_height.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pixman_image_get_height(pixman_image_t *image)
     * }
     */
    public static MethodHandle pixman_image_get_height$handle() {
        return pixman_image_get_height.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pixman_image_get_height(pixman_image_t *image)
     * }
     */
    public static MemorySegment pixman_image_get_height$address() {
        return pixman_image_get_height.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pixman_image_get_height(pixman_image_t *image)
     * }
     */
    public static int pixman_image_get_height(MemorySegment image) {
        var mh$ = pixman_image_get_height.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_get_height", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_get_stride {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_get_stride");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pixman_image_get_stride(pixman_image_t *image)
     * }
     */
    public static FunctionDescriptor pixman_image_get_stride$descriptor() {
        return pixman_image_get_stride.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pixman_image_get_stride(pixman_image_t *image)
     * }
     */
    public static MethodHandle pixman_image_get_stride$handle() {
        return pixman_image_get_stride.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pixman_image_get_stride(pixman_image_t *image)
     * }
     */
    public static MemorySegment pixman_image_get_stride$address() {
        return pixman_image_get_stride.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pixman_image_get_stride(pixman_image_t *image)
     * }
     */
    public static int pixman_image_get_stride(MemorySegment image) {
        var mh$ = pixman_image_get_stride.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_get_stride", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_get_depth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_get_depth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pixman_image_get_depth(pixman_image_t *image)
     * }
     */
    public static FunctionDescriptor pixman_image_get_depth$descriptor() {
        return pixman_image_get_depth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pixman_image_get_depth(pixman_image_t *image)
     * }
     */
    public static MethodHandle pixman_image_get_depth$handle() {
        return pixman_image_get_depth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pixman_image_get_depth(pixman_image_t *image)
     * }
     */
    public static MemorySegment pixman_image_get_depth$address() {
        return pixman_image_get_depth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pixman_image_get_depth(pixman_image_t *image)
     * }
     */
    public static int pixman_image_get_depth(MemorySegment image) {
        var mh$ = pixman_image_get_depth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_get_depth", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_get_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_get_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_format_code_t pixman_image_get_format(pixman_image_t *image)
     * }
     */
    public static FunctionDescriptor pixman_image_get_format$descriptor() {
        return pixman_image_get_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_format_code_t pixman_image_get_format(pixman_image_t *image)
     * }
     */
    public static MethodHandle pixman_image_get_format$handle() {
        return pixman_image_get_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_format_code_t pixman_image_get_format(pixman_image_t *image)
     * }
     */
    public static MemorySegment pixman_image_get_format$address() {
        return pixman_image_get_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_format_code_t pixman_image_get_format(pixman_image_t *image)
     * }
     */
    public static int pixman_image_get_format(MemorySegment image) {
        var mh$ = pixman_image_get_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_get_format", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PIXMAN_KERNEL_IMPULSE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_KERNEL_IMPULSE = 0
     * }
     */
    public static int PIXMAN_KERNEL_IMPULSE() {
        return PIXMAN_KERNEL_IMPULSE;
    }
    private static final int PIXMAN_KERNEL_BOX = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_KERNEL_BOX = 1
     * }
     */
    public static int PIXMAN_KERNEL_BOX() {
        return PIXMAN_KERNEL_BOX;
    }
    private static final int PIXMAN_KERNEL_LINEAR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_KERNEL_LINEAR = 2
     * }
     */
    public static int PIXMAN_KERNEL_LINEAR() {
        return PIXMAN_KERNEL_LINEAR;
    }
    private static final int PIXMAN_KERNEL_CUBIC = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_KERNEL_CUBIC = 3
     * }
     */
    public static int PIXMAN_KERNEL_CUBIC() {
        return PIXMAN_KERNEL_CUBIC;
    }
    private static final int PIXMAN_KERNEL_GAUSSIAN = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_KERNEL_GAUSSIAN = 4
     * }
     */
    public static int PIXMAN_KERNEL_GAUSSIAN() {
        return PIXMAN_KERNEL_GAUSSIAN;
    }
    private static final int PIXMAN_KERNEL_LANCZOS2 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_KERNEL_LANCZOS2 = 5
     * }
     */
    public static int PIXMAN_KERNEL_LANCZOS2() {
        return PIXMAN_KERNEL_LANCZOS2;
    }
    private static final int PIXMAN_KERNEL_LANCZOS3 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_KERNEL_LANCZOS3 = 6
     * }
     */
    public static int PIXMAN_KERNEL_LANCZOS3() {
        return PIXMAN_KERNEL_LANCZOS3;
    }
    private static final int PIXMAN_KERNEL_LANCZOS3_STRETCHED = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIXMAN_KERNEL_LANCZOS3_STRETCHED = 7
     * }
     */
    public static int PIXMAN_KERNEL_LANCZOS3_STRETCHED() {
        return PIXMAN_KERNEL_LANCZOS3_STRETCHED;
    }

    private static class pixman_filter_create_separable_convolution {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_filter_create_separable_convolution");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_fixed_t *pixman_filter_create_separable_convolution(int *n_values, pixman_fixed_t scale_x, pixman_fixed_t scale_y, pixman_kernel_t reconstruct_x, pixman_kernel_t reconstruct_y, pixman_kernel_t sample_x, pixman_kernel_t sample_y, int subsample_bits_x, int subsample_bits_y)
     * }
     */
    public static FunctionDescriptor pixman_filter_create_separable_convolution$descriptor() {
        return pixman_filter_create_separable_convolution.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_fixed_t *pixman_filter_create_separable_convolution(int *n_values, pixman_fixed_t scale_x, pixman_fixed_t scale_y, pixman_kernel_t reconstruct_x, pixman_kernel_t reconstruct_y, pixman_kernel_t sample_x, pixman_kernel_t sample_y, int subsample_bits_x, int subsample_bits_y)
     * }
     */
    public static MethodHandle pixman_filter_create_separable_convolution$handle() {
        return pixman_filter_create_separable_convolution.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_fixed_t *pixman_filter_create_separable_convolution(int *n_values, pixman_fixed_t scale_x, pixman_fixed_t scale_y, pixman_kernel_t reconstruct_x, pixman_kernel_t reconstruct_y, pixman_kernel_t sample_x, pixman_kernel_t sample_y, int subsample_bits_x, int subsample_bits_y)
     * }
     */
    public static MemorySegment pixman_filter_create_separable_convolution$address() {
        return pixman_filter_create_separable_convolution.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_fixed_t *pixman_filter_create_separable_convolution(int *n_values, pixman_fixed_t scale_x, pixman_fixed_t scale_y, pixman_kernel_t reconstruct_x, pixman_kernel_t reconstruct_y, pixman_kernel_t sample_x, pixman_kernel_t sample_y, int subsample_bits_x, int subsample_bits_y)
     * }
     */
    public static MemorySegment pixman_filter_create_separable_convolution(MemorySegment n_values, int scale_x, int scale_y, int reconstruct_x, int reconstruct_y, int sample_x, int sample_y, int subsample_bits_x, int subsample_bits_y) {
        var mh$ = pixman_filter_create_separable_convolution.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_filter_create_separable_convolution", n_values, scale_x, scale_y, reconstruct_x, reconstruct_y, sample_x, sample_y, subsample_bits_x, subsample_bits_y);
            }
            return (MemorySegment)mh$.invokeExact(n_values, scale_x, scale_y, reconstruct_x, reconstruct_y, sample_x, sample_y, subsample_bits_x, subsample_bits_y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_fill_rectangles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_fill_rectangles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_fill_rectangles(pixman_op_t op, pixman_image_t *image, const pixman_color_t *color, int n_rects, const pixman_rectangle16_t *rects)
     * }
     */
    public static FunctionDescriptor pixman_image_fill_rectangles$descriptor() {
        return pixman_image_fill_rectangles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_fill_rectangles(pixman_op_t op, pixman_image_t *image, const pixman_color_t *color, int n_rects, const pixman_rectangle16_t *rects)
     * }
     */
    public static MethodHandle pixman_image_fill_rectangles$handle() {
        return pixman_image_fill_rectangles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_fill_rectangles(pixman_op_t op, pixman_image_t *image, const pixman_color_t *color, int n_rects, const pixman_rectangle16_t *rects)
     * }
     */
    public static MemorySegment pixman_image_fill_rectangles$address() {
        return pixman_image_fill_rectangles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_fill_rectangles(pixman_op_t op, pixman_image_t *image, const pixman_color_t *color, int n_rects, const pixman_rectangle16_t *rects)
     * }
     */
    public static int pixman_image_fill_rectangles(int op, MemorySegment image, MemorySegment color, int n_rects, MemorySegment rects) {
        var mh$ = pixman_image_fill_rectangles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_fill_rectangles", op, image, color, n_rects, rects);
            }
            return (int)mh$.invokeExact(op, image, color, n_rects, rects);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_fill_boxes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_fill_boxes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_fill_boxes(pixman_op_t op, pixman_image_t *dest, const pixman_color_t *color, int n_boxes, const pixman_box32_t *boxes)
     * }
     */
    public static FunctionDescriptor pixman_image_fill_boxes$descriptor() {
        return pixman_image_fill_boxes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_fill_boxes(pixman_op_t op, pixman_image_t *dest, const pixman_color_t *color, int n_boxes, const pixman_box32_t *boxes)
     * }
     */
    public static MethodHandle pixman_image_fill_boxes$handle() {
        return pixman_image_fill_boxes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_fill_boxes(pixman_op_t op, pixman_image_t *dest, const pixman_color_t *color, int n_boxes, const pixman_box32_t *boxes)
     * }
     */
    public static MemorySegment pixman_image_fill_boxes$address() {
        return pixman_image_fill_boxes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_image_fill_boxes(pixman_op_t op, pixman_image_t *dest, const pixman_color_t *color, int n_boxes, const pixman_box32_t *boxes)
     * }
     */
    public static int pixman_image_fill_boxes(int op, MemorySegment dest, MemorySegment color, int n_boxes, MemorySegment boxes) {
        var mh$ = pixman_image_fill_boxes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_fill_boxes", op, dest, color, n_boxes, boxes);
            }
            return (int)mh$.invokeExact(op, dest, color, n_boxes, boxes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_compute_composite_region {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_SHORT,
            C.C_SHORT,
            C.C_SHORT,
            C.C_SHORT,
            C.C_SHORT,
            C.C_SHORT,
            C.C_SHORT,
            C.C_SHORT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_compute_composite_region");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_compute_composite_region(pixman_region16_t *region, pixman_image_t *src_image, pixman_image_t *mask_image, pixman_image_t *dest_image, int16_t src_x, int16_t src_y, int16_t mask_x, int16_t mask_y, int16_t dest_x, int16_t dest_y, uint16_t width, uint16_t height)
     * }
     */
    public static FunctionDescriptor pixman_compute_composite_region$descriptor() {
        return pixman_compute_composite_region.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_compute_composite_region(pixman_region16_t *region, pixman_image_t *src_image, pixman_image_t *mask_image, pixman_image_t *dest_image, int16_t src_x, int16_t src_y, int16_t mask_x, int16_t mask_y, int16_t dest_x, int16_t dest_y, uint16_t width, uint16_t height)
     * }
     */
    public static MethodHandle pixman_compute_composite_region$handle() {
        return pixman_compute_composite_region.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_bool_t pixman_compute_composite_region(pixman_region16_t *region, pixman_image_t *src_image, pixman_image_t *mask_image, pixman_image_t *dest_image, int16_t src_x, int16_t src_y, int16_t mask_x, int16_t mask_y, int16_t dest_x, int16_t dest_y, uint16_t width, uint16_t height)
     * }
     */
    public static MemorySegment pixman_compute_composite_region$address() {
        return pixman_compute_composite_region.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_bool_t pixman_compute_composite_region(pixman_region16_t *region, pixman_image_t *src_image, pixman_image_t *mask_image, pixman_image_t *dest_image, int16_t src_x, int16_t src_y, int16_t mask_x, int16_t mask_y, int16_t dest_x, int16_t dest_y, uint16_t width, uint16_t height)
     * }
     */
    public static int pixman_compute_composite_region(MemorySegment region, MemorySegment src_image, MemorySegment mask_image, MemorySegment dest_image, short src_x, short src_y, short mask_x, short mask_y, short dest_x, short dest_y, short width, short height) {
        var mh$ = pixman_compute_composite_region.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_compute_composite_region", region, src_image, mask_image, dest_image, src_x, src_y, mask_x, mask_y, dest_x, dest_y, width, height);
            }
            return (int)mh$.invokeExact(region, src_image, mask_image, dest_image, src_x, src_y, mask_x, mask_y, dest_x, dest_y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_composite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_SHORT,
            C.C_SHORT,
            C.C_SHORT,
            C.C_SHORT,
            C.C_SHORT,
            C.C_SHORT,
            C.C_SHORT,
            C.C_SHORT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_composite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_image_composite(pixman_op_t op, pixman_image_t *src, pixman_image_t *mask, pixman_image_t *dest, int16_t src_x, int16_t src_y, int16_t mask_x, int16_t mask_y, int16_t dest_x, int16_t dest_y, uint16_t width, uint16_t height)
     * }
     */
    public static FunctionDescriptor pixman_image_composite$descriptor() {
        return pixman_image_composite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_image_composite(pixman_op_t op, pixman_image_t *src, pixman_image_t *mask, pixman_image_t *dest, int16_t src_x, int16_t src_y, int16_t mask_x, int16_t mask_y, int16_t dest_x, int16_t dest_y, uint16_t width, uint16_t height)
     * }
     */
    public static MethodHandle pixman_image_composite$handle() {
        return pixman_image_composite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_image_composite(pixman_op_t op, pixman_image_t *src, pixman_image_t *mask, pixman_image_t *dest, int16_t src_x, int16_t src_y, int16_t mask_x, int16_t mask_y, int16_t dest_x, int16_t dest_y, uint16_t width, uint16_t height)
     * }
     */
    public static MemorySegment pixman_image_composite$address() {
        return pixman_image_composite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_image_composite(pixman_op_t op, pixman_image_t *src, pixman_image_t *mask, pixman_image_t *dest, int16_t src_x, int16_t src_y, int16_t mask_x, int16_t mask_y, int16_t dest_x, int16_t dest_y, uint16_t width, uint16_t height)
     * }
     */
    public static void pixman_image_composite(int op, MemorySegment src, MemorySegment mask, MemorySegment dest, short src_x, short src_y, short mask_x, short mask_y, short dest_x, short dest_y, short width, short height) {
        var mh$ = pixman_image_composite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_composite", op, src, mask, dest, src_x, src_y, mask_x, mask_y, dest_x, dest_y, width, height);
            }
            mh$.invokeExact(op, src, mask, dest, src_x, src_y, mask_x, mask_y, dest_x, dest_y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_image_composite32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_image_composite32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_image_composite32(pixman_op_t op, pixman_image_t *src, pixman_image_t *mask, pixman_image_t *dest, int32_t src_x, int32_t src_y, int32_t mask_x, int32_t mask_y, int32_t dest_x, int32_t dest_y, int32_t width, int32_t height)
     * }
     */
    public static FunctionDescriptor pixman_image_composite32$descriptor() {
        return pixman_image_composite32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_image_composite32(pixman_op_t op, pixman_image_t *src, pixman_image_t *mask, pixman_image_t *dest, int32_t src_x, int32_t src_y, int32_t mask_x, int32_t mask_y, int32_t dest_x, int32_t dest_y, int32_t width, int32_t height)
     * }
     */
    public static MethodHandle pixman_image_composite32$handle() {
        return pixman_image_composite32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_image_composite32(pixman_op_t op, pixman_image_t *src, pixman_image_t *mask, pixman_image_t *dest, int32_t src_x, int32_t src_y, int32_t mask_x, int32_t mask_y, int32_t dest_x, int32_t dest_y, int32_t width, int32_t height)
     * }
     */
    public static MemorySegment pixman_image_composite32$address() {
        return pixman_image_composite32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_image_composite32(pixman_op_t op, pixman_image_t *src, pixman_image_t *mask, pixman_image_t *dest, int32_t src_x, int32_t src_y, int32_t mask_x, int32_t mask_y, int32_t dest_x, int32_t dest_y, int32_t width, int32_t height)
     * }
     */
    public static void pixman_image_composite32(int op, MemorySegment src, MemorySegment mask, MemorySegment dest, int src_x, int src_y, int mask_x, int mask_y, int dest_x, int dest_y, int width, int height) {
        var mh$ = pixman_image_composite32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_image_composite32", op, src, mask, dest, src_x, src_y, mask_x, mask_y, dest_x, dest_y, width, height);
            }
            mh$.invokeExact(op, src, mask, dest, src_x, src_y, mask_x, mask_y, dest_x, dest_y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_disable_out_of_bounds_workaround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_disable_out_of_bounds_workaround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_disable_out_of_bounds_workaround()
     * }
     */
    public static FunctionDescriptor pixman_disable_out_of_bounds_workaround$descriptor() {
        return pixman_disable_out_of_bounds_workaround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_disable_out_of_bounds_workaround()
     * }
     */
    public static MethodHandle pixman_disable_out_of_bounds_workaround$handle() {
        return pixman_disable_out_of_bounds_workaround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_disable_out_of_bounds_workaround()
     * }
     */
    public static MemorySegment pixman_disable_out_of_bounds_workaround$address() {
        return pixman_disable_out_of_bounds_workaround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_disable_out_of_bounds_workaround()
     * }
     */
    public static void pixman_disable_out_of_bounds_workaround() {
        var mh$ = pixman_disable_out_of_bounds_workaround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_disable_out_of_bounds_workaround");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_glyph_cache_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER    );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_glyph_cache_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_glyph_cache_t *pixman_glyph_cache_create()
     * }
     */
    public static FunctionDescriptor pixman_glyph_cache_create$descriptor() {
        return pixman_glyph_cache_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_glyph_cache_t *pixman_glyph_cache_create()
     * }
     */
    public static MethodHandle pixman_glyph_cache_create$handle() {
        return pixman_glyph_cache_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_glyph_cache_t *pixman_glyph_cache_create()
     * }
     */
    public static MemorySegment pixman_glyph_cache_create$address() {
        return pixman_glyph_cache_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_glyph_cache_t *pixman_glyph_cache_create()
     * }
     */
    public static MemorySegment pixman_glyph_cache_create() {
        var mh$ = pixman_glyph_cache_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_glyph_cache_create");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_glyph_cache_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_glyph_cache_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_glyph_cache_destroy(pixman_glyph_cache_t *cache)
     * }
     */
    public static FunctionDescriptor pixman_glyph_cache_destroy$descriptor() {
        return pixman_glyph_cache_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_glyph_cache_destroy(pixman_glyph_cache_t *cache)
     * }
     */
    public static MethodHandle pixman_glyph_cache_destroy$handle() {
        return pixman_glyph_cache_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_glyph_cache_destroy(pixman_glyph_cache_t *cache)
     * }
     */
    public static MemorySegment pixman_glyph_cache_destroy$address() {
        return pixman_glyph_cache_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_glyph_cache_destroy(pixman_glyph_cache_t *cache)
     * }
     */
    public static void pixman_glyph_cache_destroy(MemorySegment cache) {
        var mh$ = pixman_glyph_cache_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_glyph_cache_destroy", cache);
            }
            mh$.invokeExact(cache);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_glyph_cache_freeze {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_glyph_cache_freeze");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_glyph_cache_freeze(pixman_glyph_cache_t *cache)
     * }
     */
    public static FunctionDescriptor pixman_glyph_cache_freeze$descriptor() {
        return pixman_glyph_cache_freeze.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_glyph_cache_freeze(pixman_glyph_cache_t *cache)
     * }
     */
    public static MethodHandle pixman_glyph_cache_freeze$handle() {
        return pixman_glyph_cache_freeze.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_glyph_cache_freeze(pixman_glyph_cache_t *cache)
     * }
     */
    public static MemorySegment pixman_glyph_cache_freeze$address() {
        return pixman_glyph_cache_freeze.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_glyph_cache_freeze(pixman_glyph_cache_t *cache)
     * }
     */
    public static void pixman_glyph_cache_freeze(MemorySegment cache) {
        var mh$ = pixman_glyph_cache_freeze.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_glyph_cache_freeze", cache);
            }
            mh$.invokeExact(cache);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_glyph_cache_thaw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_glyph_cache_thaw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_glyph_cache_thaw(pixman_glyph_cache_t *cache)
     * }
     */
    public static FunctionDescriptor pixman_glyph_cache_thaw$descriptor() {
        return pixman_glyph_cache_thaw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_glyph_cache_thaw(pixman_glyph_cache_t *cache)
     * }
     */
    public static MethodHandle pixman_glyph_cache_thaw$handle() {
        return pixman_glyph_cache_thaw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_glyph_cache_thaw(pixman_glyph_cache_t *cache)
     * }
     */
    public static MemorySegment pixman_glyph_cache_thaw$address() {
        return pixman_glyph_cache_thaw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_glyph_cache_thaw(pixman_glyph_cache_t *cache)
     * }
     */
    public static void pixman_glyph_cache_thaw(MemorySegment cache) {
        var mh$ = pixman_glyph_cache_thaw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_glyph_cache_thaw", cache);
            }
            mh$.invokeExact(cache);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_glyph_cache_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_glyph_cache_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const void *pixman_glyph_cache_lookup(pixman_glyph_cache_t *cache, void *font_key, void *glyph_key)
     * }
     */
    public static FunctionDescriptor pixman_glyph_cache_lookup$descriptor() {
        return pixman_glyph_cache_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const void *pixman_glyph_cache_lookup(pixman_glyph_cache_t *cache, void *font_key, void *glyph_key)
     * }
     */
    public static MethodHandle pixman_glyph_cache_lookup$handle() {
        return pixman_glyph_cache_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const void *pixman_glyph_cache_lookup(pixman_glyph_cache_t *cache, void *font_key, void *glyph_key)
     * }
     */
    public static MemorySegment pixman_glyph_cache_lookup$address() {
        return pixman_glyph_cache_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const void *pixman_glyph_cache_lookup(pixman_glyph_cache_t *cache, void *font_key, void *glyph_key)
     * }
     */
    public static MemorySegment pixman_glyph_cache_lookup(MemorySegment cache, MemorySegment font_key, MemorySegment glyph_key) {
        var mh$ = pixman_glyph_cache_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_glyph_cache_lookup", cache, font_key, glyph_key);
            }
            return (MemorySegment)mh$.invokeExact(cache, font_key, glyph_key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_glyph_cache_insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_glyph_cache_insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const void *pixman_glyph_cache_insert(pixman_glyph_cache_t *cache, void *font_key, void *glyph_key, int origin_x, int origin_y, pixman_image_t *glyph_image)
     * }
     */
    public static FunctionDescriptor pixman_glyph_cache_insert$descriptor() {
        return pixman_glyph_cache_insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const void *pixman_glyph_cache_insert(pixman_glyph_cache_t *cache, void *font_key, void *glyph_key, int origin_x, int origin_y, pixman_image_t *glyph_image)
     * }
     */
    public static MethodHandle pixman_glyph_cache_insert$handle() {
        return pixman_glyph_cache_insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const void *pixman_glyph_cache_insert(pixman_glyph_cache_t *cache, void *font_key, void *glyph_key, int origin_x, int origin_y, pixman_image_t *glyph_image)
     * }
     */
    public static MemorySegment pixman_glyph_cache_insert$address() {
        return pixman_glyph_cache_insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const void *pixman_glyph_cache_insert(pixman_glyph_cache_t *cache, void *font_key, void *glyph_key, int origin_x, int origin_y, pixman_image_t *glyph_image)
     * }
     */
    public static MemorySegment pixman_glyph_cache_insert(MemorySegment cache, MemorySegment font_key, MemorySegment glyph_key, int origin_x, int origin_y, MemorySegment glyph_image) {
        var mh$ = pixman_glyph_cache_insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_glyph_cache_insert", cache, font_key, glyph_key, origin_x, origin_y, glyph_image);
            }
            return (MemorySegment)mh$.invokeExact(cache, font_key, glyph_key, origin_x, origin_y, glyph_image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_glyph_cache_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_glyph_cache_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_glyph_cache_remove(pixman_glyph_cache_t *cache, void *font_key, void *glyph_key)
     * }
     */
    public static FunctionDescriptor pixman_glyph_cache_remove$descriptor() {
        return pixman_glyph_cache_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_glyph_cache_remove(pixman_glyph_cache_t *cache, void *font_key, void *glyph_key)
     * }
     */
    public static MethodHandle pixman_glyph_cache_remove$handle() {
        return pixman_glyph_cache_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_glyph_cache_remove(pixman_glyph_cache_t *cache, void *font_key, void *glyph_key)
     * }
     */
    public static MemorySegment pixman_glyph_cache_remove$address() {
        return pixman_glyph_cache_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_glyph_cache_remove(pixman_glyph_cache_t *cache, void *font_key, void *glyph_key)
     * }
     */
    public static void pixman_glyph_cache_remove(MemorySegment cache, MemorySegment font_key, MemorySegment glyph_key) {
        var mh$ = pixman_glyph_cache_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_glyph_cache_remove", cache, font_key, glyph_key);
            }
            mh$.invokeExact(cache, font_key, glyph_key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_glyph_get_extents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_glyph_get_extents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_glyph_get_extents(pixman_glyph_cache_t *cache, int n_glyphs, pixman_glyph_t *glyphs, pixman_box32_t *extents)
     * }
     */
    public static FunctionDescriptor pixman_glyph_get_extents$descriptor() {
        return pixman_glyph_get_extents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_glyph_get_extents(pixman_glyph_cache_t *cache, int n_glyphs, pixman_glyph_t *glyphs, pixman_box32_t *extents)
     * }
     */
    public static MethodHandle pixman_glyph_get_extents$handle() {
        return pixman_glyph_get_extents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_glyph_get_extents(pixman_glyph_cache_t *cache, int n_glyphs, pixman_glyph_t *glyphs, pixman_box32_t *extents)
     * }
     */
    public static MemorySegment pixman_glyph_get_extents$address() {
        return pixman_glyph_get_extents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_glyph_get_extents(pixman_glyph_cache_t *cache, int n_glyphs, pixman_glyph_t *glyphs, pixman_box32_t *extents)
     * }
     */
    public static void pixman_glyph_get_extents(MemorySegment cache, int n_glyphs, MemorySegment glyphs, MemorySegment extents) {
        var mh$ = pixman_glyph_get_extents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_glyph_get_extents", cache, n_glyphs, glyphs, extents);
            }
            mh$.invokeExact(cache, n_glyphs, glyphs, extents);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_glyph_get_mask_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_glyph_get_mask_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_format_code_t pixman_glyph_get_mask_format(pixman_glyph_cache_t *cache, int n_glyphs, const pixman_glyph_t *glyphs)
     * }
     */
    public static FunctionDescriptor pixman_glyph_get_mask_format$descriptor() {
        return pixman_glyph_get_mask_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_format_code_t pixman_glyph_get_mask_format(pixman_glyph_cache_t *cache, int n_glyphs, const pixman_glyph_t *glyphs)
     * }
     */
    public static MethodHandle pixman_glyph_get_mask_format$handle() {
        return pixman_glyph_get_mask_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_format_code_t pixman_glyph_get_mask_format(pixman_glyph_cache_t *cache, int n_glyphs, const pixman_glyph_t *glyphs)
     * }
     */
    public static MemorySegment pixman_glyph_get_mask_format$address() {
        return pixman_glyph_get_mask_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_format_code_t pixman_glyph_get_mask_format(pixman_glyph_cache_t *cache, int n_glyphs, const pixman_glyph_t *glyphs)
     * }
     */
    public static int pixman_glyph_get_mask_format(MemorySegment cache, int n_glyphs, MemorySegment glyphs) {
        var mh$ = pixman_glyph_get_mask_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_glyph_get_mask_format", cache, n_glyphs, glyphs);
            }
            return (int)mh$.invokeExact(cache, n_glyphs, glyphs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_composite_glyphs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_composite_glyphs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_composite_glyphs(pixman_op_t op, pixman_image_t *src, pixman_image_t *dest, pixman_format_code_t mask_format, int32_t src_x, int32_t src_y, int32_t mask_x, int32_t mask_y, int32_t dest_x, int32_t dest_y, int32_t width, int32_t height, pixman_glyph_cache_t *cache, int n_glyphs, const pixman_glyph_t *glyphs)
     * }
     */
    public static FunctionDescriptor pixman_composite_glyphs$descriptor() {
        return pixman_composite_glyphs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_composite_glyphs(pixman_op_t op, pixman_image_t *src, pixman_image_t *dest, pixman_format_code_t mask_format, int32_t src_x, int32_t src_y, int32_t mask_x, int32_t mask_y, int32_t dest_x, int32_t dest_y, int32_t width, int32_t height, pixman_glyph_cache_t *cache, int n_glyphs, const pixman_glyph_t *glyphs)
     * }
     */
    public static MethodHandle pixman_composite_glyphs$handle() {
        return pixman_composite_glyphs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_composite_glyphs(pixman_op_t op, pixman_image_t *src, pixman_image_t *dest, pixman_format_code_t mask_format, int32_t src_x, int32_t src_y, int32_t mask_x, int32_t mask_y, int32_t dest_x, int32_t dest_y, int32_t width, int32_t height, pixman_glyph_cache_t *cache, int n_glyphs, const pixman_glyph_t *glyphs)
     * }
     */
    public static MemorySegment pixman_composite_glyphs$address() {
        return pixman_composite_glyphs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_composite_glyphs(pixman_op_t op, pixman_image_t *src, pixman_image_t *dest, pixman_format_code_t mask_format, int32_t src_x, int32_t src_y, int32_t mask_x, int32_t mask_y, int32_t dest_x, int32_t dest_y, int32_t width, int32_t height, pixman_glyph_cache_t *cache, int n_glyphs, const pixman_glyph_t *glyphs)
     * }
     */
    public static void pixman_composite_glyphs(int op, MemorySegment src, MemorySegment dest, int mask_format, int src_x, int src_y, int mask_x, int mask_y, int dest_x, int dest_y, int width, int height, MemorySegment cache, int n_glyphs, MemorySegment glyphs) {
        var mh$ = pixman_composite_glyphs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_composite_glyphs", op, src, dest, mask_format, src_x, src_y, mask_x, mask_y, dest_x, dest_y, width, height, cache, n_glyphs, glyphs);
            }
            mh$.invokeExact(op, src, dest, mask_format, src_x, src_y, mask_x, mask_y, dest_x, dest_y, width, height, cache, n_glyphs, glyphs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_composite_glyphs_no_mask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_composite_glyphs_no_mask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_composite_glyphs_no_mask(pixman_op_t op, pixman_image_t *src, pixman_image_t *dest, int32_t src_x, int32_t src_y, int32_t dest_x, int32_t dest_y, pixman_glyph_cache_t *cache, int n_glyphs, const pixman_glyph_t *glyphs)
     * }
     */
    public static FunctionDescriptor pixman_composite_glyphs_no_mask$descriptor() {
        return pixman_composite_glyphs_no_mask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_composite_glyphs_no_mask(pixman_op_t op, pixman_image_t *src, pixman_image_t *dest, int32_t src_x, int32_t src_y, int32_t dest_x, int32_t dest_y, pixman_glyph_cache_t *cache, int n_glyphs, const pixman_glyph_t *glyphs)
     * }
     */
    public static MethodHandle pixman_composite_glyphs_no_mask$handle() {
        return pixman_composite_glyphs_no_mask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_composite_glyphs_no_mask(pixman_op_t op, pixman_image_t *src, pixman_image_t *dest, int32_t src_x, int32_t src_y, int32_t dest_x, int32_t dest_y, pixman_glyph_cache_t *cache, int n_glyphs, const pixman_glyph_t *glyphs)
     * }
     */
    public static MemorySegment pixman_composite_glyphs_no_mask$address() {
        return pixman_composite_glyphs_no_mask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_composite_glyphs_no_mask(pixman_op_t op, pixman_image_t *src, pixman_image_t *dest, int32_t src_x, int32_t src_y, int32_t dest_x, int32_t dest_y, pixman_glyph_cache_t *cache, int n_glyphs, const pixman_glyph_t *glyphs)
     * }
     */
    public static void pixman_composite_glyphs_no_mask(int op, MemorySegment src, MemorySegment dest, int src_x, int src_y, int dest_x, int dest_y, MemorySegment cache, int n_glyphs, MemorySegment glyphs) {
        var mh$ = pixman_composite_glyphs_no_mask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_composite_glyphs_no_mask", op, src, dest, src_x, src_y, dest_x, dest_y, cache, n_glyphs, glyphs);
            }
            mh$.invokeExact(op, src, dest, src_x, src_y, dest_x, dest_y, cache, n_glyphs, glyphs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_sample_ceil_y {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_sample_ceil_y");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_fixed_t pixman_sample_ceil_y(pixman_fixed_t y, int bpp)
     * }
     */
    public static FunctionDescriptor pixman_sample_ceil_y$descriptor() {
        return pixman_sample_ceil_y.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_fixed_t pixman_sample_ceil_y(pixman_fixed_t y, int bpp)
     * }
     */
    public static MethodHandle pixman_sample_ceil_y$handle() {
        return pixman_sample_ceil_y.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_fixed_t pixman_sample_ceil_y(pixman_fixed_t y, int bpp)
     * }
     */
    public static MemorySegment pixman_sample_ceil_y$address() {
        return pixman_sample_ceil_y.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_fixed_t pixman_sample_ceil_y(pixman_fixed_t y, int bpp)
     * }
     */
    public static int pixman_sample_ceil_y(int y, int bpp) {
        var mh$ = pixman_sample_ceil_y.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_sample_ceil_y", y, bpp);
            }
            return (int)mh$.invokeExact(y, bpp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_sample_floor_y {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_sample_floor_y");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pixman_fixed_t pixman_sample_floor_y(pixman_fixed_t y, int bpp)
     * }
     */
    public static FunctionDescriptor pixman_sample_floor_y$descriptor() {
        return pixman_sample_floor_y.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pixman_fixed_t pixman_sample_floor_y(pixman_fixed_t y, int bpp)
     * }
     */
    public static MethodHandle pixman_sample_floor_y$handle() {
        return pixman_sample_floor_y.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pixman_fixed_t pixman_sample_floor_y(pixman_fixed_t y, int bpp)
     * }
     */
    public static MemorySegment pixman_sample_floor_y$address() {
        return pixman_sample_floor_y.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pixman_fixed_t pixman_sample_floor_y(pixman_fixed_t y, int bpp)
     * }
     */
    public static int pixman_sample_floor_y(int y, int bpp) {
        var mh$ = pixman_sample_floor_y.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_sample_floor_y", y, bpp);
            }
            return (int)mh$.invokeExact(y, bpp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_edge_step {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_edge_step");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_edge_step(pixman_edge_t *e, int n)
     * }
     */
    public static FunctionDescriptor pixman_edge_step$descriptor() {
        return pixman_edge_step.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_edge_step(pixman_edge_t *e, int n)
     * }
     */
    public static MethodHandle pixman_edge_step$handle() {
        return pixman_edge_step.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_edge_step(pixman_edge_t *e, int n)
     * }
     */
    public static MemorySegment pixman_edge_step$address() {
        return pixman_edge_step.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_edge_step(pixman_edge_t *e, int n)
     * }
     */
    public static void pixman_edge_step(MemorySegment e, int n) {
        var mh$ = pixman_edge_step.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_edge_step", e, n);
            }
            mh$.invokeExact(e, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_edge_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_edge_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_edge_init(pixman_edge_t *e, int bpp, pixman_fixed_t y_start, pixman_fixed_t x_top, pixman_fixed_t y_top, pixman_fixed_t x_bot, pixman_fixed_t y_bot)
     * }
     */
    public static FunctionDescriptor pixman_edge_init$descriptor() {
        return pixman_edge_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_edge_init(pixman_edge_t *e, int bpp, pixman_fixed_t y_start, pixman_fixed_t x_top, pixman_fixed_t y_top, pixman_fixed_t x_bot, pixman_fixed_t y_bot)
     * }
     */
    public static MethodHandle pixman_edge_init$handle() {
        return pixman_edge_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_edge_init(pixman_edge_t *e, int bpp, pixman_fixed_t y_start, pixman_fixed_t x_top, pixman_fixed_t y_top, pixman_fixed_t x_bot, pixman_fixed_t y_bot)
     * }
     */
    public static MemorySegment pixman_edge_init$address() {
        return pixman_edge_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_edge_init(pixman_edge_t *e, int bpp, pixman_fixed_t y_start, pixman_fixed_t x_top, pixman_fixed_t y_top, pixman_fixed_t x_bot, pixman_fixed_t y_bot)
     * }
     */
    public static void pixman_edge_init(MemorySegment e, int bpp, int y_start, int x_top, int y_top, int x_bot, int y_bot) {
        var mh$ = pixman_edge_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_edge_init", e, bpp, y_start, x_top, y_top, x_bot, y_bot);
            }
            mh$.invokeExact(e, bpp, y_start, x_top, y_top, x_bot, y_bot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_line_fixed_edge_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_line_fixed_edge_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_line_fixed_edge_init(pixman_edge_t *e, int bpp, pixman_fixed_t y, const pixman_line_fixed_t *line, int x_off, int y_off)
     * }
     */
    public static FunctionDescriptor pixman_line_fixed_edge_init$descriptor() {
        return pixman_line_fixed_edge_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_line_fixed_edge_init(pixman_edge_t *e, int bpp, pixman_fixed_t y, const pixman_line_fixed_t *line, int x_off, int y_off)
     * }
     */
    public static MethodHandle pixman_line_fixed_edge_init$handle() {
        return pixman_line_fixed_edge_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_line_fixed_edge_init(pixman_edge_t *e, int bpp, pixman_fixed_t y, const pixman_line_fixed_t *line, int x_off, int y_off)
     * }
     */
    public static MemorySegment pixman_line_fixed_edge_init$address() {
        return pixman_line_fixed_edge_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_line_fixed_edge_init(pixman_edge_t *e, int bpp, pixman_fixed_t y, const pixman_line_fixed_t *line, int x_off, int y_off)
     * }
     */
    public static void pixman_line_fixed_edge_init(MemorySegment e, int bpp, int y, MemorySegment line, int x_off, int y_off) {
        var mh$ = pixman_line_fixed_edge_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_line_fixed_edge_init", e, bpp, y, line, x_off, y_off);
            }
            mh$.invokeExact(e, bpp, y, line, x_off, y_off);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_rasterize_edges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_rasterize_edges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_rasterize_edges(pixman_image_t *image, pixman_edge_t *l, pixman_edge_t *r, pixman_fixed_t t, pixman_fixed_t b)
     * }
     */
    public static FunctionDescriptor pixman_rasterize_edges$descriptor() {
        return pixman_rasterize_edges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_rasterize_edges(pixman_image_t *image, pixman_edge_t *l, pixman_edge_t *r, pixman_fixed_t t, pixman_fixed_t b)
     * }
     */
    public static MethodHandle pixman_rasterize_edges$handle() {
        return pixman_rasterize_edges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_rasterize_edges(pixman_image_t *image, pixman_edge_t *l, pixman_edge_t *r, pixman_fixed_t t, pixman_fixed_t b)
     * }
     */
    public static MemorySegment pixman_rasterize_edges$address() {
        return pixman_rasterize_edges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_rasterize_edges(pixman_image_t *image, pixman_edge_t *l, pixman_edge_t *r, pixman_fixed_t t, pixman_fixed_t b)
     * }
     */
    public static void pixman_rasterize_edges(MemorySegment image, MemorySegment l, MemorySegment r, int t, int b) {
        var mh$ = pixman_rasterize_edges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_rasterize_edges", image, l, r, t, b);
            }
            mh$.invokeExact(image, l, r, t, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_add_traps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_SHORT,
            C.C_SHORT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_add_traps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_add_traps(pixman_image_t *image, int16_t x_off, int16_t y_off, int ntrap, const pixman_trap_t *traps)
     * }
     */
    public static FunctionDescriptor pixman_add_traps$descriptor() {
        return pixman_add_traps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_add_traps(pixman_image_t *image, int16_t x_off, int16_t y_off, int ntrap, const pixman_trap_t *traps)
     * }
     */
    public static MethodHandle pixman_add_traps$handle() {
        return pixman_add_traps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_add_traps(pixman_image_t *image, int16_t x_off, int16_t y_off, int ntrap, const pixman_trap_t *traps)
     * }
     */
    public static MemorySegment pixman_add_traps$address() {
        return pixman_add_traps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_add_traps(pixman_image_t *image, int16_t x_off, int16_t y_off, int ntrap, const pixman_trap_t *traps)
     * }
     */
    public static void pixman_add_traps(MemorySegment image, short x_off, short y_off, int ntrap, MemorySegment traps) {
        var mh$ = pixman_add_traps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_add_traps", image, x_off, y_off, ntrap, traps);
            }
            mh$.invokeExact(image, x_off, y_off, ntrap, traps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_add_trapezoids {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_SHORT,
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_add_trapezoids");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_add_trapezoids(pixman_image_t *image, int16_t x_off, int y_off, int ntraps, const pixman_trapezoid_t *traps)
     * }
     */
    public static FunctionDescriptor pixman_add_trapezoids$descriptor() {
        return pixman_add_trapezoids.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_add_trapezoids(pixman_image_t *image, int16_t x_off, int y_off, int ntraps, const pixman_trapezoid_t *traps)
     * }
     */
    public static MethodHandle pixman_add_trapezoids$handle() {
        return pixman_add_trapezoids.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_add_trapezoids(pixman_image_t *image, int16_t x_off, int y_off, int ntraps, const pixman_trapezoid_t *traps)
     * }
     */
    public static MemorySegment pixman_add_trapezoids$address() {
        return pixman_add_trapezoids.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_add_trapezoids(pixman_image_t *image, int16_t x_off, int y_off, int ntraps, const pixman_trapezoid_t *traps)
     * }
     */
    public static void pixman_add_trapezoids(MemorySegment image, short x_off, int y_off, int ntraps, MemorySegment traps) {
        var mh$ = pixman_add_trapezoids.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_add_trapezoids", image, x_off, y_off, ntraps, traps);
            }
            mh$.invokeExact(image, x_off, y_off, ntraps, traps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_rasterize_trapezoid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_rasterize_trapezoid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_rasterize_trapezoid(pixman_image_t *image, const pixman_trapezoid_t *trap, int x_off, int y_off)
     * }
     */
    public static FunctionDescriptor pixman_rasterize_trapezoid$descriptor() {
        return pixman_rasterize_trapezoid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_rasterize_trapezoid(pixman_image_t *image, const pixman_trapezoid_t *trap, int x_off, int y_off)
     * }
     */
    public static MethodHandle pixman_rasterize_trapezoid$handle() {
        return pixman_rasterize_trapezoid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_rasterize_trapezoid(pixman_image_t *image, const pixman_trapezoid_t *trap, int x_off, int y_off)
     * }
     */
    public static MemorySegment pixman_rasterize_trapezoid$address() {
        return pixman_rasterize_trapezoid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_rasterize_trapezoid(pixman_image_t *image, const pixman_trapezoid_t *trap, int x_off, int y_off)
     * }
     */
    public static void pixman_rasterize_trapezoid(MemorySegment image, MemorySegment trap, int x_off, int y_off) {
        var mh$ = pixman_rasterize_trapezoid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_rasterize_trapezoid", image, trap, x_off, y_off);
            }
            mh$.invokeExact(image, trap, x_off, y_off);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_composite_trapezoids {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_composite_trapezoids");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_composite_trapezoids(pixman_op_t op, pixman_image_t *src, pixman_image_t *dst, pixman_format_code_t mask_format, int x_src, int y_src, int x_dst, int y_dst, int n_traps, const pixman_trapezoid_t *traps)
     * }
     */
    public static FunctionDescriptor pixman_composite_trapezoids$descriptor() {
        return pixman_composite_trapezoids.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_composite_trapezoids(pixman_op_t op, pixman_image_t *src, pixman_image_t *dst, pixman_format_code_t mask_format, int x_src, int y_src, int x_dst, int y_dst, int n_traps, const pixman_trapezoid_t *traps)
     * }
     */
    public static MethodHandle pixman_composite_trapezoids$handle() {
        return pixman_composite_trapezoids.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_composite_trapezoids(pixman_op_t op, pixman_image_t *src, pixman_image_t *dst, pixman_format_code_t mask_format, int x_src, int y_src, int x_dst, int y_dst, int n_traps, const pixman_trapezoid_t *traps)
     * }
     */
    public static MemorySegment pixman_composite_trapezoids$address() {
        return pixman_composite_trapezoids.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_composite_trapezoids(pixman_op_t op, pixman_image_t *src, pixman_image_t *dst, pixman_format_code_t mask_format, int x_src, int y_src, int x_dst, int y_dst, int n_traps, const pixman_trapezoid_t *traps)
     * }
     */
    public static void pixman_composite_trapezoids(int op, MemorySegment src, MemorySegment dst, int mask_format, int x_src, int y_src, int x_dst, int y_dst, int n_traps, MemorySegment traps) {
        var mh$ = pixman_composite_trapezoids.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_composite_trapezoids", op, src, dst, mask_format, x_src, y_src, x_dst, y_dst, n_traps, traps);
            }
            mh$.invokeExact(op, src, dst, mask_format, x_src, y_src, x_dst, y_dst, n_traps, traps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_composite_triangles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_composite_triangles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_composite_triangles(pixman_op_t op, pixman_image_t *src, pixman_image_t *dst, pixman_format_code_t mask_format, int x_src, int y_src, int x_dst, int y_dst, int n_tris, const pixman_triangle_t *tris)
     * }
     */
    public static FunctionDescriptor pixman_composite_triangles$descriptor() {
        return pixman_composite_triangles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_composite_triangles(pixman_op_t op, pixman_image_t *src, pixman_image_t *dst, pixman_format_code_t mask_format, int x_src, int y_src, int x_dst, int y_dst, int n_tris, const pixman_triangle_t *tris)
     * }
     */
    public static MethodHandle pixman_composite_triangles$handle() {
        return pixman_composite_triangles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_composite_triangles(pixman_op_t op, pixman_image_t *src, pixman_image_t *dst, pixman_format_code_t mask_format, int x_src, int y_src, int x_dst, int y_dst, int n_tris, const pixman_triangle_t *tris)
     * }
     */
    public static MemorySegment pixman_composite_triangles$address() {
        return pixman_composite_triangles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_composite_triangles(pixman_op_t op, pixman_image_t *src, pixman_image_t *dst, pixman_format_code_t mask_format, int x_src, int y_src, int x_dst, int y_dst, int n_tris, const pixman_triangle_t *tris)
     * }
     */
    public static void pixman_composite_triangles(int op, MemorySegment src, MemorySegment dst, int mask_format, int x_src, int y_src, int x_dst, int y_dst, int n_tris, MemorySegment tris) {
        var mh$ = pixman_composite_triangles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_composite_triangles", op, src, dst, mask_format, x_src, y_src, x_dst, y_dst, n_tris, tris);
            }
            mh$.invokeExact(op, src, dst, mask_format, x_src, y_src, x_dst, y_dst, n_tris, tris);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pixman_add_triangles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pixman_add_triangles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pixman_add_triangles(pixman_image_t *image, int32_t x_off, int32_t y_off, int n_tris, const pixman_triangle_t *tris)
     * }
     */
    public static FunctionDescriptor pixman_add_triangles$descriptor() {
        return pixman_add_triangles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pixman_add_triangles(pixman_image_t *image, int32_t x_off, int32_t y_off, int n_tris, const pixman_triangle_t *tris)
     * }
     */
    public static MethodHandle pixman_add_triangles$handle() {
        return pixman_add_triangles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pixman_add_triangles(pixman_image_t *image, int32_t x_off, int32_t y_off, int n_tris, const pixman_triangle_t *tris)
     * }
     */
    public static MemorySegment pixman_add_triangles$address() {
        return pixman_add_triangles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pixman_add_triangles(pixman_image_t *image, int32_t x_off, int32_t y_off, int n_tris, const pixman_triangle_t *tris)
     * }
     */
    public static void pixman_add_triangles(MemorySegment image, int x_off, int y_off, int n_tris, MemorySegment tris) {
        var mh$ = pixman_add_triangles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pixman_add_triangles", image, x_off, y_off, n_tris, tris);
            }
            mh$.invokeExact(image, x_off, y_off, n_tris, tris);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_box_closest_point {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_box_closest_point");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_box_closest_point(const struct wlr_box *box, double x, double y, double *dest_x, double *dest_y)
     * }
     */
    public static FunctionDescriptor wlr_box_closest_point$descriptor() {
        return wlr_box_closest_point.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_box_closest_point(const struct wlr_box *box, double x, double y, double *dest_x, double *dest_y)
     * }
     */
    public static MethodHandle wlr_box_closest_point$handle() {
        return wlr_box_closest_point.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_box_closest_point(const struct wlr_box *box, double x, double y, double *dest_x, double *dest_y)
     * }
     */
    public static MemorySegment wlr_box_closest_point$address() {
        return wlr_box_closest_point.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_box_closest_point(const struct wlr_box *box, double x, double y, double *dest_x, double *dest_y)
     * }
     */
    public static void wlr_box_closest_point(MemorySegment box, double x, double y, MemorySegment dest_x, MemorySegment dest_y) {
        var mh$ = wlr_box_closest_point.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_box_closest_point", box, x, y, dest_x, dest_y);
            }
            mh$.invokeExact(box, x, y, dest_x, dest_y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_box_intersection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_box_intersection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_box_intersection(struct wlr_box *dest, const struct wlr_box *box_a, const struct wlr_box *box_b)
     * }
     */
    public static FunctionDescriptor wlr_box_intersection$descriptor() {
        return wlr_box_intersection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_box_intersection(struct wlr_box *dest, const struct wlr_box *box_a, const struct wlr_box *box_b)
     * }
     */
    public static MethodHandle wlr_box_intersection$handle() {
        return wlr_box_intersection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_box_intersection(struct wlr_box *dest, const struct wlr_box *box_a, const struct wlr_box *box_b)
     * }
     */
    public static MemorySegment wlr_box_intersection$address() {
        return wlr_box_intersection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_box_intersection(struct wlr_box *dest, const struct wlr_box *box_a, const struct wlr_box *box_b)
     * }
     */
    public static boolean wlr_box_intersection(MemorySegment dest, MemorySegment box_a, MemorySegment box_b) {
        var mh$ = wlr_box_intersection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_box_intersection", dest, box_a, box_b);
            }
            return (boolean)mh$.invokeExact(dest, box_a, box_b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_box_contains_point {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_box_contains_point");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_box_contains_point(const struct wlr_box *box, double x, double y)
     * }
     */
    public static FunctionDescriptor wlr_box_contains_point$descriptor() {
        return wlr_box_contains_point.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_box_contains_point(const struct wlr_box *box, double x, double y)
     * }
     */
    public static MethodHandle wlr_box_contains_point$handle() {
        return wlr_box_contains_point.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_box_contains_point(const struct wlr_box *box, double x, double y)
     * }
     */
    public static MemorySegment wlr_box_contains_point$address() {
        return wlr_box_contains_point.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_box_contains_point(const struct wlr_box *box, double x, double y)
     * }
     */
    public static boolean wlr_box_contains_point(MemorySegment box, double x, double y) {
        var mh$ = wlr_box_contains_point.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_box_contains_point", box, x, y);
            }
            return (boolean)mh$.invokeExact(box, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_box_empty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_box_empty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_box_empty(const struct wlr_box *box)
     * }
     */
    public static FunctionDescriptor wlr_box_empty$descriptor() {
        return wlr_box_empty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_box_empty(const struct wlr_box *box)
     * }
     */
    public static MethodHandle wlr_box_empty$handle() {
        return wlr_box_empty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_box_empty(const struct wlr_box *box)
     * }
     */
    public static MemorySegment wlr_box_empty$address() {
        return wlr_box_empty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_box_empty(const struct wlr_box *box)
     * }
     */
    public static boolean wlr_box_empty(MemorySegment box) {
        var mh$ = wlr_box_empty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_box_empty", box);
            }
            return (boolean)mh$.invokeExact(box);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_box_transform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_box_transform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_box_transform(struct wlr_box *dest, const struct wlr_box *box, enum wl_output_transform transform, int width, int height)
     * }
     */
    public static FunctionDescriptor wlr_box_transform$descriptor() {
        return wlr_box_transform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_box_transform(struct wlr_box *dest, const struct wlr_box *box, enum wl_output_transform transform, int width, int height)
     * }
     */
    public static MethodHandle wlr_box_transform$handle() {
        return wlr_box_transform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_box_transform(struct wlr_box *dest, const struct wlr_box *box, enum wl_output_transform transform, int width, int height)
     * }
     */
    public static MemorySegment wlr_box_transform$address() {
        return wlr_box_transform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_box_transform(struct wlr_box *dest, const struct wlr_box *box, enum wl_output_transform transform, int width, int height)
     * }
     */
    public static void wlr_box_transform(MemorySegment dest, MemorySegment box, int transform, int width, int height) {
        var mh$ = wlr_box_transform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_box_transform", dest, box, transform, width, height);
            }
            mh$.invokeExact(dest, box, transform, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_fbox_empty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_fbox_empty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_fbox_empty(const struct wlr_fbox *box)
     * }
     */
    public static FunctionDescriptor wlr_fbox_empty$descriptor() {
        return wlr_fbox_empty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_fbox_empty(const struct wlr_fbox *box)
     * }
     */
    public static MethodHandle wlr_fbox_empty$handle() {
        return wlr_fbox_empty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_fbox_empty(const struct wlr_fbox *box)
     * }
     */
    public static MemorySegment wlr_fbox_empty$address() {
        return wlr_fbox_empty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_fbox_empty(const struct wlr_fbox *box)
     * }
     */
    public static boolean wlr_fbox_empty(MemorySegment box) {
        var mh$ = wlr_fbox_empty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_fbox_empty", box);
            }
            return (boolean)mh$.invokeExact(box);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_fbox_transform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_fbox_transform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_fbox_transform(struct wlr_fbox *dest, const struct wlr_fbox *box, enum wl_output_transform transform, double width, double height)
     * }
     */
    public static FunctionDescriptor wlr_fbox_transform$descriptor() {
        return wlr_fbox_transform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_fbox_transform(struct wlr_fbox *dest, const struct wlr_fbox *box, enum wl_output_transform transform, double width, double height)
     * }
     */
    public static MethodHandle wlr_fbox_transform$handle() {
        return wlr_fbox_transform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_fbox_transform(struct wlr_fbox *dest, const struct wlr_fbox *box, enum wl_output_transform transform, double width, double height)
     * }
     */
    public static MemorySegment wlr_fbox_transform$address() {
        return wlr_fbox_transform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_fbox_transform(struct wlr_fbox *dest, const struct wlr_fbox *box, enum wl_output_transform transform, double width, double height)
     * }
     */
    public static void wlr_fbox_transform(MemorySegment dest, MemorySegment box, int transform, double width, double height) {
        var mh$ = wlr_fbox_transform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_fbox_transform", dest, box, transform, width, height);
            }
            mh$.invokeExact(dest, box, transform, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_box_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_box_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_box_equal(const struct wlr_box *a, const struct wlr_box *b)
     * }
     */
    public static FunctionDescriptor wlr_box_equal$descriptor() {
        return wlr_box_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_box_equal(const struct wlr_box *a, const struct wlr_box *b)
     * }
     */
    public static MethodHandle wlr_box_equal$handle() {
        return wlr_box_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_box_equal(const struct wlr_box *a, const struct wlr_box *b)
     * }
     */
    public static MemorySegment wlr_box_equal$address() {
        return wlr_box_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_box_equal(const struct wlr_box *a, const struct wlr_box *b)
     * }
     */
    public static boolean wlr_box_equal(MemorySegment a, MemorySegment b) {
        var mh$ = wlr_box_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_box_equal", a, b);
            }
            return (boolean)mh$.invokeExact(a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_fbox_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_fbox_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_fbox_equal(const struct wlr_fbox *a, const struct wlr_fbox *b)
     * }
     */
    public static FunctionDescriptor wlr_fbox_equal$descriptor() {
        return wlr_fbox_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_fbox_equal(const struct wlr_fbox *a, const struct wlr_fbox *b)
     * }
     */
    public static MethodHandle wlr_fbox_equal$handle() {
        return wlr_fbox_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_fbox_equal(const struct wlr_fbox *a, const struct wlr_fbox *b)
     * }
     */
    public static MemorySegment wlr_fbox_equal$address() {
        return wlr_fbox_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_fbox_equal(const struct wlr_fbox *a, const struct wlr_fbox *b)
     * }
     */
    public static boolean wlr_fbox_equal(MemorySegment a, MemorySegment b) {
        var mh$ = wlr_fbox_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_fbox_equal", a, b);
            }
            return (boolean)mh$.invokeExact(a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_renderer_begin_buffer_pass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_renderer_begin_buffer_pass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_render_pass *wlr_renderer_begin_buffer_pass(struct wlr_renderer *renderer, struct wlr_buffer *buffer, const struct wlr_buffer_pass_options *options)
     * }
     */
    public static FunctionDescriptor wlr_renderer_begin_buffer_pass$descriptor() {
        return wlr_renderer_begin_buffer_pass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_render_pass *wlr_renderer_begin_buffer_pass(struct wlr_renderer *renderer, struct wlr_buffer *buffer, const struct wlr_buffer_pass_options *options)
     * }
     */
    public static MethodHandle wlr_renderer_begin_buffer_pass$handle() {
        return wlr_renderer_begin_buffer_pass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_render_pass *wlr_renderer_begin_buffer_pass(struct wlr_renderer *renderer, struct wlr_buffer *buffer, const struct wlr_buffer_pass_options *options)
     * }
     */
    public static MemorySegment wlr_renderer_begin_buffer_pass$address() {
        return wlr_renderer_begin_buffer_pass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_render_pass *wlr_renderer_begin_buffer_pass(struct wlr_renderer *renderer, struct wlr_buffer *buffer, const struct wlr_buffer_pass_options *options)
     * }
     */
    public static MemorySegment wlr_renderer_begin_buffer_pass(MemorySegment renderer, MemorySegment buffer, MemorySegment options) {
        var mh$ = wlr_renderer_begin_buffer_pass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_renderer_begin_buffer_pass", renderer, buffer, options);
            }
            return (MemorySegment)mh$.invokeExact(renderer, buffer, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_render_pass_submit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_render_pass_submit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_render_pass_submit(struct wlr_render_pass *render_pass)
     * }
     */
    public static FunctionDescriptor wlr_render_pass_submit$descriptor() {
        return wlr_render_pass_submit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_render_pass_submit(struct wlr_render_pass *render_pass)
     * }
     */
    public static MethodHandle wlr_render_pass_submit$handle() {
        return wlr_render_pass_submit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_render_pass_submit(struct wlr_render_pass *render_pass)
     * }
     */
    public static MemorySegment wlr_render_pass_submit$address() {
        return wlr_render_pass_submit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_render_pass_submit(struct wlr_render_pass *render_pass)
     * }
     */
    public static boolean wlr_render_pass_submit(MemorySegment render_pass) {
        var mh$ = wlr_render_pass_submit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_render_pass_submit", render_pass);
            }
            return (boolean)mh$.invokeExact(render_pass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int WLR_RENDER_BLEND_MODE_PREMULTIPLIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wlr_render_blend_mode.WLR_RENDER_BLEND_MODE_PREMULTIPLIED = 0
     * }
     */
    public static int WLR_RENDER_BLEND_MODE_PREMULTIPLIED() {
        return WLR_RENDER_BLEND_MODE_PREMULTIPLIED;
    }
    private static final int WLR_RENDER_BLEND_MODE_NONE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_render_blend_mode.WLR_RENDER_BLEND_MODE_NONE = 1
     * }
     */
    public static int WLR_RENDER_BLEND_MODE_NONE() {
        return WLR_RENDER_BLEND_MODE_NONE;
    }
    private static final int WLR_SCALE_FILTER_BILINEAR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wlr_scale_filter_mode.WLR_SCALE_FILTER_BILINEAR = 0
     * }
     */
    public static int WLR_SCALE_FILTER_BILINEAR() {
        return WLR_SCALE_FILTER_BILINEAR;
    }
    private static final int WLR_SCALE_FILTER_NEAREST = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_scale_filter_mode.WLR_SCALE_FILTER_NEAREST = 1
     * }
     */
    public static int WLR_SCALE_FILTER_NEAREST() {
        return WLR_SCALE_FILTER_NEAREST;
    }

    private static class wlr_render_pass_add_texture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_render_pass_add_texture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_render_pass_add_texture(struct wlr_render_pass *render_pass, const struct wlr_render_texture_options *options)
     * }
     */
    public static FunctionDescriptor wlr_render_pass_add_texture$descriptor() {
        return wlr_render_pass_add_texture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_render_pass_add_texture(struct wlr_render_pass *render_pass, const struct wlr_render_texture_options *options)
     * }
     */
    public static MethodHandle wlr_render_pass_add_texture$handle() {
        return wlr_render_pass_add_texture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_render_pass_add_texture(struct wlr_render_pass *render_pass, const struct wlr_render_texture_options *options)
     * }
     */
    public static MemorySegment wlr_render_pass_add_texture$address() {
        return wlr_render_pass_add_texture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_render_pass_add_texture(struct wlr_render_pass *render_pass, const struct wlr_render_texture_options *options)
     * }
     */
    public static void wlr_render_pass_add_texture(MemorySegment render_pass, MemorySegment options) {
        var mh$ = wlr_render_pass_add_texture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_render_pass_add_texture", render_pass, options);
            }
            mh$.invokeExact(render_pass, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_render_pass_add_rect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_render_pass_add_rect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_render_pass_add_rect(struct wlr_render_pass *render_pass, const struct wlr_render_rect_options *options)
     * }
     */
    public static FunctionDescriptor wlr_render_pass_add_rect$descriptor() {
        return wlr_render_pass_add_rect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_render_pass_add_rect(struct wlr_render_pass *render_pass, const struct wlr_render_rect_options *options)
     * }
     */
    public static MethodHandle wlr_render_pass_add_rect$handle() {
        return wlr_render_pass_add_rect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_render_pass_add_rect(struct wlr_render_pass *render_pass, const struct wlr_render_rect_options *options)
     * }
     */
    public static MemorySegment wlr_render_pass_add_rect$address() {
        return wlr_render_pass_add_rect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_render_pass_add_rect(struct wlr_render_pass *render_pass, const struct wlr_render_rect_options *options)
     * }
     */
    public static void wlr_render_pass_add_rect(MemorySegment render_pass, MemorySegment options) {
        var mh$ = wlr_render_pass_add_rect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_render_pass_add_rect", render_pass, options);
            }
            mh$.invokeExact(render_pass, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_dmabuf_attributes_finish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_dmabuf_attributes_finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_dmabuf_attributes_finish(struct wlr_dmabuf_attributes *attribs)
     * }
     */
    public static FunctionDescriptor wlr_dmabuf_attributes_finish$descriptor() {
        return wlr_dmabuf_attributes_finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_dmabuf_attributes_finish(struct wlr_dmabuf_attributes *attribs)
     * }
     */
    public static MethodHandle wlr_dmabuf_attributes_finish$handle() {
        return wlr_dmabuf_attributes_finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_dmabuf_attributes_finish(struct wlr_dmabuf_attributes *attribs)
     * }
     */
    public static MemorySegment wlr_dmabuf_attributes_finish$address() {
        return wlr_dmabuf_attributes_finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_dmabuf_attributes_finish(struct wlr_dmabuf_attributes *attribs)
     * }
     */
    public static void wlr_dmabuf_attributes_finish(MemorySegment attribs) {
        var mh$ = wlr_dmabuf_attributes_finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_dmabuf_attributes_finish", attribs);
            }
            mh$.invokeExact(attribs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_dmabuf_attributes_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_dmabuf_attributes_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_dmabuf_attributes_copy(struct wlr_dmabuf_attributes *dst, const struct wlr_dmabuf_attributes *src)
     * }
     */
    public static FunctionDescriptor wlr_dmabuf_attributes_copy$descriptor() {
        return wlr_dmabuf_attributes_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_dmabuf_attributes_copy(struct wlr_dmabuf_attributes *dst, const struct wlr_dmabuf_attributes *src)
     * }
     */
    public static MethodHandle wlr_dmabuf_attributes_copy$handle() {
        return wlr_dmabuf_attributes_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_dmabuf_attributes_copy(struct wlr_dmabuf_attributes *dst, const struct wlr_dmabuf_attributes *src)
     * }
     */
    public static MemorySegment wlr_dmabuf_attributes_copy$address() {
        return wlr_dmabuf_attributes_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_dmabuf_attributes_copy(struct wlr_dmabuf_attributes *dst, const struct wlr_dmabuf_attributes *src)
     * }
     */
    public static boolean wlr_dmabuf_attributes_copy(MemorySegment dst, MemorySegment src) {
        var mh$ = wlr_dmabuf_attributes_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_dmabuf_attributes_copy", dst, src);
            }
            return (boolean)mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_texture_from_pixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_texture_from_pixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_texture *wlr_texture_from_pixels(struct wlr_renderer *renderer, uint32_t fmt, uint32_t stride, uint32_t width, uint32_t height, const void *data)
     * }
     */
    public static FunctionDescriptor wlr_texture_from_pixels$descriptor() {
        return wlr_texture_from_pixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_texture *wlr_texture_from_pixels(struct wlr_renderer *renderer, uint32_t fmt, uint32_t stride, uint32_t width, uint32_t height, const void *data)
     * }
     */
    public static MethodHandle wlr_texture_from_pixels$handle() {
        return wlr_texture_from_pixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_texture *wlr_texture_from_pixels(struct wlr_renderer *renderer, uint32_t fmt, uint32_t stride, uint32_t width, uint32_t height, const void *data)
     * }
     */
    public static MemorySegment wlr_texture_from_pixels$address() {
        return wlr_texture_from_pixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_texture *wlr_texture_from_pixels(struct wlr_renderer *renderer, uint32_t fmt, uint32_t stride, uint32_t width, uint32_t height, const void *data)
     * }
     */
    public static MemorySegment wlr_texture_from_pixels(MemorySegment renderer, int fmt, int stride, int width, int height, MemorySegment data) {
        var mh$ = wlr_texture_from_pixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_texture_from_pixels", renderer, fmt, stride, width, height, data);
            }
            return (MemorySegment)mh$.invokeExact(renderer, fmt, stride, width, height, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_texture_from_dmabuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_texture_from_dmabuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_texture *wlr_texture_from_dmabuf(struct wlr_renderer *renderer, struct wlr_dmabuf_attributes *attribs)
     * }
     */
    public static FunctionDescriptor wlr_texture_from_dmabuf$descriptor() {
        return wlr_texture_from_dmabuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_texture *wlr_texture_from_dmabuf(struct wlr_renderer *renderer, struct wlr_dmabuf_attributes *attribs)
     * }
     */
    public static MethodHandle wlr_texture_from_dmabuf$handle() {
        return wlr_texture_from_dmabuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_texture *wlr_texture_from_dmabuf(struct wlr_renderer *renderer, struct wlr_dmabuf_attributes *attribs)
     * }
     */
    public static MemorySegment wlr_texture_from_dmabuf$address() {
        return wlr_texture_from_dmabuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_texture *wlr_texture_from_dmabuf(struct wlr_renderer *renderer, struct wlr_dmabuf_attributes *attribs)
     * }
     */
    public static MemorySegment wlr_texture_from_dmabuf(MemorySegment renderer, MemorySegment attribs) {
        var mh$ = wlr_texture_from_dmabuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_texture_from_dmabuf", renderer, attribs);
            }
            return (MemorySegment)mh$.invokeExact(renderer, attribs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_texture_update_from_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_texture_update_from_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_texture_update_from_buffer(struct wlr_texture *texture, struct wlr_buffer *buffer, const pixman_region32_t *damage)
     * }
     */
    public static FunctionDescriptor wlr_texture_update_from_buffer$descriptor() {
        return wlr_texture_update_from_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_texture_update_from_buffer(struct wlr_texture *texture, struct wlr_buffer *buffer, const pixman_region32_t *damage)
     * }
     */
    public static MethodHandle wlr_texture_update_from_buffer$handle() {
        return wlr_texture_update_from_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_texture_update_from_buffer(struct wlr_texture *texture, struct wlr_buffer *buffer, const pixman_region32_t *damage)
     * }
     */
    public static MemorySegment wlr_texture_update_from_buffer$address() {
        return wlr_texture_update_from_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_texture_update_from_buffer(struct wlr_texture *texture, struct wlr_buffer *buffer, const pixman_region32_t *damage)
     * }
     */
    public static boolean wlr_texture_update_from_buffer(MemorySegment texture, MemorySegment buffer, MemorySegment damage) {
        var mh$ = wlr_texture_update_from_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_texture_update_from_buffer", texture, buffer, damage);
            }
            return (boolean)mh$.invokeExact(texture, buffer, damage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_texture_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_texture_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_texture_destroy(struct wlr_texture *texture)
     * }
     */
    public static FunctionDescriptor wlr_texture_destroy$descriptor() {
        return wlr_texture_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_texture_destroy(struct wlr_texture *texture)
     * }
     */
    public static MethodHandle wlr_texture_destroy$handle() {
        return wlr_texture_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_texture_destroy(struct wlr_texture *texture)
     * }
     */
    public static MemorySegment wlr_texture_destroy$address() {
        return wlr_texture_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_texture_destroy(struct wlr_texture *texture)
     * }
     */
    public static void wlr_texture_destroy(MemorySegment texture) {
        var mh$ = wlr_texture_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_texture_destroy", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_texture_from_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_texture_from_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_texture *wlr_texture_from_buffer(struct wlr_renderer *renderer, struct wlr_buffer *buffer)
     * }
     */
    public static FunctionDescriptor wlr_texture_from_buffer$descriptor() {
        return wlr_texture_from_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_texture *wlr_texture_from_buffer(struct wlr_renderer *renderer, struct wlr_buffer *buffer)
     * }
     */
    public static MethodHandle wlr_texture_from_buffer$handle() {
        return wlr_texture_from_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_texture *wlr_texture_from_buffer(struct wlr_renderer *renderer, struct wlr_buffer *buffer)
     * }
     */
    public static MemorySegment wlr_texture_from_buffer$address() {
        return wlr_texture_from_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_texture *wlr_texture_from_buffer(struct wlr_renderer *renderer, struct wlr_buffer *buffer)
     * }
     */
    public static MemorySegment wlr_texture_from_buffer(MemorySegment renderer, MemorySegment buffer) {
        var mh$ = wlr_texture_from_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_texture_from_buffer", renderer, buffer);
            }
            return (MemorySegment)mh$.invokeExact(renderer, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_renderer_autocreate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_renderer_autocreate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_renderer *wlr_renderer_autocreate(struct wlr_backend *backend)
     * }
     */
    public static FunctionDescriptor wlr_renderer_autocreate$descriptor() {
        return wlr_renderer_autocreate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_renderer *wlr_renderer_autocreate(struct wlr_backend *backend)
     * }
     */
    public static MethodHandle wlr_renderer_autocreate$handle() {
        return wlr_renderer_autocreate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_renderer *wlr_renderer_autocreate(struct wlr_backend *backend)
     * }
     */
    public static MemorySegment wlr_renderer_autocreate$address() {
        return wlr_renderer_autocreate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_renderer *wlr_renderer_autocreate(struct wlr_backend *backend)
     * }
     */
    public static MemorySegment wlr_renderer_autocreate(MemorySegment backend) {
        var mh$ = wlr_renderer_autocreate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_renderer_autocreate", backend);
            }
            return (MemorySegment)mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_renderer_begin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_renderer_begin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_renderer_begin(struct wlr_renderer *r, uint32_t width, uint32_t height)
     * }
     */
    public static FunctionDescriptor wlr_renderer_begin$descriptor() {
        return wlr_renderer_begin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_renderer_begin(struct wlr_renderer *r, uint32_t width, uint32_t height)
     * }
     */
    public static MethodHandle wlr_renderer_begin$handle() {
        return wlr_renderer_begin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_renderer_begin(struct wlr_renderer *r, uint32_t width, uint32_t height)
     * }
     */
    public static MemorySegment wlr_renderer_begin$address() {
        return wlr_renderer_begin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_renderer_begin(struct wlr_renderer *r, uint32_t width, uint32_t height)
     * }
     */
    public static boolean wlr_renderer_begin(MemorySegment r, int width, int height) {
        var mh$ = wlr_renderer_begin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_renderer_begin", r, width, height);
            }
            return (boolean)mh$.invokeExact(r, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_renderer_begin_with_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_renderer_begin_with_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_renderer_begin_with_buffer(struct wlr_renderer *r, struct wlr_buffer *buffer)
     * }
     */
    public static FunctionDescriptor wlr_renderer_begin_with_buffer$descriptor() {
        return wlr_renderer_begin_with_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_renderer_begin_with_buffer(struct wlr_renderer *r, struct wlr_buffer *buffer)
     * }
     */
    public static MethodHandle wlr_renderer_begin_with_buffer$handle() {
        return wlr_renderer_begin_with_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_renderer_begin_with_buffer(struct wlr_renderer *r, struct wlr_buffer *buffer)
     * }
     */
    public static MemorySegment wlr_renderer_begin_with_buffer$address() {
        return wlr_renderer_begin_with_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_renderer_begin_with_buffer(struct wlr_renderer *r, struct wlr_buffer *buffer)
     * }
     */
    public static boolean wlr_renderer_begin_with_buffer(MemorySegment r, MemorySegment buffer) {
        var mh$ = wlr_renderer_begin_with_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_renderer_begin_with_buffer", r, buffer);
            }
            return (boolean)mh$.invokeExact(r, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_renderer_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_renderer_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_renderer_end(struct wlr_renderer *r)
     * }
     */
    public static FunctionDescriptor wlr_renderer_end$descriptor() {
        return wlr_renderer_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_renderer_end(struct wlr_renderer *r)
     * }
     */
    public static MethodHandle wlr_renderer_end$handle() {
        return wlr_renderer_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_renderer_end(struct wlr_renderer *r)
     * }
     */
    public static MemorySegment wlr_renderer_end$address() {
        return wlr_renderer_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_renderer_end(struct wlr_renderer *r)
     * }
     */
    public static void wlr_renderer_end(MemorySegment r) {
        var mh$ = wlr_renderer_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_renderer_end", r);
            }
            mh$.invokeExact(r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_renderer_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_renderer_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_renderer_clear(struct wlr_renderer *r, const float color[static 4])
     * }
     */
    public static FunctionDescriptor wlr_renderer_clear$descriptor() {
        return wlr_renderer_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_renderer_clear(struct wlr_renderer *r, const float color[static 4])
     * }
     */
    public static MethodHandle wlr_renderer_clear$handle() {
        return wlr_renderer_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_renderer_clear(struct wlr_renderer *r, const float color[static 4])
     * }
     */
    public static MemorySegment wlr_renderer_clear$address() {
        return wlr_renderer_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_renderer_clear(struct wlr_renderer *r, const float color[static 4])
     * }
     */
    public static void wlr_renderer_clear(MemorySegment r, MemorySegment color) {
        var mh$ = wlr_renderer_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_renderer_clear", r, color);
            }
            mh$.invokeExact(r, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_renderer_scissor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_renderer_scissor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_renderer_scissor(struct wlr_renderer *r, struct wlr_box *box)
     * }
     */
    public static FunctionDescriptor wlr_renderer_scissor$descriptor() {
        return wlr_renderer_scissor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_renderer_scissor(struct wlr_renderer *r, struct wlr_box *box)
     * }
     */
    public static MethodHandle wlr_renderer_scissor$handle() {
        return wlr_renderer_scissor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_renderer_scissor(struct wlr_renderer *r, struct wlr_box *box)
     * }
     */
    public static MemorySegment wlr_renderer_scissor$address() {
        return wlr_renderer_scissor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_renderer_scissor(struct wlr_renderer *r, struct wlr_box *box)
     * }
     */
    public static void wlr_renderer_scissor(MemorySegment r, MemorySegment box) {
        var mh$ = wlr_renderer_scissor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_renderer_scissor", r, box);
            }
            mh$.invokeExact(r, box);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_render_texture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_render_texture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_render_texture(struct wlr_renderer *r, struct wlr_texture *texture, const float projection[static 9], int x, int y, float alpha)
     * }
     */
    public static FunctionDescriptor wlr_render_texture$descriptor() {
        return wlr_render_texture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_render_texture(struct wlr_renderer *r, struct wlr_texture *texture, const float projection[static 9], int x, int y, float alpha)
     * }
     */
    public static MethodHandle wlr_render_texture$handle() {
        return wlr_render_texture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_render_texture(struct wlr_renderer *r, struct wlr_texture *texture, const float projection[static 9], int x, int y, float alpha)
     * }
     */
    public static MemorySegment wlr_render_texture$address() {
        return wlr_render_texture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_render_texture(struct wlr_renderer *r, struct wlr_texture *texture, const float projection[static 9], int x, int y, float alpha)
     * }
     */
    public static boolean wlr_render_texture(MemorySegment r, MemorySegment texture, MemorySegment projection, int x, int y, float alpha) {
        var mh$ = wlr_render_texture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_render_texture", r, texture, projection, x, y, alpha);
            }
            return (boolean)mh$.invokeExact(r, texture, projection, x, y, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_render_texture_with_matrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_render_texture_with_matrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_render_texture_with_matrix(struct wlr_renderer *r, struct wlr_texture *texture, const float matrix[static 9], float alpha)
     * }
     */
    public static FunctionDescriptor wlr_render_texture_with_matrix$descriptor() {
        return wlr_render_texture_with_matrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_render_texture_with_matrix(struct wlr_renderer *r, struct wlr_texture *texture, const float matrix[static 9], float alpha)
     * }
     */
    public static MethodHandle wlr_render_texture_with_matrix$handle() {
        return wlr_render_texture_with_matrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_render_texture_with_matrix(struct wlr_renderer *r, struct wlr_texture *texture, const float matrix[static 9], float alpha)
     * }
     */
    public static MemorySegment wlr_render_texture_with_matrix$address() {
        return wlr_render_texture_with_matrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_render_texture_with_matrix(struct wlr_renderer *r, struct wlr_texture *texture, const float matrix[static 9], float alpha)
     * }
     */
    public static boolean wlr_render_texture_with_matrix(MemorySegment r, MemorySegment texture, MemorySegment matrix, float alpha) {
        var mh$ = wlr_render_texture_with_matrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_render_texture_with_matrix", r, texture, matrix, alpha);
            }
            return (boolean)mh$.invokeExact(r, texture, matrix, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_render_subtexture_with_matrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_render_subtexture_with_matrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_render_subtexture_with_matrix(struct wlr_renderer *r, struct wlr_texture *texture, const struct wlr_fbox *box, const float matrix[static 9], float alpha)
     * }
     */
    public static FunctionDescriptor wlr_render_subtexture_with_matrix$descriptor() {
        return wlr_render_subtexture_with_matrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_render_subtexture_with_matrix(struct wlr_renderer *r, struct wlr_texture *texture, const struct wlr_fbox *box, const float matrix[static 9], float alpha)
     * }
     */
    public static MethodHandle wlr_render_subtexture_with_matrix$handle() {
        return wlr_render_subtexture_with_matrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_render_subtexture_with_matrix(struct wlr_renderer *r, struct wlr_texture *texture, const struct wlr_fbox *box, const float matrix[static 9], float alpha)
     * }
     */
    public static MemorySegment wlr_render_subtexture_with_matrix$address() {
        return wlr_render_subtexture_with_matrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_render_subtexture_with_matrix(struct wlr_renderer *r, struct wlr_texture *texture, const struct wlr_fbox *box, const float matrix[static 9], float alpha)
     * }
     */
    public static boolean wlr_render_subtexture_with_matrix(MemorySegment r, MemorySegment texture, MemorySegment box, MemorySegment matrix, float alpha) {
        var mh$ = wlr_render_subtexture_with_matrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_render_subtexture_with_matrix", r, texture, box, matrix, alpha);
            }
            return (boolean)mh$.invokeExact(r, texture, box, matrix, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_render_rect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_render_rect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_render_rect(struct wlr_renderer *r, const struct wlr_box *box, const float color[static 4], const float projection[static 9])
     * }
     */
    public static FunctionDescriptor wlr_render_rect$descriptor() {
        return wlr_render_rect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_render_rect(struct wlr_renderer *r, const struct wlr_box *box, const float color[static 4], const float projection[static 9])
     * }
     */
    public static MethodHandle wlr_render_rect$handle() {
        return wlr_render_rect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_render_rect(struct wlr_renderer *r, const struct wlr_box *box, const float color[static 4], const float projection[static 9])
     * }
     */
    public static MemorySegment wlr_render_rect$address() {
        return wlr_render_rect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_render_rect(struct wlr_renderer *r, const struct wlr_box *box, const float color[static 4], const float projection[static 9])
     * }
     */
    public static void wlr_render_rect(MemorySegment r, MemorySegment box, MemorySegment color, MemorySegment projection) {
        var mh$ = wlr_render_rect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_render_rect", r, box, color, projection);
            }
            mh$.invokeExact(r, box, color, projection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_render_quad_with_matrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_render_quad_with_matrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_render_quad_with_matrix(struct wlr_renderer *r, const float color[static 4], const float matrix[static 9])
     * }
     */
    public static FunctionDescriptor wlr_render_quad_with_matrix$descriptor() {
        return wlr_render_quad_with_matrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_render_quad_with_matrix(struct wlr_renderer *r, const float color[static 4], const float matrix[static 9])
     * }
     */
    public static MethodHandle wlr_render_quad_with_matrix$handle() {
        return wlr_render_quad_with_matrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_render_quad_with_matrix(struct wlr_renderer *r, const float color[static 4], const float matrix[static 9])
     * }
     */
    public static MemorySegment wlr_render_quad_with_matrix$address() {
        return wlr_render_quad_with_matrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_render_quad_with_matrix(struct wlr_renderer *r, const float color[static 4], const float matrix[static 9])
     * }
     */
    public static void wlr_render_quad_with_matrix(MemorySegment r, MemorySegment color, MemorySegment matrix) {
        var mh$ = wlr_render_quad_with_matrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_render_quad_with_matrix", r, color, matrix);
            }
            mh$.invokeExact(r, color, matrix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_renderer_get_shm_texture_formats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_renderer_get_shm_texture_formats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const uint32_t *wlr_renderer_get_shm_texture_formats(struct wlr_renderer *r, size_t *len)
     * }
     */
    public static FunctionDescriptor wlr_renderer_get_shm_texture_formats$descriptor() {
        return wlr_renderer_get_shm_texture_formats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const uint32_t *wlr_renderer_get_shm_texture_formats(struct wlr_renderer *r, size_t *len)
     * }
     */
    public static MethodHandle wlr_renderer_get_shm_texture_formats$handle() {
        return wlr_renderer_get_shm_texture_formats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const uint32_t *wlr_renderer_get_shm_texture_formats(struct wlr_renderer *r, size_t *len)
     * }
     */
    public static MemorySegment wlr_renderer_get_shm_texture_formats$address() {
        return wlr_renderer_get_shm_texture_formats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const uint32_t *wlr_renderer_get_shm_texture_formats(struct wlr_renderer *r, size_t *len)
     * }
     */
    public static MemorySegment wlr_renderer_get_shm_texture_formats(MemorySegment r, MemorySegment len) {
        var mh$ = wlr_renderer_get_shm_texture_formats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_renderer_get_shm_texture_formats", r, len);
            }
            return (MemorySegment)mh$.invokeExact(r, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_renderer_get_dmabuf_texture_formats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_renderer_get_dmabuf_texture_formats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const struct wlr_drm_format_set *wlr_renderer_get_dmabuf_texture_formats(struct wlr_renderer *renderer)
     * }
     */
    public static FunctionDescriptor wlr_renderer_get_dmabuf_texture_formats$descriptor() {
        return wlr_renderer_get_dmabuf_texture_formats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const struct wlr_drm_format_set *wlr_renderer_get_dmabuf_texture_formats(struct wlr_renderer *renderer)
     * }
     */
    public static MethodHandle wlr_renderer_get_dmabuf_texture_formats$handle() {
        return wlr_renderer_get_dmabuf_texture_formats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const struct wlr_drm_format_set *wlr_renderer_get_dmabuf_texture_formats(struct wlr_renderer *renderer)
     * }
     */
    public static MemorySegment wlr_renderer_get_dmabuf_texture_formats$address() {
        return wlr_renderer_get_dmabuf_texture_formats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const struct wlr_drm_format_set *wlr_renderer_get_dmabuf_texture_formats(struct wlr_renderer *renderer)
     * }
     */
    public static MemorySegment wlr_renderer_get_dmabuf_texture_formats(MemorySegment renderer) {
        var mh$ = wlr_renderer_get_dmabuf_texture_formats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_renderer_get_dmabuf_texture_formats", renderer);
            }
            return (MemorySegment)mh$.invokeExact(renderer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_renderer_read_pixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_renderer_read_pixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_renderer_read_pixels(struct wlr_renderer *r, uint32_t fmt, uint32_t stride, uint32_t width, uint32_t height, uint32_t src_x, uint32_t src_y, uint32_t dst_x, uint32_t dst_y, void *data)
     * }
     */
    public static FunctionDescriptor wlr_renderer_read_pixels$descriptor() {
        return wlr_renderer_read_pixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_renderer_read_pixels(struct wlr_renderer *r, uint32_t fmt, uint32_t stride, uint32_t width, uint32_t height, uint32_t src_x, uint32_t src_y, uint32_t dst_x, uint32_t dst_y, void *data)
     * }
     */
    public static MethodHandle wlr_renderer_read_pixels$handle() {
        return wlr_renderer_read_pixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_renderer_read_pixels(struct wlr_renderer *r, uint32_t fmt, uint32_t stride, uint32_t width, uint32_t height, uint32_t src_x, uint32_t src_y, uint32_t dst_x, uint32_t dst_y, void *data)
     * }
     */
    public static MemorySegment wlr_renderer_read_pixels$address() {
        return wlr_renderer_read_pixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_renderer_read_pixels(struct wlr_renderer *r, uint32_t fmt, uint32_t stride, uint32_t width, uint32_t height, uint32_t src_x, uint32_t src_y, uint32_t dst_x, uint32_t dst_y, void *data)
     * }
     */
    public static boolean wlr_renderer_read_pixels(MemorySegment r, int fmt, int stride, int width, int height, int src_x, int src_y, int dst_x, int dst_y, MemorySegment data) {
        var mh$ = wlr_renderer_read_pixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_renderer_read_pixels", r, fmt, stride, width, height, src_x, src_y, dst_x, dst_y, data);
            }
            return (boolean)mh$.invokeExact(r, fmt, stride, width, height, src_x, src_y, dst_x, dst_y, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_renderer_init_wl_display {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_renderer_init_wl_display");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_renderer_init_wl_display(struct wlr_renderer *r, struct wl_display *wl_display)
     * }
     */
    public static FunctionDescriptor wlr_renderer_init_wl_display$descriptor() {
        return wlr_renderer_init_wl_display.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_renderer_init_wl_display(struct wlr_renderer *r, struct wl_display *wl_display)
     * }
     */
    public static MethodHandle wlr_renderer_init_wl_display$handle() {
        return wlr_renderer_init_wl_display.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_renderer_init_wl_display(struct wlr_renderer *r, struct wl_display *wl_display)
     * }
     */
    public static MemorySegment wlr_renderer_init_wl_display$address() {
        return wlr_renderer_init_wl_display.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_renderer_init_wl_display(struct wlr_renderer *r, struct wl_display *wl_display)
     * }
     */
    public static boolean wlr_renderer_init_wl_display(MemorySegment r, MemorySegment wl_display) {
        var mh$ = wlr_renderer_init_wl_display.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_renderer_init_wl_display", r, wl_display);
            }
            return (boolean)mh$.invokeExact(r, wl_display);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_renderer_init_wl_shm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_renderer_init_wl_shm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_renderer_init_wl_shm(struct wlr_renderer *r, struct wl_display *wl_display)
     * }
     */
    public static FunctionDescriptor wlr_renderer_init_wl_shm$descriptor() {
        return wlr_renderer_init_wl_shm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_renderer_init_wl_shm(struct wlr_renderer *r, struct wl_display *wl_display)
     * }
     */
    public static MethodHandle wlr_renderer_init_wl_shm$handle() {
        return wlr_renderer_init_wl_shm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_renderer_init_wl_shm(struct wlr_renderer *r, struct wl_display *wl_display)
     * }
     */
    public static MemorySegment wlr_renderer_init_wl_shm$address() {
        return wlr_renderer_init_wl_shm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_renderer_init_wl_shm(struct wlr_renderer *r, struct wl_display *wl_display)
     * }
     */
    public static boolean wlr_renderer_init_wl_shm(MemorySegment r, MemorySegment wl_display) {
        var mh$ = wlr_renderer_init_wl_shm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_renderer_init_wl_shm", r, wl_display);
            }
            return (boolean)mh$.invokeExact(r, wl_display);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_renderer_get_drm_fd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_renderer_get_drm_fd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wlr_renderer_get_drm_fd(struct wlr_renderer *r)
     * }
     */
    public static FunctionDescriptor wlr_renderer_get_drm_fd$descriptor() {
        return wlr_renderer_get_drm_fd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wlr_renderer_get_drm_fd(struct wlr_renderer *r)
     * }
     */
    public static MethodHandle wlr_renderer_get_drm_fd$handle() {
        return wlr_renderer_get_drm_fd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wlr_renderer_get_drm_fd(struct wlr_renderer *r)
     * }
     */
    public static MemorySegment wlr_renderer_get_drm_fd$address() {
        return wlr_renderer_get_drm_fd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wlr_renderer_get_drm_fd(struct wlr_renderer *r)
     * }
     */
    public static int wlr_renderer_get_drm_fd(MemorySegment r) {
        var mh$ = wlr_renderer_get_drm_fd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_renderer_get_drm_fd", r);
            }
            return (int)mh$.invokeExact(r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_renderer_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_renderer_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_renderer_destroy(struct wlr_renderer *renderer)
     * }
     */
    public static FunctionDescriptor wlr_renderer_destroy$descriptor() {
        return wlr_renderer_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_renderer_destroy(struct wlr_renderer *renderer)
     * }
     */
    public static MethodHandle wlr_renderer_destroy$handle() {
        return wlr_renderer_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_renderer_destroy(struct wlr_renderer *renderer)
     * }
     */
    public static MemorySegment wlr_renderer_destroy$address() {
        return wlr_renderer_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_renderer_destroy(struct wlr_renderer *renderer)
     * }
     */
    public static void wlr_renderer_destroy(MemorySegment renderer) {
        var mh$ = wlr_renderer_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_renderer_destroy", renderer);
            }
            mh$.invokeExact(renderer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_render_timer_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_render_timer_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_render_timer *wlr_render_timer_create(struct wlr_renderer *renderer)
     * }
     */
    public static FunctionDescriptor wlr_render_timer_create$descriptor() {
        return wlr_render_timer_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_render_timer *wlr_render_timer_create(struct wlr_renderer *renderer)
     * }
     */
    public static MethodHandle wlr_render_timer_create$handle() {
        return wlr_render_timer_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_render_timer *wlr_render_timer_create(struct wlr_renderer *renderer)
     * }
     */
    public static MemorySegment wlr_render_timer_create$address() {
        return wlr_render_timer_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_render_timer *wlr_render_timer_create(struct wlr_renderer *renderer)
     * }
     */
    public static MemorySegment wlr_render_timer_create(MemorySegment renderer) {
        var mh$ = wlr_render_timer_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_render_timer_create", renderer);
            }
            return (MemorySegment)mh$.invokeExact(renderer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_render_timer_get_duration_ns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_render_timer_get_duration_ns");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wlr_render_timer_get_duration_ns(struct wlr_render_timer *timer)
     * }
     */
    public static FunctionDescriptor wlr_render_timer_get_duration_ns$descriptor() {
        return wlr_render_timer_get_duration_ns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wlr_render_timer_get_duration_ns(struct wlr_render_timer *timer)
     * }
     */
    public static MethodHandle wlr_render_timer_get_duration_ns$handle() {
        return wlr_render_timer_get_duration_ns.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wlr_render_timer_get_duration_ns(struct wlr_render_timer *timer)
     * }
     */
    public static MemorySegment wlr_render_timer_get_duration_ns$address() {
        return wlr_render_timer_get_duration_ns.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wlr_render_timer_get_duration_ns(struct wlr_render_timer *timer)
     * }
     */
    public static int wlr_render_timer_get_duration_ns(MemorySegment timer) {
        var mh$ = wlr_render_timer_get_duration_ns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_render_timer_get_duration_ns", timer);
            }
            return (int)mh$.invokeExact(timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_render_timer_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_render_timer_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_render_timer_destroy(struct wlr_render_timer *timer)
     * }
     */
    public static FunctionDescriptor wlr_render_timer_destroy$descriptor() {
        return wlr_render_timer_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_render_timer_destroy(struct wlr_render_timer *timer)
     * }
     */
    public static MethodHandle wlr_render_timer_destroy$handle() {
        return wlr_render_timer_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_render_timer_destroy(struct wlr_render_timer *timer)
     * }
     */
    public static MemorySegment wlr_render_timer_destroy$address() {
        return wlr_render_timer_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_render_timer_destroy(struct wlr_render_timer *timer)
     * }
     */
    public static void wlr_render_timer_destroy(MemorySegment timer) {
        var mh$ = wlr_render_timer_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_render_timer_destroy", timer);
            }
            mh$.invokeExact(timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct __locale_struct {
     *     struct __locale_data *__locales[13];
     *     const unsigned short *__ctype_b;
     *     const int *__ctype_tolower;
     *     const int *__ctype_toupper;
     *     const char *__names[13];
     * } *__locale_t
     * }
     */
    public static final AddressLayout __locale_t = C.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __locale_t locale_t
     * }
     */
    public static final AddressLayout locale_t = C.C_POINTER;

    private static class clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG    );

        public static final MemorySegment ADDR = C.findOrThrow("clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static FunctionDescriptor clock$descriptor() {
        return clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static MethodHandle clock$handle() {
        return clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static MemorySegment clock$address() {
        return clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static long clock() {
        var mh$ = clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static FunctionDescriptor time$descriptor() {
        return time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static MethodHandle time$handle() {
        return time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static MemorySegment time$address() {
        return time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static long time(MemorySegment __timer) {
        var mh$ = time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time", __timer);
            }
            return (long)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class difftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_LONG,
            C.C_LONG
        );

        public static final MemorySegment ADDR = C.findOrThrow("difftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static FunctionDescriptor difftime$descriptor() {
        return difftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static MethodHandle difftime$handle() {
        return difftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static MemorySegment difftime$address() {
        return difftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static double difftime(long __time1, long __time0) {
        var mh$ = difftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("difftime", __time1, __time0);
            }
            return (double)mh$.invokeExact(__time1, __time0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("mktime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor mktime$descriptor() {
        return mktime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static MethodHandle mktime$handle() {
        return mktime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static MemorySegment mktime$address() {
        return mktime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static long mktime(MemorySegment __tp) {
        var mh$ = mktime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktime", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER,
            C.C_LONG,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("strftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor strftime$descriptor() {
        return strftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static MethodHandle strftime$handle() {
        return strftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static MemorySegment strftime$address() {
        return strftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static long strftime(MemorySegment __s, long __maxsize, MemorySegment __format, MemorySegment __tp) {
        var mh$ = strftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime", __s, __maxsize, __format, __tp);
            }
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER,
            C.C_LONG,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("strftime_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strftime_l$descriptor() {
        return strftime_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static MethodHandle strftime_l$handle() {
        return strftime_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static MemorySegment strftime_l$address() {
        return strftime_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static long strftime_l(MemorySegment __s, long __maxsize, MemorySegment __format, MemorySegment __tp, MemorySegment __loc) {
        var mh$ = strftime_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime_l", __s, __maxsize, __format, __tp, __loc);
            }
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp, __loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("gmtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor gmtime$descriptor() {
        return gmtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MethodHandle gmtime$handle() {
        return gmtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MemorySegment gmtime$address() {
        return gmtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MemorySegment gmtime(MemorySegment __timer) {
        var mh$ = gmtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("localtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor localtime$descriptor() {
        return localtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MethodHandle localtime$handle() {
        return localtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MemorySegment localtime$address() {
        return localtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MemorySegment localtime(MemorySegment __timer) {
        var mh$ = localtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("gmtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor gmtime_r$descriptor() {
        return gmtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MethodHandle gmtime_r$handle() {
        return gmtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment gmtime_r$address() {
        return gmtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment gmtime_r(MemorySegment __timer, MemorySegment __tp) {
        var mh$ = gmtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime_r", __timer, __tp);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("localtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor localtime_r$descriptor() {
        return localtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MethodHandle localtime_r$handle() {
        return localtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment localtime_r$address() {
        return localtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment localtime_r(MemorySegment __timer, MemorySegment __tp) {
        var mh$ = localtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime_r", __timer, __tp);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("asctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static FunctionDescriptor asctime$descriptor() {
        return asctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MethodHandle asctime$handle() {
        return asctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MemorySegment asctime$address() {
        return asctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MemorySegment asctime(MemorySegment __tp) {
        var mh$ = asctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime", __tp);
            }
            return (MemorySegment)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("ctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor ctime$descriptor() {
        return ctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MethodHandle ctime$handle() {
        return ctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MemorySegment ctime$address() {
        return ctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MemorySegment ctime(MemorySegment __timer) {
        var mh$ = ctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("asctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor asctime_r$descriptor() {
        return asctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MethodHandle asctime_r$handle() {
        return asctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MemorySegment asctime_r$address() {
        return asctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MemorySegment asctime_r(MemorySegment __tp, MemorySegment __buf) {
        var mh$ = asctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime_r", __tp, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__tp, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("ctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor ctime_r$descriptor() {
        return ctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MethodHandle ctime_r$handle() {
        return ctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MemorySegment ctime_r$address() {
        return ctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MemorySegment ctime_r(MemorySegment __timer, MemorySegment __buf) {
        var mh$ = ctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime_r", __timer, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, C.C_POINTER);
        public static final MemorySegment SEGMENT = C.findOrThrow("__tzname").reinterpret(LAYOUT.byteSize());
    public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static SequenceLayout __tzname$layout() {
        return __tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static long[] __tzname$dimensions() {
        return __tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static MemorySegment __tzname() {
        return __tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static void __tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, __tzname$constants.SEGMENT, 0L, __tzname$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static MemorySegment __tzname(long index0) {
        return (MemorySegment)__tzname$constants.HANDLE.get(__tzname$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static void __tzname(long index0, MemorySegment varValue) {
        __tzname$constants.HANDLE.set(__tzname$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class __daylight$constants {
        public static final OfInt LAYOUT = C.C_INT;
        public static final MemorySegment SEGMENT = C.findOrThrow("__daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static OfInt __daylight$layout() {
        return __daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static MemorySegment __daylight$segment() {
        return __daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static int __daylight() {
        return __daylight$constants.SEGMENT.get(__daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static void __daylight(int varValue) {
        __daylight$constants.SEGMENT.set(__daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class __timezone$constants {
        public static final OfLong LAYOUT = C.C_LONG;
        public static final MemorySegment SEGMENT = C.findOrThrow("__timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static OfLong __timezone$layout() {
        return __timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static MemorySegment __timezone$segment() {
        return __timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static long __timezone() {
        return __timezone$constants.SEGMENT.get(__timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static void __timezone(long varValue) {
        __timezone$constants.SEGMENT.set(__timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, C.C_POINTER);
        public static final MemorySegment SEGMENT = C.findOrThrow("tzname").reinterpret(LAYOUT.byteSize());
    public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static SequenceLayout tzname$layout() {
        return tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static long[] tzname$dimensions() {
        return tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static MemorySegment tzname() {
        return tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static void tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, tzname$constants.SEGMENT, 0L, tzname$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static MemorySegment tzname(long index0) {
        return (MemorySegment)tzname$constants.HANDLE.get(tzname$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static void tzname(long index0, MemorySegment varValue) {
        tzname$constants.HANDLE.set(tzname$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = C.findOrThrow("tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static FunctionDescriptor tzset$descriptor() {
        return tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static MethodHandle tzset$handle() {
        return tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static MemorySegment tzset$address() {
        return tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static void tzset() {
        var mh$ = tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzset");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daylight$constants {
        public static final OfInt LAYOUT = C.C_INT;
        public static final MemorySegment SEGMENT = C.findOrThrow("daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static OfInt daylight$layout() {
        return daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static MemorySegment daylight$segment() {
        return daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static int daylight() {
        return daylight$constants.SEGMENT.get(daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static void daylight(int varValue) {
        daylight$constants.SEGMENT.set(daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class timezone$constants {
        public static final OfLong LAYOUT = C.C_LONG;
        public static final MemorySegment SEGMENT = C.findOrThrow("timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static OfLong timezone$layout() {
        return timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static MemorySegment timezone$segment() {
        return timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static long timezone() {
        return timezone$constants.SEGMENT.get(timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static void timezone(long varValue) {
        timezone$constants.SEGMENT.set(timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class timegm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("timegm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor timegm$descriptor() {
        return timegm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static MethodHandle timegm$handle() {
        return timegm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static MemorySegment timegm$address() {
        return timegm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static long timegm(MemorySegment __tp) {
        var mh$ = timegm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timegm", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timelocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("timelocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor timelocal$descriptor() {
        return timelocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static MethodHandle timelocal$handle() {
        return timelocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static MemorySegment timelocal$address() {
        return timelocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static long timelocal(MemorySegment __tp) {
        var mh$ = timelocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timelocal", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dysize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("dysize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static FunctionDescriptor dysize$descriptor() {
        return dysize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static MethodHandle dysize$handle() {
        return dysize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static MemorySegment dysize$address() {
        return dysize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static int dysize(int __year) {
        var mh$ = dysize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dysize", __year);
            }
            return (int)mh$.invokeExact(__year);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static FunctionDescriptor nanosleep$descriptor() {
        return nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static MethodHandle nanosleep$handle() {
        return nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static MemorySegment nanosleep$address() {
        return nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static int nanosleep(MemorySegment __requested_time, MemorySegment __remaining) {
        var mh$ = nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanosleep", __requested_time, __remaining);
            }
            return (int)mh$.invokeExact(__requested_time, __remaining);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_getres {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("clock_getres");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static FunctionDescriptor clock_getres$descriptor() {
        return clock_getres.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MethodHandle clock_getres$handle() {
        return clock_getres.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MemorySegment clock_getres$address() {
        return clock_getres.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static int clock_getres(int __clock_id, MemorySegment __res) {
        var mh$ = clock_getres.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getres", __clock_id, __res);
            }
            return (int)mh$.invokeExact(__clock_id, __res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("clock_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_gettime$descriptor() {
        return clock_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_gettime$handle() {
        return clock_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_gettime$address() {
        return clock_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static int clock_gettime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("clock_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_settime$descriptor() {
        return clock_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_settime$handle() {
        return clock_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_settime$address() {
        return clock_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static int clock_settime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_settime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("clock_nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static FunctionDescriptor clock_nanosleep$descriptor() {
        return clock_nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static MethodHandle clock_nanosleep$handle() {
        return clock_nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static MemorySegment clock_nanosleep$address() {
        return clock_nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static int clock_nanosleep(int __clock_id, int __flags, MemorySegment __req, MemorySegment __rem) {
        var mh$ = clock_nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_nanosleep", __clock_id, __flags, __req, __rem);
            }
            return (int)mh$.invokeExact(__clock_id, __flags, __req, __rem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_getcpuclockid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("clock_getcpuclockid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static FunctionDescriptor clock_getcpuclockid$descriptor() {
        return clock_getcpuclockid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static MethodHandle clock_getcpuclockid$handle() {
        return clock_getcpuclockid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static MemorySegment clock_getcpuclockid$address() {
        return clock_getcpuclockid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static int clock_getcpuclockid(int __pid, MemorySegment __clock_id) {
        var mh$ = clock_getcpuclockid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getcpuclockid", __pid, __clock_id);
            }
            return (int)mh$.invokeExact(__pid, __clock_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("timer_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static FunctionDescriptor timer_create$descriptor() {
        return timer_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static MethodHandle timer_create$handle() {
        return timer_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static MemorySegment timer_create$address() {
        return timer_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static int timer_create(int __clock_id, MemorySegment __evp, MemorySegment __timerid) {
        var mh$ = timer_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_create", __clock_id, __evp, __timerid);
            }
            return (int)mh$.invokeExact(__clock_id, __evp, __timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("timer_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static FunctionDescriptor timer_delete$descriptor() {
        return timer_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static MethodHandle timer_delete$handle() {
        return timer_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static MemorySegment timer_delete$address() {
        return timer_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static int timer_delete(MemorySegment __timerid) {
        var mh$ = timer_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_delete", __timerid);
            }
            return (int)mh$.invokeExact(__timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("timer_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static FunctionDescriptor timer_settime$descriptor() {
        return timer_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static MethodHandle timer_settime$handle() {
        return timer_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static MemorySegment timer_settime$address() {
        return timer_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static int timer_settime(MemorySegment __timerid, int __flags, MemorySegment __value, MemorySegment __ovalue) {
        var mh$ = timer_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_settime", __timerid, __flags, __value, __ovalue);
            }
            return (int)mh$.invokeExact(__timerid, __flags, __value, __ovalue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("timer_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static FunctionDescriptor timer_gettime$descriptor() {
        return timer_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static MethodHandle timer_gettime$handle() {
        return timer_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static MemorySegment timer_gettime$address() {
        return timer_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static int timer_gettime(MemorySegment __timerid, MemorySegment __value) {
        var mh$ = timer_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_gettime", __timerid, __value);
            }
            return (int)mh$.invokeExact(__timerid, __value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_getoverrun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("timer_getoverrun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static FunctionDescriptor timer_getoverrun$descriptor() {
        return timer_getoverrun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static MethodHandle timer_getoverrun$handle() {
        return timer_getoverrun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static MemorySegment timer_getoverrun$address() {
        return timer_getoverrun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static int timer_getoverrun(MemorySegment __timerid) {
        var mh$ = timer_getoverrun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_getoverrun", __timerid);
            }
            return (int)mh$.invokeExact(__timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timespec_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("timespec_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static FunctionDescriptor timespec_get$descriptor() {
        return timespec_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static MethodHandle timespec_get$handle() {
        return timespec_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static MemorySegment timespec_get$address() {
        return timespec_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static int timespec_get(MemorySegment __ts, int __base) {
        var mh$ = timespec_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timespec_get", __ts, __base);
            }
            return (int)mh$.invokeExact(__ts, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_addon_set_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_addon_set_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_addon_set_init(struct wlr_addon_set *set)
     * }
     */
    public static FunctionDescriptor wlr_addon_set_init$descriptor() {
        return wlr_addon_set_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_addon_set_init(struct wlr_addon_set *set)
     * }
     */
    public static MethodHandle wlr_addon_set_init$handle() {
        return wlr_addon_set_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_addon_set_init(struct wlr_addon_set *set)
     * }
     */
    public static MemorySegment wlr_addon_set_init$address() {
        return wlr_addon_set_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_addon_set_init(struct wlr_addon_set *set)
     * }
     */
    public static void wlr_addon_set_init(MemorySegment set) {
        var mh$ = wlr_addon_set_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_addon_set_init", set);
            }
            mh$.invokeExact(set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_addon_set_finish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_addon_set_finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_addon_set_finish(struct wlr_addon_set *set)
     * }
     */
    public static FunctionDescriptor wlr_addon_set_finish$descriptor() {
        return wlr_addon_set_finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_addon_set_finish(struct wlr_addon_set *set)
     * }
     */
    public static MethodHandle wlr_addon_set_finish$handle() {
        return wlr_addon_set_finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_addon_set_finish(struct wlr_addon_set *set)
     * }
     */
    public static MemorySegment wlr_addon_set_finish$address() {
        return wlr_addon_set_finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_addon_set_finish(struct wlr_addon_set *set)
     * }
     */
    public static void wlr_addon_set_finish(MemorySegment set) {
        var mh$ = wlr_addon_set_finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_addon_set_finish", set);
            }
            mh$.invokeExact(set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_addon_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_addon_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_addon_init(struct wlr_addon *addon, struct wlr_addon_set *set, const void *owner, const struct wlr_addon_interface *impl)
     * }
     */
    public static FunctionDescriptor wlr_addon_init$descriptor() {
        return wlr_addon_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_addon_init(struct wlr_addon *addon, struct wlr_addon_set *set, const void *owner, const struct wlr_addon_interface *impl)
     * }
     */
    public static MethodHandle wlr_addon_init$handle() {
        return wlr_addon_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_addon_init(struct wlr_addon *addon, struct wlr_addon_set *set, const void *owner, const struct wlr_addon_interface *impl)
     * }
     */
    public static MemorySegment wlr_addon_init$address() {
        return wlr_addon_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_addon_init(struct wlr_addon *addon, struct wlr_addon_set *set, const void *owner, const struct wlr_addon_interface *impl)
     * }
     */
    public static void wlr_addon_init(MemorySegment addon, MemorySegment set, MemorySegment owner, MemorySegment impl) {
        var mh$ = wlr_addon_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_addon_init", addon, set, owner, impl);
            }
            mh$.invokeExact(addon, set, owner, impl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_addon_finish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_addon_finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_addon_finish(struct wlr_addon *addon)
     * }
     */
    public static FunctionDescriptor wlr_addon_finish$descriptor() {
        return wlr_addon_finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_addon_finish(struct wlr_addon *addon)
     * }
     */
    public static MethodHandle wlr_addon_finish$handle() {
        return wlr_addon_finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_addon_finish(struct wlr_addon *addon)
     * }
     */
    public static MemorySegment wlr_addon_finish$address() {
        return wlr_addon_finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_addon_finish(struct wlr_addon *addon)
     * }
     */
    public static void wlr_addon_finish(MemorySegment addon) {
        var mh$ = wlr_addon_finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_addon_finish", addon);
            }
            mh$.invokeExact(addon);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_addon_find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_addon_find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_addon *wlr_addon_find(struct wlr_addon_set *set, const void *owner, const struct wlr_addon_interface *impl)
     * }
     */
    public static FunctionDescriptor wlr_addon_find$descriptor() {
        return wlr_addon_find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_addon *wlr_addon_find(struct wlr_addon_set *set, const void *owner, const struct wlr_addon_interface *impl)
     * }
     */
    public static MethodHandle wlr_addon_find$handle() {
        return wlr_addon_find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_addon *wlr_addon_find(struct wlr_addon_set *set, const void *owner, const struct wlr_addon_interface *impl)
     * }
     */
    public static MemorySegment wlr_addon_find$address() {
        return wlr_addon_find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_addon *wlr_addon_find(struct wlr_addon_set *set, const void *owner, const struct wlr_addon_interface *impl)
     * }
     */
    public static MemorySegment wlr_addon_find(MemorySegment set, MemorySegment owner, MemorySegment impl) {
        var mh$ = wlr_addon_find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_addon_find", set, owner, impl);
            }
            return (MemorySegment)mh$.invokeExact(set, owner, impl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int WLR_BUFFER_CAP_DATA_PTR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_buffer_cap.WLR_BUFFER_CAP_DATA_PTR = 1
     * }
     */
    public static int WLR_BUFFER_CAP_DATA_PTR() {
        return WLR_BUFFER_CAP_DATA_PTR;
    }
    private static final int WLR_BUFFER_CAP_DMABUF = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wlr_buffer_cap.WLR_BUFFER_CAP_DMABUF = 2
     * }
     */
    public static int WLR_BUFFER_CAP_DMABUF() {
        return WLR_BUFFER_CAP_DMABUF;
    }
    private static final int WLR_BUFFER_CAP_SHM = (int)4L;
    /**
     * {@snippet lang=c :
     * enum wlr_buffer_cap.WLR_BUFFER_CAP_SHM = 4
     * }
     */
    public static int WLR_BUFFER_CAP_SHM() {
        return WLR_BUFFER_CAP_SHM;
    }

    private static class wlr_buffer_drop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_buffer_drop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_buffer_drop(struct wlr_buffer *buffer)
     * }
     */
    public static FunctionDescriptor wlr_buffer_drop$descriptor() {
        return wlr_buffer_drop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_buffer_drop(struct wlr_buffer *buffer)
     * }
     */
    public static MethodHandle wlr_buffer_drop$handle() {
        return wlr_buffer_drop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_buffer_drop(struct wlr_buffer *buffer)
     * }
     */
    public static MemorySegment wlr_buffer_drop$address() {
        return wlr_buffer_drop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_buffer_drop(struct wlr_buffer *buffer)
     * }
     */
    public static void wlr_buffer_drop(MemorySegment buffer) {
        var mh$ = wlr_buffer_drop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_buffer_drop", buffer);
            }
            mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_buffer_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_buffer_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_buffer *wlr_buffer_lock(struct wlr_buffer *buffer)
     * }
     */
    public static FunctionDescriptor wlr_buffer_lock$descriptor() {
        return wlr_buffer_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_buffer *wlr_buffer_lock(struct wlr_buffer *buffer)
     * }
     */
    public static MethodHandle wlr_buffer_lock$handle() {
        return wlr_buffer_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_buffer *wlr_buffer_lock(struct wlr_buffer *buffer)
     * }
     */
    public static MemorySegment wlr_buffer_lock$address() {
        return wlr_buffer_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_buffer *wlr_buffer_lock(struct wlr_buffer *buffer)
     * }
     */
    public static MemorySegment wlr_buffer_lock(MemorySegment buffer) {
        var mh$ = wlr_buffer_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_buffer_lock", buffer);
            }
            return (MemorySegment)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_buffer_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_buffer_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_buffer_unlock(struct wlr_buffer *buffer)
     * }
     */
    public static FunctionDescriptor wlr_buffer_unlock$descriptor() {
        return wlr_buffer_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_buffer_unlock(struct wlr_buffer *buffer)
     * }
     */
    public static MethodHandle wlr_buffer_unlock$handle() {
        return wlr_buffer_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_buffer_unlock(struct wlr_buffer *buffer)
     * }
     */
    public static MemorySegment wlr_buffer_unlock$address() {
        return wlr_buffer_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_buffer_unlock(struct wlr_buffer *buffer)
     * }
     */
    public static void wlr_buffer_unlock(MemorySegment buffer) {
        var mh$ = wlr_buffer_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_buffer_unlock", buffer);
            }
            mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_buffer_get_dmabuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_buffer_get_dmabuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_buffer_get_dmabuf(struct wlr_buffer *buffer, struct wlr_dmabuf_attributes *attribs)
     * }
     */
    public static FunctionDescriptor wlr_buffer_get_dmabuf$descriptor() {
        return wlr_buffer_get_dmabuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_buffer_get_dmabuf(struct wlr_buffer *buffer, struct wlr_dmabuf_attributes *attribs)
     * }
     */
    public static MethodHandle wlr_buffer_get_dmabuf$handle() {
        return wlr_buffer_get_dmabuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_buffer_get_dmabuf(struct wlr_buffer *buffer, struct wlr_dmabuf_attributes *attribs)
     * }
     */
    public static MemorySegment wlr_buffer_get_dmabuf$address() {
        return wlr_buffer_get_dmabuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_buffer_get_dmabuf(struct wlr_buffer *buffer, struct wlr_dmabuf_attributes *attribs)
     * }
     */
    public static boolean wlr_buffer_get_dmabuf(MemorySegment buffer, MemorySegment attribs) {
        var mh$ = wlr_buffer_get_dmabuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_buffer_get_dmabuf", buffer, attribs);
            }
            return (boolean)mh$.invokeExact(buffer, attribs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_buffer_get_shm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_buffer_get_shm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_buffer_get_shm(struct wlr_buffer *buffer, struct wlr_shm_attributes *attribs)
     * }
     */
    public static FunctionDescriptor wlr_buffer_get_shm$descriptor() {
        return wlr_buffer_get_shm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_buffer_get_shm(struct wlr_buffer *buffer, struct wlr_shm_attributes *attribs)
     * }
     */
    public static MethodHandle wlr_buffer_get_shm$handle() {
        return wlr_buffer_get_shm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_buffer_get_shm(struct wlr_buffer *buffer, struct wlr_shm_attributes *attribs)
     * }
     */
    public static MemorySegment wlr_buffer_get_shm$address() {
        return wlr_buffer_get_shm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_buffer_get_shm(struct wlr_buffer *buffer, struct wlr_shm_attributes *attribs)
     * }
     */
    public static boolean wlr_buffer_get_shm(MemorySegment buffer, MemorySegment attribs) {
        var mh$ = wlr_buffer_get_shm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_buffer_get_shm", buffer, attribs);
            }
            return (boolean)mh$.invokeExact(buffer, attribs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_buffer_try_from_resource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_buffer_try_from_resource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_buffer *wlr_buffer_try_from_resource(struct wl_resource *resource)
     * }
     */
    public static FunctionDescriptor wlr_buffer_try_from_resource$descriptor() {
        return wlr_buffer_try_from_resource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_buffer *wlr_buffer_try_from_resource(struct wl_resource *resource)
     * }
     */
    public static MethodHandle wlr_buffer_try_from_resource$handle() {
        return wlr_buffer_try_from_resource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_buffer *wlr_buffer_try_from_resource(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wlr_buffer_try_from_resource$address() {
        return wlr_buffer_try_from_resource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_buffer *wlr_buffer_try_from_resource(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wlr_buffer_try_from_resource(MemorySegment resource) {
        var mh$ = wlr_buffer_try_from_resource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_buffer_try_from_resource", resource);
            }
            return (MemorySegment)mh$.invokeExact(resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int WLR_BUFFER_DATA_PTR_ACCESS_READ = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_buffer_data_ptr_access_flag.WLR_BUFFER_DATA_PTR_ACCESS_READ = 1
     * }
     */
    public static int WLR_BUFFER_DATA_PTR_ACCESS_READ() {
        return WLR_BUFFER_DATA_PTR_ACCESS_READ;
    }
    private static final int WLR_BUFFER_DATA_PTR_ACCESS_WRITE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wlr_buffer_data_ptr_access_flag.WLR_BUFFER_DATA_PTR_ACCESS_WRITE = 2
     * }
     */
    public static int WLR_BUFFER_DATA_PTR_ACCESS_WRITE() {
        return WLR_BUFFER_DATA_PTR_ACCESS_WRITE;
    }

    private static class wlr_buffer_begin_data_ptr_access {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_buffer_begin_data_ptr_access");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_buffer_begin_data_ptr_access(struct wlr_buffer *buffer, uint32_t flags, void **data, uint32_t *format, size_t *stride)
     * }
     */
    public static FunctionDescriptor wlr_buffer_begin_data_ptr_access$descriptor() {
        return wlr_buffer_begin_data_ptr_access.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_buffer_begin_data_ptr_access(struct wlr_buffer *buffer, uint32_t flags, void **data, uint32_t *format, size_t *stride)
     * }
     */
    public static MethodHandle wlr_buffer_begin_data_ptr_access$handle() {
        return wlr_buffer_begin_data_ptr_access.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_buffer_begin_data_ptr_access(struct wlr_buffer *buffer, uint32_t flags, void **data, uint32_t *format, size_t *stride)
     * }
     */
    public static MemorySegment wlr_buffer_begin_data_ptr_access$address() {
        return wlr_buffer_begin_data_ptr_access.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_buffer_begin_data_ptr_access(struct wlr_buffer *buffer, uint32_t flags, void **data, uint32_t *format, size_t *stride)
     * }
     */
    public static boolean wlr_buffer_begin_data_ptr_access(MemorySegment buffer, int flags, MemorySegment data, MemorySegment format, MemorySegment stride) {
        var mh$ = wlr_buffer_begin_data_ptr_access.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_buffer_begin_data_ptr_access", buffer, flags, data, format, stride);
            }
            return (boolean)mh$.invokeExact(buffer, flags, data, format, stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_buffer_end_data_ptr_access {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_buffer_end_data_ptr_access");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_buffer_end_data_ptr_access(struct wlr_buffer *buffer)
     * }
     */
    public static FunctionDescriptor wlr_buffer_end_data_ptr_access$descriptor() {
        return wlr_buffer_end_data_ptr_access.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_buffer_end_data_ptr_access(struct wlr_buffer *buffer)
     * }
     */
    public static MethodHandle wlr_buffer_end_data_ptr_access$handle() {
        return wlr_buffer_end_data_ptr_access.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_buffer_end_data_ptr_access(struct wlr_buffer *buffer)
     * }
     */
    public static MemorySegment wlr_buffer_end_data_ptr_access$address() {
        return wlr_buffer_end_data_ptr_access.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_buffer_end_data_ptr_access(struct wlr_buffer *buffer)
     * }
     */
    public static void wlr_buffer_end_data_ptr_access(MemorySegment buffer) {
        var mh$ = wlr_buffer_end_data_ptr_access.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_buffer_end_data_ptr_access", buffer);
            }
            mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_client_buffer_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_client_buffer_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_client_buffer *wlr_client_buffer_get(struct wlr_buffer *buffer)
     * }
     */
    public static FunctionDescriptor wlr_client_buffer_get$descriptor() {
        return wlr_client_buffer_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_client_buffer *wlr_client_buffer_get(struct wlr_buffer *buffer)
     * }
     */
    public static MethodHandle wlr_client_buffer_get$handle() {
        return wlr_client_buffer_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_client_buffer *wlr_client_buffer_get(struct wlr_buffer *buffer)
     * }
     */
    public static MemorySegment wlr_client_buffer_get$address() {
        return wlr_client_buffer_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_client_buffer *wlr_client_buffer_get(struct wlr_buffer *buffer)
     * }
     */
    public static MemorySegment wlr_client_buffer_get(MemorySegment buffer) {
        var mh$ = wlr_client_buffer_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_client_buffer_get", buffer);
            }
            return (MemorySegment)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int WLR_OUTPUT_MODE_ASPECT_RATIO_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_mode_aspect_ratio.WLR_OUTPUT_MODE_ASPECT_RATIO_NONE = 0
     * }
     */
    public static int WLR_OUTPUT_MODE_ASPECT_RATIO_NONE() {
        return WLR_OUTPUT_MODE_ASPECT_RATIO_NONE;
    }
    private static final int WLR_OUTPUT_MODE_ASPECT_RATIO_4_3 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_mode_aspect_ratio.WLR_OUTPUT_MODE_ASPECT_RATIO_4_3 = 1
     * }
     */
    public static int WLR_OUTPUT_MODE_ASPECT_RATIO_4_3() {
        return WLR_OUTPUT_MODE_ASPECT_RATIO_4_3;
    }
    private static final int WLR_OUTPUT_MODE_ASPECT_RATIO_16_9 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_mode_aspect_ratio.WLR_OUTPUT_MODE_ASPECT_RATIO_16_9 = 2
     * }
     */
    public static int WLR_OUTPUT_MODE_ASPECT_RATIO_16_9() {
        return WLR_OUTPUT_MODE_ASPECT_RATIO_16_9;
    }
    private static final int WLR_OUTPUT_MODE_ASPECT_RATIO_64_27 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_mode_aspect_ratio.WLR_OUTPUT_MODE_ASPECT_RATIO_64_27 = 3
     * }
     */
    public static int WLR_OUTPUT_MODE_ASPECT_RATIO_64_27() {
        return WLR_OUTPUT_MODE_ASPECT_RATIO_64_27;
    }
    private static final int WLR_OUTPUT_MODE_ASPECT_RATIO_256_135 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_mode_aspect_ratio.WLR_OUTPUT_MODE_ASPECT_RATIO_256_135 = 4
     * }
     */
    public static int WLR_OUTPUT_MODE_ASPECT_RATIO_256_135() {
        return WLR_OUTPUT_MODE_ASPECT_RATIO_256_135;
    }
    private static final int WLR_OUTPUT_ADAPTIVE_SYNC_DISABLED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_adaptive_sync_status.WLR_OUTPUT_ADAPTIVE_SYNC_DISABLED = 0
     * }
     */
    public static int WLR_OUTPUT_ADAPTIVE_SYNC_DISABLED() {
        return WLR_OUTPUT_ADAPTIVE_SYNC_DISABLED;
    }
    private static final int WLR_OUTPUT_ADAPTIVE_SYNC_ENABLED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_adaptive_sync_status.WLR_OUTPUT_ADAPTIVE_SYNC_ENABLED = 1
     * }
     */
    public static int WLR_OUTPUT_ADAPTIVE_SYNC_ENABLED() {
        return WLR_OUTPUT_ADAPTIVE_SYNC_ENABLED;
    }
    private static final int WLR_OUTPUT_STATE_BUFFER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_state_field.WLR_OUTPUT_STATE_BUFFER = 1
     * }
     */
    public static int WLR_OUTPUT_STATE_BUFFER() {
        return WLR_OUTPUT_STATE_BUFFER;
    }
    private static final int WLR_OUTPUT_STATE_DAMAGE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_state_field.WLR_OUTPUT_STATE_DAMAGE = 2
     * }
     */
    public static int WLR_OUTPUT_STATE_DAMAGE() {
        return WLR_OUTPUT_STATE_DAMAGE;
    }
    private static final int WLR_OUTPUT_STATE_MODE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_state_field.WLR_OUTPUT_STATE_MODE = 4
     * }
     */
    public static int WLR_OUTPUT_STATE_MODE() {
        return WLR_OUTPUT_STATE_MODE;
    }
    private static final int WLR_OUTPUT_STATE_ENABLED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_state_field.WLR_OUTPUT_STATE_ENABLED = 8
     * }
     */
    public static int WLR_OUTPUT_STATE_ENABLED() {
        return WLR_OUTPUT_STATE_ENABLED;
    }
    private static final int WLR_OUTPUT_STATE_SCALE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_state_field.WLR_OUTPUT_STATE_SCALE = 16
     * }
     */
    public static int WLR_OUTPUT_STATE_SCALE() {
        return WLR_OUTPUT_STATE_SCALE;
    }
    private static final int WLR_OUTPUT_STATE_TRANSFORM = (int)32L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_state_field.WLR_OUTPUT_STATE_TRANSFORM = 32
     * }
     */
    public static int WLR_OUTPUT_STATE_TRANSFORM() {
        return WLR_OUTPUT_STATE_TRANSFORM;
    }
    private static final int WLR_OUTPUT_STATE_ADAPTIVE_SYNC_ENABLED = (int)64L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_state_field.WLR_OUTPUT_STATE_ADAPTIVE_SYNC_ENABLED = 64
     * }
     */
    public static int WLR_OUTPUT_STATE_ADAPTIVE_SYNC_ENABLED() {
        return WLR_OUTPUT_STATE_ADAPTIVE_SYNC_ENABLED;
    }
    private static final int WLR_OUTPUT_STATE_GAMMA_LUT = (int)128L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_state_field.WLR_OUTPUT_STATE_GAMMA_LUT = 128
     * }
     */
    public static int WLR_OUTPUT_STATE_GAMMA_LUT() {
        return WLR_OUTPUT_STATE_GAMMA_LUT;
    }
    private static final int WLR_OUTPUT_STATE_RENDER_FORMAT = (int)256L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_state_field.WLR_OUTPUT_STATE_RENDER_FORMAT = 256
     * }
     */
    public static int WLR_OUTPUT_STATE_RENDER_FORMAT() {
        return WLR_OUTPUT_STATE_RENDER_FORMAT;
    }
    private static final int WLR_OUTPUT_STATE_SUBPIXEL = (int)512L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_state_field.WLR_OUTPUT_STATE_SUBPIXEL = 512
     * }
     */
    public static int WLR_OUTPUT_STATE_SUBPIXEL() {
        return WLR_OUTPUT_STATE_SUBPIXEL;
    }
    private static final int WLR_OUTPUT_STATE_LAYERS = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_state_field.WLR_OUTPUT_STATE_LAYERS = 1024
     * }
     */
    public static int WLR_OUTPUT_STATE_LAYERS() {
        return WLR_OUTPUT_STATE_LAYERS;
    }
    private static final int WLR_OUTPUT_STATE_MODE_FIXED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_state_mode_type.WLR_OUTPUT_STATE_MODE_FIXED = 0
     * }
     */
    public static int WLR_OUTPUT_STATE_MODE_FIXED() {
        return WLR_OUTPUT_STATE_MODE_FIXED;
    }
    private static final int WLR_OUTPUT_STATE_MODE_CUSTOM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_state_mode_type.WLR_OUTPUT_STATE_MODE_CUSTOM = 1
     * }
     */
    public static int WLR_OUTPUT_STATE_MODE_CUSTOM() {
        return WLR_OUTPUT_STATE_MODE_CUSTOM;
    }
    private static final int WLR_OUTPUT_PRESENT_VSYNC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_present_flag.WLR_OUTPUT_PRESENT_VSYNC = 1
     * }
     */
    public static int WLR_OUTPUT_PRESENT_VSYNC() {
        return WLR_OUTPUT_PRESENT_VSYNC;
    }
    private static final int WLR_OUTPUT_PRESENT_HW_CLOCK = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_present_flag.WLR_OUTPUT_PRESENT_HW_CLOCK = 2
     * }
     */
    public static int WLR_OUTPUT_PRESENT_HW_CLOCK() {
        return WLR_OUTPUT_PRESENT_HW_CLOCK;
    }
    private static final int WLR_OUTPUT_PRESENT_HW_COMPLETION = (int)4L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_present_flag.WLR_OUTPUT_PRESENT_HW_COMPLETION = 4
     * }
     */
    public static int WLR_OUTPUT_PRESENT_HW_COMPLETION() {
        return WLR_OUTPUT_PRESENT_HW_COMPLETION;
    }
    private static final int WLR_OUTPUT_PRESENT_ZERO_COPY = (int)8L;
    /**
     * {@snippet lang=c :
     * enum wlr_output_present_flag.WLR_OUTPUT_PRESENT_ZERO_COPY = 8
     * }
     */
    public static int WLR_OUTPUT_PRESENT_ZERO_COPY() {
        return WLR_OUTPUT_PRESENT_ZERO_COPY;
    }

    private static class wlr_output_enable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_BOOL
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_enable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_enable(struct wlr_output *output, bool enable)
     * }
     */
    public static FunctionDescriptor wlr_output_enable$descriptor() {
        return wlr_output_enable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_enable(struct wlr_output *output, bool enable)
     * }
     */
    public static MethodHandle wlr_output_enable$handle() {
        return wlr_output_enable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_enable(struct wlr_output *output, bool enable)
     * }
     */
    public static MemorySegment wlr_output_enable$address() {
        return wlr_output_enable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_enable(struct wlr_output *output, bool enable)
     * }
     */
    public static void wlr_output_enable(MemorySegment output, boolean enable) {
        var mh$ = wlr_output_enable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_enable", output, enable);
            }
            mh$.invokeExact(output, enable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_create_global {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_create_global");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_create_global(struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_output_create_global$descriptor() {
        return wlr_output_create_global.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_create_global(struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_output_create_global$handle() {
        return wlr_output_create_global.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_create_global(struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_output_create_global$address() {
        return wlr_output_create_global.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_create_global(struct wlr_output *output)
     * }
     */
    public static void wlr_output_create_global(MemorySegment output) {
        var mh$ = wlr_output_create_global.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_create_global", output);
            }
            mh$.invokeExact(output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_destroy_global {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_destroy_global");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_destroy_global(struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_output_destroy_global$descriptor() {
        return wlr_output_destroy_global.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_destroy_global(struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_output_destroy_global$handle() {
        return wlr_output_destroy_global.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_destroy_global(struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_output_destroy_global$address() {
        return wlr_output_destroy_global.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_destroy_global(struct wlr_output *output)
     * }
     */
    public static void wlr_output_destroy_global(MemorySegment output) {
        var mh$ = wlr_output_destroy_global.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_destroy_global", output);
            }
            mh$.invokeExact(output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_init_render {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_init_render");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_output_init_render(struct wlr_output *output, struct wlr_allocator *allocator, struct wlr_renderer *renderer)
     * }
     */
    public static FunctionDescriptor wlr_output_init_render$descriptor() {
        return wlr_output_init_render.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_output_init_render(struct wlr_output *output, struct wlr_allocator *allocator, struct wlr_renderer *renderer)
     * }
     */
    public static MethodHandle wlr_output_init_render$handle() {
        return wlr_output_init_render.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_output_init_render(struct wlr_output *output, struct wlr_allocator *allocator, struct wlr_renderer *renderer)
     * }
     */
    public static MemorySegment wlr_output_init_render$address() {
        return wlr_output_init_render.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_output_init_render(struct wlr_output *output, struct wlr_allocator *allocator, struct wlr_renderer *renderer)
     * }
     */
    public static boolean wlr_output_init_render(MemorySegment output, MemorySegment allocator, MemorySegment renderer) {
        var mh$ = wlr_output_init_render.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_init_render", output, allocator, renderer);
            }
            return (boolean)mh$.invokeExact(output, allocator, renderer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_preferred_mode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_preferred_mode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_output_mode *wlr_output_preferred_mode(struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_output_preferred_mode$descriptor() {
        return wlr_output_preferred_mode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_output_mode *wlr_output_preferred_mode(struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_output_preferred_mode$handle() {
        return wlr_output_preferred_mode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_output_mode *wlr_output_preferred_mode(struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_output_preferred_mode$address() {
        return wlr_output_preferred_mode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_output_mode *wlr_output_preferred_mode(struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_output_preferred_mode(MemorySegment output) {
        var mh$ = wlr_output_preferred_mode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_preferred_mode", output);
            }
            return (MemorySegment)mh$.invokeExact(output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_set_mode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_set_mode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_set_mode(struct wlr_output *output, struct wlr_output_mode *mode)
     * }
     */
    public static FunctionDescriptor wlr_output_set_mode$descriptor() {
        return wlr_output_set_mode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_set_mode(struct wlr_output *output, struct wlr_output_mode *mode)
     * }
     */
    public static MethodHandle wlr_output_set_mode$handle() {
        return wlr_output_set_mode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_set_mode(struct wlr_output *output, struct wlr_output_mode *mode)
     * }
     */
    public static MemorySegment wlr_output_set_mode$address() {
        return wlr_output_set_mode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_set_mode(struct wlr_output *output, struct wlr_output_mode *mode)
     * }
     */
    public static void wlr_output_set_mode(MemorySegment output, MemorySegment mode) {
        var mh$ = wlr_output_set_mode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_set_mode", output, mode);
            }
            mh$.invokeExact(output, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_set_custom_mode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_set_custom_mode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_set_custom_mode(struct wlr_output *output, int32_t width, int32_t height, int32_t refresh)
     * }
     */
    public static FunctionDescriptor wlr_output_set_custom_mode$descriptor() {
        return wlr_output_set_custom_mode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_set_custom_mode(struct wlr_output *output, int32_t width, int32_t height, int32_t refresh)
     * }
     */
    public static MethodHandle wlr_output_set_custom_mode$handle() {
        return wlr_output_set_custom_mode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_set_custom_mode(struct wlr_output *output, int32_t width, int32_t height, int32_t refresh)
     * }
     */
    public static MemorySegment wlr_output_set_custom_mode$address() {
        return wlr_output_set_custom_mode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_set_custom_mode(struct wlr_output *output, int32_t width, int32_t height, int32_t refresh)
     * }
     */
    public static void wlr_output_set_custom_mode(MemorySegment output, int width, int height, int refresh) {
        var mh$ = wlr_output_set_custom_mode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_set_custom_mode", output, width, height, refresh);
            }
            mh$.invokeExact(output, width, height, refresh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_set_transform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_set_transform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_set_transform(struct wlr_output *output, enum wl_output_transform transform)
     * }
     */
    public static FunctionDescriptor wlr_output_set_transform$descriptor() {
        return wlr_output_set_transform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_set_transform(struct wlr_output *output, enum wl_output_transform transform)
     * }
     */
    public static MethodHandle wlr_output_set_transform$handle() {
        return wlr_output_set_transform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_set_transform(struct wlr_output *output, enum wl_output_transform transform)
     * }
     */
    public static MemorySegment wlr_output_set_transform$address() {
        return wlr_output_set_transform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_set_transform(struct wlr_output *output, enum wl_output_transform transform)
     * }
     */
    public static void wlr_output_set_transform(MemorySegment output, int transform) {
        var mh$ = wlr_output_set_transform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_set_transform", output, transform);
            }
            mh$.invokeExact(output, transform);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_enable_adaptive_sync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_BOOL
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_enable_adaptive_sync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_enable_adaptive_sync(struct wlr_output *output, bool enabled)
     * }
     */
    public static FunctionDescriptor wlr_output_enable_adaptive_sync$descriptor() {
        return wlr_output_enable_adaptive_sync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_enable_adaptive_sync(struct wlr_output *output, bool enabled)
     * }
     */
    public static MethodHandle wlr_output_enable_adaptive_sync$handle() {
        return wlr_output_enable_adaptive_sync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_enable_adaptive_sync(struct wlr_output *output, bool enabled)
     * }
     */
    public static MemorySegment wlr_output_enable_adaptive_sync$address() {
        return wlr_output_enable_adaptive_sync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_enable_adaptive_sync(struct wlr_output *output, bool enabled)
     * }
     */
    public static void wlr_output_enable_adaptive_sync(MemorySegment output, boolean enabled) {
        var mh$ = wlr_output_enable_adaptive_sync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_enable_adaptive_sync", output, enabled);
            }
            mh$.invokeExact(output, enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_set_render_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_set_render_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_set_render_format(struct wlr_output *output, uint32_t format)
     * }
     */
    public static FunctionDescriptor wlr_output_set_render_format$descriptor() {
        return wlr_output_set_render_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_set_render_format(struct wlr_output *output, uint32_t format)
     * }
     */
    public static MethodHandle wlr_output_set_render_format$handle() {
        return wlr_output_set_render_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_set_render_format(struct wlr_output *output, uint32_t format)
     * }
     */
    public static MemorySegment wlr_output_set_render_format$address() {
        return wlr_output_set_render_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_set_render_format(struct wlr_output *output, uint32_t format)
     * }
     */
    public static void wlr_output_set_render_format(MemorySegment output, int format) {
        var mh$ = wlr_output_set_render_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_set_render_format", output, format);
            }
            mh$.invokeExact(output, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_set_scale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_set_scale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_set_scale(struct wlr_output *output, float scale)
     * }
     */
    public static FunctionDescriptor wlr_output_set_scale$descriptor() {
        return wlr_output_set_scale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_set_scale(struct wlr_output *output, float scale)
     * }
     */
    public static MethodHandle wlr_output_set_scale$handle() {
        return wlr_output_set_scale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_set_scale(struct wlr_output *output, float scale)
     * }
     */
    public static MemorySegment wlr_output_set_scale$address() {
        return wlr_output_set_scale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_set_scale(struct wlr_output *output, float scale)
     * }
     */
    public static void wlr_output_set_scale(MemorySegment output, float scale) {
        var mh$ = wlr_output_set_scale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_set_scale", output, scale);
            }
            mh$.invokeExact(output, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_set_subpixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_set_subpixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_set_subpixel(struct wlr_output *output, enum wl_output_subpixel subpixel)
     * }
     */
    public static FunctionDescriptor wlr_output_set_subpixel$descriptor() {
        return wlr_output_set_subpixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_set_subpixel(struct wlr_output *output, enum wl_output_subpixel subpixel)
     * }
     */
    public static MethodHandle wlr_output_set_subpixel$handle() {
        return wlr_output_set_subpixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_set_subpixel(struct wlr_output *output, enum wl_output_subpixel subpixel)
     * }
     */
    public static MemorySegment wlr_output_set_subpixel$address() {
        return wlr_output_set_subpixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_set_subpixel(struct wlr_output *output, enum wl_output_subpixel subpixel)
     * }
     */
    public static void wlr_output_set_subpixel(MemorySegment output, int subpixel) {
        var mh$ = wlr_output_set_subpixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_set_subpixel", output, subpixel);
            }
            mh$.invokeExact(output, subpixel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_set_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_set_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_set_name(struct wlr_output *output, const char *name)
     * }
     */
    public static FunctionDescriptor wlr_output_set_name$descriptor() {
        return wlr_output_set_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_set_name(struct wlr_output *output, const char *name)
     * }
     */
    public static MethodHandle wlr_output_set_name$handle() {
        return wlr_output_set_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_set_name(struct wlr_output *output, const char *name)
     * }
     */
    public static MemorySegment wlr_output_set_name$address() {
        return wlr_output_set_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_set_name(struct wlr_output *output, const char *name)
     * }
     */
    public static void wlr_output_set_name(MemorySegment output, MemorySegment name) {
        var mh$ = wlr_output_set_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_set_name", output, name);
            }
            mh$.invokeExact(output, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_set_description {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_set_description");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_set_description(struct wlr_output *output, const char *desc)
     * }
     */
    public static FunctionDescriptor wlr_output_set_description$descriptor() {
        return wlr_output_set_description.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_set_description(struct wlr_output *output, const char *desc)
     * }
     */
    public static MethodHandle wlr_output_set_description$handle() {
        return wlr_output_set_description.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_set_description(struct wlr_output *output, const char *desc)
     * }
     */
    public static MemorySegment wlr_output_set_description$address() {
        return wlr_output_set_description.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_set_description(struct wlr_output *output, const char *desc)
     * }
     */
    public static void wlr_output_set_description(MemorySegment output, MemorySegment desc) {
        var mh$ = wlr_output_set_description.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_set_description", output, desc);
            }
            mh$.invokeExact(output, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_schedule_done {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_schedule_done");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_schedule_done(struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_output_schedule_done$descriptor() {
        return wlr_output_schedule_done.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_schedule_done(struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_output_schedule_done$handle() {
        return wlr_output_schedule_done.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_schedule_done(struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_output_schedule_done$address() {
        return wlr_output_schedule_done.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_schedule_done(struct wlr_output *output)
     * }
     */
    public static void wlr_output_schedule_done(MemorySegment output) {
        var mh$ = wlr_output_schedule_done.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_schedule_done", output);
            }
            mh$.invokeExact(output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_destroy(struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_output_destroy$descriptor() {
        return wlr_output_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_destroy(struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_output_destroy$handle() {
        return wlr_output_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_destroy(struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_output_destroy$address() {
        return wlr_output_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_destroy(struct wlr_output *output)
     * }
     */
    public static void wlr_output_destroy(MemorySegment output) {
        var mh$ = wlr_output_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_destroy", output);
            }
            mh$.invokeExact(output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_transformed_resolution {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_transformed_resolution");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_transformed_resolution(struct wlr_output *output, int *width, int *height)
     * }
     */
    public static FunctionDescriptor wlr_output_transformed_resolution$descriptor() {
        return wlr_output_transformed_resolution.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_transformed_resolution(struct wlr_output *output, int *width, int *height)
     * }
     */
    public static MethodHandle wlr_output_transformed_resolution$handle() {
        return wlr_output_transformed_resolution.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_transformed_resolution(struct wlr_output *output, int *width, int *height)
     * }
     */
    public static MemorySegment wlr_output_transformed_resolution$address() {
        return wlr_output_transformed_resolution.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_transformed_resolution(struct wlr_output *output, int *width, int *height)
     * }
     */
    public static void wlr_output_transformed_resolution(MemorySegment output, MemorySegment width, MemorySegment height) {
        var mh$ = wlr_output_transformed_resolution.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_transformed_resolution", output, width, height);
            }
            mh$.invokeExact(output, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_effective_resolution {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_effective_resolution");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_effective_resolution(struct wlr_output *output, int *width, int *height)
     * }
     */
    public static FunctionDescriptor wlr_output_effective_resolution$descriptor() {
        return wlr_output_effective_resolution.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_effective_resolution(struct wlr_output *output, int *width, int *height)
     * }
     */
    public static MethodHandle wlr_output_effective_resolution$handle() {
        return wlr_output_effective_resolution.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_effective_resolution(struct wlr_output *output, int *width, int *height)
     * }
     */
    public static MemorySegment wlr_output_effective_resolution$address() {
        return wlr_output_effective_resolution.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_effective_resolution(struct wlr_output *output, int *width, int *height)
     * }
     */
    public static void wlr_output_effective_resolution(MemorySegment output, MemorySegment width, MemorySegment height) {
        var mh$ = wlr_output_effective_resolution.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_effective_resolution", output, width, height);
            }
            mh$.invokeExact(output, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_attach_render {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_attach_render");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_output_attach_render(struct wlr_output *output, int *buffer_age)
     * }
     */
    public static FunctionDescriptor wlr_output_attach_render$descriptor() {
        return wlr_output_attach_render.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_output_attach_render(struct wlr_output *output, int *buffer_age)
     * }
     */
    public static MethodHandle wlr_output_attach_render$handle() {
        return wlr_output_attach_render.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_output_attach_render(struct wlr_output *output, int *buffer_age)
     * }
     */
    public static MemorySegment wlr_output_attach_render$address() {
        return wlr_output_attach_render.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_output_attach_render(struct wlr_output *output, int *buffer_age)
     * }
     */
    public static boolean wlr_output_attach_render(MemorySegment output, MemorySegment buffer_age) {
        var mh$ = wlr_output_attach_render.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_attach_render", output, buffer_age);
            }
            return (boolean)mh$.invokeExact(output, buffer_age);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_attach_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_attach_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_attach_buffer(struct wlr_output *output, struct wlr_buffer *buffer)
     * }
     */
    public static FunctionDescriptor wlr_output_attach_buffer$descriptor() {
        return wlr_output_attach_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_attach_buffer(struct wlr_output *output, struct wlr_buffer *buffer)
     * }
     */
    public static MethodHandle wlr_output_attach_buffer$handle() {
        return wlr_output_attach_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_attach_buffer(struct wlr_output *output, struct wlr_buffer *buffer)
     * }
     */
    public static MemorySegment wlr_output_attach_buffer$address() {
        return wlr_output_attach_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_attach_buffer(struct wlr_output *output, struct wlr_buffer *buffer)
     * }
     */
    public static void wlr_output_attach_buffer(MemorySegment output, MemorySegment buffer) {
        var mh$ = wlr_output_attach_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_attach_buffer", output, buffer);
            }
            mh$.invokeExact(output, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_preferred_read_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_preferred_read_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t wlr_output_preferred_read_format(struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_output_preferred_read_format$descriptor() {
        return wlr_output_preferred_read_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t wlr_output_preferred_read_format(struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_output_preferred_read_format$handle() {
        return wlr_output_preferred_read_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t wlr_output_preferred_read_format(struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_output_preferred_read_format$address() {
        return wlr_output_preferred_read_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t wlr_output_preferred_read_format(struct wlr_output *output)
     * }
     */
    public static int wlr_output_preferred_read_format(MemorySegment output) {
        var mh$ = wlr_output_preferred_read_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_preferred_read_format", output);
            }
            return (int)mh$.invokeExact(output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_set_damage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_set_damage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_set_damage(struct wlr_output *output, const pixman_region32_t *damage)
     * }
     */
    public static FunctionDescriptor wlr_output_set_damage$descriptor() {
        return wlr_output_set_damage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_set_damage(struct wlr_output *output, const pixman_region32_t *damage)
     * }
     */
    public static MethodHandle wlr_output_set_damage$handle() {
        return wlr_output_set_damage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_set_damage(struct wlr_output *output, const pixman_region32_t *damage)
     * }
     */
    public static MemorySegment wlr_output_set_damage$address() {
        return wlr_output_set_damage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_set_damage(struct wlr_output *output, const pixman_region32_t *damage)
     * }
     */
    public static void wlr_output_set_damage(MemorySegment output, MemorySegment damage) {
        var mh$ = wlr_output_set_damage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_set_damage", output, damage);
            }
            mh$.invokeExact(output, damage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_set_layers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_LONG
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_set_layers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_set_layers(struct wlr_output *output, struct wlr_output_layer_state *layers, size_t layers_len)
     * }
     */
    public static FunctionDescriptor wlr_output_set_layers$descriptor() {
        return wlr_output_set_layers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_set_layers(struct wlr_output *output, struct wlr_output_layer_state *layers, size_t layers_len)
     * }
     */
    public static MethodHandle wlr_output_set_layers$handle() {
        return wlr_output_set_layers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_set_layers(struct wlr_output *output, struct wlr_output_layer_state *layers, size_t layers_len)
     * }
     */
    public static MemorySegment wlr_output_set_layers$address() {
        return wlr_output_set_layers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_set_layers(struct wlr_output *output, struct wlr_output_layer_state *layers, size_t layers_len)
     * }
     */
    public static void wlr_output_set_layers(MemorySegment output, MemorySegment layers, long layers_len) {
        var mh$ = wlr_output_set_layers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_set_layers", output, layers, layers_len);
            }
            mh$.invokeExact(output, layers, layers_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_test {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_test");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_output_test(struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_output_test$descriptor() {
        return wlr_output_test.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_output_test(struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_output_test$handle() {
        return wlr_output_test.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_output_test(struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_output_test$address() {
        return wlr_output_test.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_output_test(struct wlr_output *output)
     * }
     */
    public static boolean wlr_output_test(MemorySegment output) {
        var mh$ = wlr_output_test.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_test", output);
            }
            return (boolean)mh$.invokeExact(output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_commit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_commit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_output_commit(struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_output_commit$descriptor() {
        return wlr_output_commit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_output_commit(struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_output_commit$handle() {
        return wlr_output_commit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_output_commit(struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_output_commit$address() {
        return wlr_output_commit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_output_commit(struct wlr_output *output)
     * }
     */
    public static boolean wlr_output_commit(MemorySegment output) {
        var mh$ = wlr_output_commit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_commit", output);
            }
            return (boolean)mh$.invokeExact(output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_rollback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_rollback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_rollback(struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_output_rollback$descriptor() {
        return wlr_output_rollback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_rollback(struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_output_rollback$handle() {
        return wlr_output_rollback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_rollback(struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_output_rollback$address() {
        return wlr_output_rollback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_rollback(struct wlr_output *output)
     * }
     */
    public static void wlr_output_rollback(MemorySegment output) {
        var mh$ = wlr_output_rollback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_rollback", output);
            }
            mh$.invokeExact(output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_test_state {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_test_state");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_output_test_state(struct wlr_output *output, const struct wlr_output_state *state)
     * }
     */
    public static FunctionDescriptor wlr_output_test_state$descriptor() {
        return wlr_output_test_state.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_output_test_state(struct wlr_output *output, const struct wlr_output_state *state)
     * }
     */
    public static MethodHandle wlr_output_test_state$handle() {
        return wlr_output_test_state.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_output_test_state(struct wlr_output *output, const struct wlr_output_state *state)
     * }
     */
    public static MemorySegment wlr_output_test_state$address() {
        return wlr_output_test_state.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_output_test_state(struct wlr_output *output, const struct wlr_output_state *state)
     * }
     */
    public static boolean wlr_output_test_state(MemorySegment output, MemorySegment state) {
        var mh$ = wlr_output_test_state.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_test_state", output, state);
            }
            return (boolean)mh$.invokeExact(output, state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_commit_state {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_commit_state");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_output_commit_state(struct wlr_output *output, const struct wlr_output_state *state)
     * }
     */
    public static FunctionDescriptor wlr_output_commit_state$descriptor() {
        return wlr_output_commit_state.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_output_commit_state(struct wlr_output *output, const struct wlr_output_state *state)
     * }
     */
    public static MethodHandle wlr_output_commit_state$handle() {
        return wlr_output_commit_state.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_output_commit_state(struct wlr_output *output, const struct wlr_output_state *state)
     * }
     */
    public static MemorySegment wlr_output_commit_state$address() {
        return wlr_output_commit_state.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_output_commit_state(struct wlr_output *output, const struct wlr_output_state *state)
     * }
     */
    public static boolean wlr_output_commit_state(MemorySegment output, MemorySegment state) {
        var mh$ = wlr_output_commit_state.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_commit_state", output, state);
            }
            return (boolean)mh$.invokeExact(output, state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_schedule_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_schedule_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_schedule_frame(struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_output_schedule_frame$descriptor() {
        return wlr_output_schedule_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_schedule_frame(struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_output_schedule_frame$handle() {
        return wlr_output_schedule_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_schedule_frame(struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_output_schedule_frame$address() {
        return wlr_output_schedule_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_schedule_frame(struct wlr_output *output)
     * }
     */
    public static void wlr_output_schedule_frame(MemorySegment output) {
        var mh$ = wlr_output_schedule_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_schedule_frame", output);
            }
            mh$.invokeExact(output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_get_gamma_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_get_gamma_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wlr_output_get_gamma_size(struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_output_get_gamma_size$descriptor() {
        return wlr_output_get_gamma_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wlr_output_get_gamma_size(struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_output_get_gamma_size$handle() {
        return wlr_output_get_gamma_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wlr_output_get_gamma_size(struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_output_get_gamma_size$address() {
        return wlr_output_get_gamma_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wlr_output_get_gamma_size(struct wlr_output *output)
     * }
     */
    public static long wlr_output_get_gamma_size(MemorySegment output) {
        var mh$ = wlr_output_get_gamma_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_get_gamma_size", output);
            }
            return (long)mh$.invokeExact(output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_set_gamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_LONG,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_set_gamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_set_gamma(struct wlr_output *output, size_t size, const uint16_t *r, const uint16_t *g, const uint16_t *b)
     * }
     */
    public static FunctionDescriptor wlr_output_set_gamma$descriptor() {
        return wlr_output_set_gamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_set_gamma(struct wlr_output *output, size_t size, const uint16_t *r, const uint16_t *g, const uint16_t *b)
     * }
     */
    public static MethodHandle wlr_output_set_gamma$handle() {
        return wlr_output_set_gamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_set_gamma(struct wlr_output *output, size_t size, const uint16_t *r, const uint16_t *g, const uint16_t *b)
     * }
     */
    public static MemorySegment wlr_output_set_gamma$address() {
        return wlr_output_set_gamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_set_gamma(struct wlr_output *output, size_t size, const uint16_t *r, const uint16_t *g, const uint16_t *b)
     * }
     */
    public static void wlr_output_set_gamma(MemorySegment output, long size, MemorySegment r, MemorySegment g, MemorySegment b) {
        var mh$ = wlr_output_set_gamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_set_gamma", output, size, r, g, b);
            }
            mh$.invokeExact(output, size, r, g, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_from_resource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_from_resource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_output *wlr_output_from_resource(struct wl_resource *resource)
     * }
     */
    public static FunctionDescriptor wlr_output_from_resource$descriptor() {
        return wlr_output_from_resource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_output *wlr_output_from_resource(struct wl_resource *resource)
     * }
     */
    public static MethodHandle wlr_output_from_resource$handle() {
        return wlr_output_from_resource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_output *wlr_output_from_resource(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wlr_output_from_resource$address() {
        return wlr_output_from_resource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_output *wlr_output_from_resource(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wlr_output_from_resource(MemorySegment resource) {
        var mh$ = wlr_output_from_resource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_from_resource", resource);
            }
            return (MemorySegment)mh$.invokeExact(resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_lock_attach_render {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_BOOL
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_lock_attach_render");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_lock_attach_render(struct wlr_output *output, bool lock)
     * }
     */
    public static FunctionDescriptor wlr_output_lock_attach_render$descriptor() {
        return wlr_output_lock_attach_render.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_lock_attach_render(struct wlr_output *output, bool lock)
     * }
     */
    public static MethodHandle wlr_output_lock_attach_render$handle() {
        return wlr_output_lock_attach_render.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_lock_attach_render(struct wlr_output *output, bool lock)
     * }
     */
    public static MemorySegment wlr_output_lock_attach_render$address() {
        return wlr_output_lock_attach_render.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_lock_attach_render(struct wlr_output *output, bool lock)
     * }
     */
    public static void wlr_output_lock_attach_render(MemorySegment output, boolean lock) {
        var mh$ = wlr_output_lock_attach_render.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_lock_attach_render", output, lock);
            }
            mh$.invokeExact(output, lock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_lock_software_cursors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_BOOL
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_lock_software_cursors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_lock_software_cursors(struct wlr_output *output, bool lock)
     * }
     */
    public static FunctionDescriptor wlr_output_lock_software_cursors$descriptor() {
        return wlr_output_lock_software_cursors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_lock_software_cursors(struct wlr_output *output, bool lock)
     * }
     */
    public static MethodHandle wlr_output_lock_software_cursors$handle() {
        return wlr_output_lock_software_cursors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_lock_software_cursors(struct wlr_output *output, bool lock)
     * }
     */
    public static MemorySegment wlr_output_lock_software_cursors$address() {
        return wlr_output_lock_software_cursors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_lock_software_cursors(struct wlr_output *output, bool lock)
     * }
     */
    public static void wlr_output_lock_software_cursors(MemorySegment output, boolean lock) {
        var mh$ = wlr_output_lock_software_cursors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_lock_software_cursors", output, lock);
            }
            mh$.invokeExact(output, lock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_render_software_cursors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_render_software_cursors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_render_software_cursors(struct wlr_output *output, const pixman_region32_t *damage)
     * }
     */
    public static FunctionDescriptor wlr_output_render_software_cursors$descriptor() {
        return wlr_output_render_software_cursors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_render_software_cursors(struct wlr_output *output, const pixman_region32_t *damage)
     * }
     */
    public static MethodHandle wlr_output_render_software_cursors$handle() {
        return wlr_output_render_software_cursors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_render_software_cursors(struct wlr_output *output, const pixman_region32_t *damage)
     * }
     */
    public static MemorySegment wlr_output_render_software_cursors$address() {
        return wlr_output_render_software_cursors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_render_software_cursors(struct wlr_output *output, const pixman_region32_t *damage)
     * }
     */
    public static void wlr_output_render_software_cursors(MemorySegment output, MemorySegment damage) {
        var mh$ = wlr_output_render_software_cursors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_render_software_cursors", output, damage);
            }
            mh$.invokeExact(output, damage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_add_software_cursors_to_render_pass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_add_software_cursors_to_render_pass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_add_software_cursors_to_render_pass(struct wlr_output *output, struct wlr_render_pass *render_pass, const pixman_region32_t *damage)
     * }
     */
    public static FunctionDescriptor wlr_output_add_software_cursors_to_render_pass$descriptor() {
        return wlr_output_add_software_cursors_to_render_pass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_add_software_cursors_to_render_pass(struct wlr_output *output, struct wlr_render_pass *render_pass, const pixman_region32_t *damage)
     * }
     */
    public static MethodHandle wlr_output_add_software_cursors_to_render_pass$handle() {
        return wlr_output_add_software_cursors_to_render_pass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_add_software_cursors_to_render_pass(struct wlr_output *output, struct wlr_render_pass *render_pass, const pixman_region32_t *damage)
     * }
     */
    public static MemorySegment wlr_output_add_software_cursors_to_render_pass$address() {
        return wlr_output_add_software_cursors_to_render_pass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_add_software_cursors_to_render_pass(struct wlr_output *output, struct wlr_render_pass *render_pass, const pixman_region32_t *damage)
     * }
     */
    public static void wlr_output_add_software_cursors_to_render_pass(MemorySegment output, MemorySegment render_pass, MemorySegment damage) {
        var mh$ = wlr_output_add_software_cursors_to_render_pass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_add_software_cursors_to_render_pass", output, render_pass, damage);
            }
            mh$.invokeExact(output, render_pass, damage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_get_primary_formats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_get_primary_formats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const struct wlr_drm_format_set *wlr_output_get_primary_formats(struct wlr_output *output, uint32_t buffer_caps)
     * }
     */
    public static FunctionDescriptor wlr_output_get_primary_formats$descriptor() {
        return wlr_output_get_primary_formats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const struct wlr_drm_format_set *wlr_output_get_primary_formats(struct wlr_output *output, uint32_t buffer_caps)
     * }
     */
    public static MethodHandle wlr_output_get_primary_formats$handle() {
        return wlr_output_get_primary_formats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const struct wlr_drm_format_set *wlr_output_get_primary_formats(struct wlr_output *output, uint32_t buffer_caps)
     * }
     */
    public static MemorySegment wlr_output_get_primary_formats$address() {
        return wlr_output_get_primary_formats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const struct wlr_drm_format_set *wlr_output_get_primary_formats(struct wlr_output *output, uint32_t buffer_caps)
     * }
     */
    public static MemorySegment wlr_output_get_primary_formats(MemorySegment output, int buffer_caps) {
        var mh$ = wlr_output_get_primary_formats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_get_primary_formats", output, buffer_caps);
            }
            return (MemorySegment)mh$.invokeExact(output, buffer_caps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_is_direct_scanout_allowed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_is_direct_scanout_allowed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_output_is_direct_scanout_allowed(struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_output_is_direct_scanout_allowed$descriptor() {
        return wlr_output_is_direct_scanout_allowed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_output_is_direct_scanout_allowed(struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_output_is_direct_scanout_allowed$handle() {
        return wlr_output_is_direct_scanout_allowed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_output_is_direct_scanout_allowed(struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_output_is_direct_scanout_allowed$address() {
        return wlr_output_is_direct_scanout_allowed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_output_is_direct_scanout_allowed(struct wlr_output *output)
     * }
     */
    public static boolean wlr_output_is_direct_scanout_allowed(MemorySegment output) {
        var mh$ = wlr_output_is_direct_scanout_allowed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_is_direct_scanout_allowed", output);
            }
            return (boolean)mh$.invokeExact(output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_cursor_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_cursor_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_output_cursor *wlr_output_cursor_create(struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_output_cursor_create$descriptor() {
        return wlr_output_cursor_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_output_cursor *wlr_output_cursor_create(struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_output_cursor_create$handle() {
        return wlr_output_cursor_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_output_cursor *wlr_output_cursor_create(struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_output_cursor_create$address() {
        return wlr_output_cursor_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_output_cursor *wlr_output_cursor_create(struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_output_cursor_create(MemorySegment output) {
        var mh$ = wlr_output_cursor_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_cursor_create", output);
            }
            return (MemorySegment)mh$.invokeExact(output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_cursor_set_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_cursor_set_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_output_cursor_set_buffer(struct wlr_output_cursor *cursor, struct wlr_buffer *buffer, int32_t hotspot_x, int32_t hotspot_y)
     * }
     */
    public static FunctionDescriptor wlr_output_cursor_set_buffer$descriptor() {
        return wlr_output_cursor_set_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_output_cursor_set_buffer(struct wlr_output_cursor *cursor, struct wlr_buffer *buffer, int32_t hotspot_x, int32_t hotspot_y)
     * }
     */
    public static MethodHandle wlr_output_cursor_set_buffer$handle() {
        return wlr_output_cursor_set_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_output_cursor_set_buffer(struct wlr_output_cursor *cursor, struct wlr_buffer *buffer, int32_t hotspot_x, int32_t hotspot_y)
     * }
     */
    public static MemorySegment wlr_output_cursor_set_buffer$address() {
        return wlr_output_cursor_set_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_output_cursor_set_buffer(struct wlr_output_cursor *cursor, struct wlr_buffer *buffer, int32_t hotspot_x, int32_t hotspot_y)
     * }
     */
    public static boolean wlr_output_cursor_set_buffer(MemorySegment cursor, MemorySegment buffer, int hotspot_x, int hotspot_y) {
        var mh$ = wlr_output_cursor_set_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_cursor_set_buffer", cursor, buffer, hotspot_x, hotspot_y);
            }
            return (boolean)mh$.invokeExact(cursor, buffer, hotspot_x, hotspot_y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_cursor_move {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_cursor_move");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_output_cursor_move(struct wlr_output_cursor *cursor, double x, double y)
     * }
     */
    public static FunctionDescriptor wlr_output_cursor_move$descriptor() {
        return wlr_output_cursor_move.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_output_cursor_move(struct wlr_output_cursor *cursor, double x, double y)
     * }
     */
    public static MethodHandle wlr_output_cursor_move$handle() {
        return wlr_output_cursor_move.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_output_cursor_move(struct wlr_output_cursor *cursor, double x, double y)
     * }
     */
    public static MemorySegment wlr_output_cursor_move$address() {
        return wlr_output_cursor_move.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_output_cursor_move(struct wlr_output_cursor *cursor, double x, double y)
     * }
     */
    public static boolean wlr_output_cursor_move(MemorySegment cursor, double x, double y) {
        var mh$ = wlr_output_cursor_move.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_cursor_move", cursor, x, y);
            }
            return (boolean)mh$.invokeExact(cursor, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_cursor_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_cursor_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_cursor_destroy(struct wlr_output_cursor *cursor)
     * }
     */
    public static FunctionDescriptor wlr_output_cursor_destroy$descriptor() {
        return wlr_output_cursor_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_cursor_destroy(struct wlr_output_cursor *cursor)
     * }
     */
    public static MethodHandle wlr_output_cursor_destroy$handle() {
        return wlr_output_cursor_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_cursor_destroy(struct wlr_output_cursor *cursor)
     * }
     */
    public static MemorySegment wlr_output_cursor_destroy$address() {
        return wlr_output_cursor_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_cursor_destroy(struct wlr_output_cursor *cursor)
     * }
     */
    public static void wlr_output_cursor_destroy(MemorySegment cursor) {
        var mh$ = wlr_output_cursor_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_cursor_destroy", cursor);
            }
            mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_state_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_state_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_state_init(struct wlr_output_state *state)
     * }
     */
    public static FunctionDescriptor wlr_output_state_init$descriptor() {
        return wlr_output_state_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_state_init(struct wlr_output_state *state)
     * }
     */
    public static MethodHandle wlr_output_state_init$handle() {
        return wlr_output_state_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_state_init(struct wlr_output_state *state)
     * }
     */
    public static MemorySegment wlr_output_state_init$address() {
        return wlr_output_state_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_state_init(struct wlr_output_state *state)
     * }
     */
    public static void wlr_output_state_init(MemorySegment state) {
        var mh$ = wlr_output_state_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_state_init", state);
            }
            mh$.invokeExact(state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_state_finish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_state_finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_state_finish(struct wlr_output_state *state)
     * }
     */
    public static FunctionDescriptor wlr_output_state_finish$descriptor() {
        return wlr_output_state_finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_state_finish(struct wlr_output_state *state)
     * }
     */
    public static MethodHandle wlr_output_state_finish$handle() {
        return wlr_output_state_finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_state_finish(struct wlr_output_state *state)
     * }
     */
    public static MemorySegment wlr_output_state_finish$address() {
        return wlr_output_state_finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_state_finish(struct wlr_output_state *state)
     * }
     */
    public static void wlr_output_state_finish(MemorySegment state) {
        var mh$ = wlr_output_state_finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_state_finish", state);
            }
            mh$.invokeExact(state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_state_set_enabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_BOOL
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_state_set_enabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_state_set_enabled(struct wlr_output_state *state, bool enabled)
     * }
     */
    public static FunctionDescriptor wlr_output_state_set_enabled$descriptor() {
        return wlr_output_state_set_enabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_state_set_enabled(struct wlr_output_state *state, bool enabled)
     * }
     */
    public static MethodHandle wlr_output_state_set_enabled$handle() {
        return wlr_output_state_set_enabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_state_set_enabled(struct wlr_output_state *state, bool enabled)
     * }
     */
    public static MemorySegment wlr_output_state_set_enabled$address() {
        return wlr_output_state_set_enabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_state_set_enabled(struct wlr_output_state *state, bool enabled)
     * }
     */
    public static void wlr_output_state_set_enabled(MemorySegment state, boolean enabled) {
        var mh$ = wlr_output_state_set_enabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_state_set_enabled", state, enabled);
            }
            mh$.invokeExact(state, enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_state_set_mode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_state_set_mode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_state_set_mode(struct wlr_output_state *state, struct wlr_output_mode *mode)
     * }
     */
    public static FunctionDescriptor wlr_output_state_set_mode$descriptor() {
        return wlr_output_state_set_mode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_state_set_mode(struct wlr_output_state *state, struct wlr_output_mode *mode)
     * }
     */
    public static MethodHandle wlr_output_state_set_mode$handle() {
        return wlr_output_state_set_mode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_state_set_mode(struct wlr_output_state *state, struct wlr_output_mode *mode)
     * }
     */
    public static MemorySegment wlr_output_state_set_mode$address() {
        return wlr_output_state_set_mode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_state_set_mode(struct wlr_output_state *state, struct wlr_output_mode *mode)
     * }
     */
    public static void wlr_output_state_set_mode(MemorySegment state, MemorySegment mode) {
        var mh$ = wlr_output_state_set_mode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_state_set_mode", state, mode);
            }
            mh$.invokeExact(state, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_state_set_custom_mode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_state_set_custom_mode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_state_set_custom_mode(struct wlr_output_state *state, int32_t width, int32_t height, int32_t refresh)
     * }
     */
    public static FunctionDescriptor wlr_output_state_set_custom_mode$descriptor() {
        return wlr_output_state_set_custom_mode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_state_set_custom_mode(struct wlr_output_state *state, int32_t width, int32_t height, int32_t refresh)
     * }
     */
    public static MethodHandle wlr_output_state_set_custom_mode$handle() {
        return wlr_output_state_set_custom_mode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_state_set_custom_mode(struct wlr_output_state *state, int32_t width, int32_t height, int32_t refresh)
     * }
     */
    public static MemorySegment wlr_output_state_set_custom_mode$address() {
        return wlr_output_state_set_custom_mode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_state_set_custom_mode(struct wlr_output_state *state, int32_t width, int32_t height, int32_t refresh)
     * }
     */
    public static void wlr_output_state_set_custom_mode(MemorySegment state, int width, int height, int refresh) {
        var mh$ = wlr_output_state_set_custom_mode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_state_set_custom_mode", state, width, height, refresh);
            }
            mh$.invokeExact(state, width, height, refresh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_state_set_scale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_state_set_scale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_state_set_scale(struct wlr_output_state *state, float scale)
     * }
     */
    public static FunctionDescriptor wlr_output_state_set_scale$descriptor() {
        return wlr_output_state_set_scale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_state_set_scale(struct wlr_output_state *state, float scale)
     * }
     */
    public static MethodHandle wlr_output_state_set_scale$handle() {
        return wlr_output_state_set_scale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_state_set_scale(struct wlr_output_state *state, float scale)
     * }
     */
    public static MemorySegment wlr_output_state_set_scale$address() {
        return wlr_output_state_set_scale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_state_set_scale(struct wlr_output_state *state, float scale)
     * }
     */
    public static void wlr_output_state_set_scale(MemorySegment state, float scale) {
        var mh$ = wlr_output_state_set_scale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_state_set_scale", state, scale);
            }
            mh$.invokeExact(state, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_state_set_transform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_state_set_transform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_state_set_transform(struct wlr_output_state *state, enum wl_output_transform transform)
     * }
     */
    public static FunctionDescriptor wlr_output_state_set_transform$descriptor() {
        return wlr_output_state_set_transform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_state_set_transform(struct wlr_output_state *state, enum wl_output_transform transform)
     * }
     */
    public static MethodHandle wlr_output_state_set_transform$handle() {
        return wlr_output_state_set_transform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_state_set_transform(struct wlr_output_state *state, enum wl_output_transform transform)
     * }
     */
    public static MemorySegment wlr_output_state_set_transform$address() {
        return wlr_output_state_set_transform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_state_set_transform(struct wlr_output_state *state, enum wl_output_transform transform)
     * }
     */
    public static void wlr_output_state_set_transform(MemorySegment state, int transform) {
        var mh$ = wlr_output_state_set_transform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_state_set_transform", state, transform);
            }
            mh$.invokeExact(state, transform);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_state_set_adaptive_sync_enabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_BOOL
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_state_set_adaptive_sync_enabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_state_set_adaptive_sync_enabled(struct wlr_output_state *state, bool enabled)
     * }
     */
    public static FunctionDescriptor wlr_output_state_set_adaptive_sync_enabled$descriptor() {
        return wlr_output_state_set_adaptive_sync_enabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_state_set_adaptive_sync_enabled(struct wlr_output_state *state, bool enabled)
     * }
     */
    public static MethodHandle wlr_output_state_set_adaptive_sync_enabled$handle() {
        return wlr_output_state_set_adaptive_sync_enabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_state_set_adaptive_sync_enabled(struct wlr_output_state *state, bool enabled)
     * }
     */
    public static MemorySegment wlr_output_state_set_adaptive_sync_enabled$address() {
        return wlr_output_state_set_adaptive_sync_enabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_state_set_adaptive_sync_enabled(struct wlr_output_state *state, bool enabled)
     * }
     */
    public static void wlr_output_state_set_adaptive_sync_enabled(MemorySegment state, boolean enabled) {
        var mh$ = wlr_output_state_set_adaptive_sync_enabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_state_set_adaptive_sync_enabled", state, enabled);
            }
            mh$.invokeExact(state, enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_state_set_render_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_state_set_render_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_state_set_render_format(struct wlr_output_state *state, uint32_t format)
     * }
     */
    public static FunctionDescriptor wlr_output_state_set_render_format$descriptor() {
        return wlr_output_state_set_render_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_state_set_render_format(struct wlr_output_state *state, uint32_t format)
     * }
     */
    public static MethodHandle wlr_output_state_set_render_format$handle() {
        return wlr_output_state_set_render_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_state_set_render_format(struct wlr_output_state *state, uint32_t format)
     * }
     */
    public static MemorySegment wlr_output_state_set_render_format$address() {
        return wlr_output_state_set_render_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_state_set_render_format(struct wlr_output_state *state, uint32_t format)
     * }
     */
    public static void wlr_output_state_set_render_format(MemorySegment state, int format) {
        var mh$ = wlr_output_state_set_render_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_state_set_render_format", state, format);
            }
            mh$.invokeExact(state, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_state_set_subpixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_state_set_subpixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_state_set_subpixel(struct wlr_output_state *state, enum wl_output_subpixel subpixel)
     * }
     */
    public static FunctionDescriptor wlr_output_state_set_subpixel$descriptor() {
        return wlr_output_state_set_subpixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_state_set_subpixel(struct wlr_output_state *state, enum wl_output_subpixel subpixel)
     * }
     */
    public static MethodHandle wlr_output_state_set_subpixel$handle() {
        return wlr_output_state_set_subpixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_state_set_subpixel(struct wlr_output_state *state, enum wl_output_subpixel subpixel)
     * }
     */
    public static MemorySegment wlr_output_state_set_subpixel$address() {
        return wlr_output_state_set_subpixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_state_set_subpixel(struct wlr_output_state *state, enum wl_output_subpixel subpixel)
     * }
     */
    public static void wlr_output_state_set_subpixel(MemorySegment state, int subpixel) {
        var mh$ = wlr_output_state_set_subpixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_state_set_subpixel", state, subpixel);
            }
            mh$.invokeExact(state, subpixel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_state_set_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_state_set_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_state_set_buffer(struct wlr_output_state *state, struct wlr_buffer *buffer)
     * }
     */
    public static FunctionDescriptor wlr_output_state_set_buffer$descriptor() {
        return wlr_output_state_set_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_state_set_buffer(struct wlr_output_state *state, struct wlr_buffer *buffer)
     * }
     */
    public static MethodHandle wlr_output_state_set_buffer$handle() {
        return wlr_output_state_set_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_state_set_buffer(struct wlr_output_state *state, struct wlr_buffer *buffer)
     * }
     */
    public static MemorySegment wlr_output_state_set_buffer$address() {
        return wlr_output_state_set_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_state_set_buffer(struct wlr_output_state *state, struct wlr_buffer *buffer)
     * }
     */
    public static void wlr_output_state_set_buffer(MemorySegment state, MemorySegment buffer) {
        var mh$ = wlr_output_state_set_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_state_set_buffer", state, buffer);
            }
            mh$.invokeExact(state, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_state_set_gamma_lut {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_LONG,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_state_set_gamma_lut");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_output_state_set_gamma_lut(struct wlr_output_state *state, size_t ramp_size, const uint16_t *r, const uint16_t *g, const uint16_t *b)
     * }
     */
    public static FunctionDescriptor wlr_output_state_set_gamma_lut$descriptor() {
        return wlr_output_state_set_gamma_lut.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_output_state_set_gamma_lut(struct wlr_output_state *state, size_t ramp_size, const uint16_t *r, const uint16_t *g, const uint16_t *b)
     * }
     */
    public static MethodHandle wlr_output_state_set_gamma_lut$handle() {
        return wlr_output_state_set_gamma_lut.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_output_state_set_gamma_lut(struct wlr_output_state *state, size_t ramp_size, const uint16_t *r, const uint16_t *g, const uint16_t *b)
     * }
     */
    public static MemorySegment wlr_output_state_set_gamma_lut$address() {
        return wlr_output_state_set_gamma_lut.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_output_state_set_gamma_lut(struct wlr_output_state *state, size_t ramp_size, const uint16_t *r, const uint16_t *g, const uint16_t *b)
     * }
     */
    public static boolean wlr_output_state_set_gamma_lut(MemorySegment state, long ramp_size, MemorySegment r, MemorySegment g, MemorySegment b) {
        var mh$ = wlr_output_state_set_gamma_lut.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_state_set_gamma_lut", state, ramp_size, r, g, b);
            }
            return (boolean)mh$.invokeExact(state, ramp_size, r, g, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_state_set_damage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_state_set_damage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_state_set_damage(struct wlr_output_state *state, const pixman_region32_t *damage)
     * }
     */
    public static FunctionDescriptor wlr_output_state_set_damage$descriptor() {
        return wlr_output_state_set_damage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_state_set_damage(struct wlr_output_state *state, const pixman_region32_t *damage)
     * }
     */
    public static MethodHandle wlr_output_state_set_damage$handle() {
        return wlr_output_state_set_damage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_state_set_damage(struct wlr_output_state *state, const pixman_region32_t *damage)
     * }
     */
    public static MemorySegment wlr_output_state_set_damage$address() {
        return wlr_output_state_set_damage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_state_set_damage(struct wlr_output_state *state, const pixman_region32_t *damage)
     * }
     */
    public static void wlr_output_state_set_damage(MemorySegment state, MemorySegment damage) {
        var mh$ = wlr_output_state_set_damage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_state_set_damage", state, damage);
            }
            mh$.invokeExact(state, damage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_state_set_layers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_LONG
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_state_set_layers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_state_set_layers(struct wlr_output_state *state, struct wlr_output_layer_state *layers, size_t layers_len)
     * }
     */
    public static FunctionDescriptor wlr_output_state_set_layers$descriptor() {
        return wlr_output_state_set_layers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_state_set_layers(struct wlr_output_state *state, struct wlr_output_layer_state *layers, size_t layers_len)
     * }
     */
    public static MethodHandle wlr_output_state_set_layers$handle() {
        return wlr_output_state_set_layers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_state_set_layers(struct wlr_output_state *state, struct wlr_output_layer_state *layers, size_t layers_len)
     * }
     */
    public static MemorySegment wlr_output_state_set_layers$address() {
        return wlr_output_state_set_layers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_state_set_layers(struct wlr_output_state *state, struct wlr_output_layer_state *layers, size_t layers_len)
     * }
     */
    public static void wlr_output_state_set_layers(MemorySegment state, MemorySegment layers, long layers_len) {
        var mh$ = wlr_output_state_set_layers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_state_set_layers", state, layers, layers_len);
            }
            mh$.invokeExact(state, layers, layers_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_state_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_state_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_output_state_copy(struct wlr_output_state *dst, const struct wlr_output_state *src)
     * }
     */
    public static FunctionDescriptor wlr_output_state_copy$descriptor() {
        return wlr_output_state_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_output_state_copy(struct wlr_output_state *dst, const struct wlr_output_state *src)
     * }
     */
    public static MethodHandle wlr_output_state_copy$handle() {
        return wlr_output_state_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_output_state_copy(struct wlr_output_state *dst, const struct wlr_output_state *src)
     * }
     */
    public static MemorySegment wlr_output_state_copy$address() {
        return wlr_output_state_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_output_state_copy(struct wlr_output_state *dst, const struct wlr_output_state *src)
     * }
     */
    public static boolean wlr_output_state_copy(MemorySegment dst, MemorySegment src) {
        var mh$ = wlr_output_state_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_state_copy", dst, src);
            }
            return (boolean)mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_configure_primary_swapchain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_configure_primary_swapchain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_output_configure_primary_swapchain(struct wlr_output *output, const struct wlr_output_state *state, struct wlr_swapchain **swapchain)
     * }
     */
    public static FunctionDescriptor wlr_output_configure_primary_swapchain$descriptor() {
        return wlr_output_configure_primary_swapchain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_output_configure_primary_swapchain(struct wlr_output *output, const struct wlr_output_state *state, struct wlr_swapchain **swapchain)
     * }
     */
    public static MethodHandle wlr_output_configure_primary_swapchain$handle() {
        return wlr_output_configure_primary_swapchain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_output_configure_primary_swapchain(struct wlr_output *output, const struct wlr_output_state *state, struct wlr_swapchain **swapchain)
     * }
     */
    public static MemorySegment wlr_output_configure_primary_swapchain$address() {
        return wlr_output_configure_primary_swapchain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_output_configure_primary_swapchain(struct wlr_output *output, const struct wlr_output_state *state, struct wlr_swapchain **swapchain)
     * }
     */
    public static boolean wlr_output_configure_primary_swapchain(MemorySegment output, MemorySegment state, MemorySegment swapchain) {
        var mh$ = wlr_output_configure_primary_swapchain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_configure_primary_swapchain", output, state, swapchain);
            }
            return (boolean)mh$.invokeExact(output, state, swapchain);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_begin_render_pass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_begin_render_pass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_render_pass *wlr_output_begin_render_pass(struct wlr_output *output, struct wlr_output_state *state, int *buffer_age, struct wlr_render_timer *timer)
     * }
     */
    public static FunctionDescriptor wlr_output_begin_render_pass$descriptor() {
        return wlr_output_begin_render_pass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_render_pass *wlr_output_begin_render_pass(struct wlr_output *output, struct wlr_output_state *state, int *buffer_age, struct wlr_render_timer *timer)
     * }
     */
    public static MethodHandle wlr_output_begin_render_pass$handle() {
        return wlr_output_begin_render_pass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_render_pass *wlr_output_begin_render_pass(struct wlr_output *output, struct wlr_output_state *state, int *buffer_age, struct wlr_render_timer *timer)
     * }
     */
    public static MemorySegment wlr_output_begin_render_pass$address() {
        return wlr_output_begin_render_pass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_render_pass *wlr_output_begin_render_pass(struct wlr_output *output, struct wlr_output_state *state, int *buffer_age, struct wlr_render_timer *timer)
     * }
     */
    public static MemorySegment wlr_output_begin_render_pass(MemorySegment output, MemorySegment state, MemorySegment buffer_age, MemorySegment timer) {
        var mh$ = wlr_output_begin_render_pass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_begin_render_pass", output, state, buffer_age, timer);
            }
            return (MemorySegment)mh$.invokeExact(output, state, buffer_age, timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_transform_invert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_transform_invert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum wl_output_transform wlr_output_transform_invert(enum wl_output_transform tr)
     * }
     */
    public static FunctionDescriptor wlr_output_transform_invert$descriptor() {
        return wlr_output_transform_invert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum wl_output_transform wlr_output_transform_invert(enum wl_output_transform tr)
     * }
     */
    public static MethodHandle wlr_output_transform_invert$handle() {
        return wlr_output_transform_invert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum wl_output_transform wlr_output_transform_invert(enum wl_output_transform tr)
     * }
     */
    public static MemorySegment wlr_output_transform_invert$address() {
        return wlr_output_transform_invert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum wl_output_transform wlr_output_transform_invert(enum wl_output_transform tr)
     * }
     */
    public static int wlr_output_transform_invert(int tr) {
        var mh$ = wlr_output_transform_invert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_transform_invert", tr);
            }
            return (int)mh$.invokeExact(tr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_transform_compose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_transform_compose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum wl_output_transform wlr_output_transform_compose(enum wl_output_transform tr_a, enum wl_output_transform tr_b)
     * }
     */
    public static FunctionDescriptor wlr_output_transform_compose$descriptor() {
        return wlr_output_transform_compose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum wl_output_transform wlr_output_transform_compose(enum wl_output_transform tr_a, enum wl_output_transform tr_b)
     * }
     */
    public static MethodHandle wlr_output_transform_compose$handle() {
        return wlr_output_transform_compose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum wl_output_transform wlr_output_transform_compose(enum wl_output_transform tr_a, enum wl_output_transform tr_b)
     * }
     */
    public static MemorySegment wlr_output_transform_compose$address() {
        return wlr_output_transform_compose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum wl_output_transform wlr_output_transform_compose(enum wl_output_transform tr_a, enum wl_output_transform tr_b)
     * }
     */
    public static int wlr_output_transform_compose(int tr_a, int tr_b) {
        var mh$ = wlr_output_transform_compose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_transform_compose", tr_a, tr_b);
            }
            return (int)mh$.invokeExact(tr_a, tr_b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_layout_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER    );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_layout_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_output_layout *wlr_output_layout_create()
     * }
     */
    public static FunctionDescriptor wlr_output_layout_create$descriptor() {
        return wlr_output_layout_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_output_layout *wlr_output_layout_create()
     * }
     */
    public static MethodHandle wlr_output_layout_create$handle() {
        return wlr_output_layout_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_output_layout *wlr_output_layout_create()
     * }
     */
    public static MemorySegment wlr_output_layout_create$address() {
        return wlr_output_layout_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_output_layout *wlr_output_layout_create()
     * }
     */
    public static MemorySegment wlr_output_layout_create() {
        var mh$ = wlr_output_layout_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_layout_create");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_layout_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_layout_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_layout_destroy(struct wlr_output_layout *layout)
     * }
     */
    public static FunctionDescriptor wlr_output_layout_destroy$descriptor() {
        return wlr_output_layout_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_layout_destroy(struct wlr_output_layout *layout)
     * }
     */
    public static MethodHandle wlr_output_layout_destroy$handle() {
        return wlr_output_layout_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_layout_destroy(struct wlr_output_layout *layout)
     * }
     */
    public static MemorySegment wlr_output_layout_destroy$address() {
        return wlr_output_layout_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_layout_destroy(struct wlr_output_layout *layout)
     * }
     */
    public static void wlr_output_layout_destroy(MemorySegment layout) {
        var mh$ = wlr_output_layout_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_layout_destroy", layout);
            }
            mh$.invokeExact(layout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_layout_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_layout_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_output_layout_output *wlr_output_layout_get(struct wlr_output_layout *layout, struct wlr_output *reference)
     * }
     */
    public static FunctionDescriptor wlr_output_layout_get$descriptor() {
        return wlr_output_layout_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_output_layout_output *wlr_output_layout_get(struct wlr_output_layout *layout, struct wlr_output *reference)
     * }
     */
    public static MethodHandle wlr_output_layout_get$handle() {
        return wlr_output_layout_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_output_layout_output *wlr_output_layout_get(struct wlr_output_layout *layout, struct wlr_output *reference)
     * }
     */
    public static MemorySegment wlr_output_layout_get$address() {
        return wlr_output_layout_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_output_layout_output *wlr_output_layout_get(struct wlr_output_layout *layout, struct wlr_output *reference)
     * }
     */
    public static MemorySegment wlr_output_layout_get(MemorySegment layout, MemorySegment reference) {
        var mh$ = wlr_output_layout_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_layout_get", layout, reference);
            }
            return (MemorySegment)mh$.invokeExact(layout, reference);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_layout_output_at {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_layout_output_at");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_output *wlr_output_layout_output_at(struct wlr_output_layout *layout, double lx, double ly)
     * }
     */
    public static FunctionDescriptor wlr_output_layout_output_at$descriptor() {
        return wlr_output_layout_output_at.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_output *wlr_output_layout_output_at(struct wlr_output_layout *layout, double lx, double ly)
     * }
     */
    public static MethodHandle wlr_output_layout_output_at$handle() {
        return wlr_output_layout_output_at.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_output *wlr_output_layout_output_at(struct wlr_output_layout *layout, double lx, double ly)
     * }
     */
    public static MemorySegment wlr_output_layout_output_at$address() {
        return wlr_output_layout_output_at.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_output *wlr_output_layout_output_at(struct wlr_output_layout *layout, double lx, double ly)
     * }
     */
    public static MemorySegment wlr_output_layout_output_at(MemorySegment layout, double lx, double ly) {
        var mh$ = wlr_output_layout_output_at.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_layout_output_at", layout, lx, ly);
            }
            return (MemorySegment)mh$.invokeExact(layout, lx, ly);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_layout_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_layout_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_output_layout_output *wlr_output_layout_add(struct wlr_output_layout *layout, struct wlr_output *output, int lx, int ly)
     * }
     */
    public static FunctionDescriptor wlr_output_layout_add$descriptor() {
        return wlr_output_layout_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_output_layout_output *wlr_output_layout_add(struct wlr_output_layout *layout, struct wlr_output *output, int lx, int ly)
     * }
     */
    public static MethodHandle wlr_output_layout_add$handle() {
        return wlr_output_layout_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_output_layout_output *wlr_output_layout_add(struct wlr_output_layout *layout, struct wlr_output *output, int lx, int ly)
     * }
     */
    public static MemorySegment wlr_output_layout_add$address() {
        return wlr_output_layout_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_output_layout_output *wlr_output_layout_add(struct wlr_output_layout *layout, struct wlr_output *output, int lx, int ly)
     * }
     */
    public static MemorySegment wlr_output_layout_add(MemorySegment layout, MemorySegment output, int lx, int ly) {
        var mh$ = wlr_output_layout_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_layout_add", layout, output, lx, ly);
            }
            return (MemorySegment)mh$.invokeExact(layout, output, lx, ly);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_layout_add_auto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_layout_add_auto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_output_layout_output *wlr_output_layout_add_auto(struct wlr_output_layout *layout, struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_output_layout_add_auto$descriptor() {
        return wlr_output_layout_add_auto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_output_layout_output *wlr_output_layout_add_auto(struct wlr_output_layout *layout, struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_output_layout_add_auto$handle() {
        return wlr_output_layout_add_auto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_output_layout_output *wlr_output_layout_add_auto(struct wlr_output_layout *layout, struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_output_layout_add_auto$address() {
        return wlr_output_layout_add_auto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_output_layout_output *wlr_output_layout_add_auto(struct wlr_output_layout *layout, struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_output_layout_add_auto(MemorySegment layout, MemorySegment output) {
        var mh$ = wlr_output_layout_add_auto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_layout_add_auto", layout, output);
            }
            return (MemorySegment)mh$.invokeExact(layout, output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_layout_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_layout_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_layout_remove(struct wlr_output_layout *layout, struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_output_layout_remove$descriptor() {
        return wlr_output_layout_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_layout_remove(struct wlr_output_layout *layout, struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_output_layout_remove$handle() {
        return wlr_output_layout_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_layout_remove(struct wlr_output_layout *layout, struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_output_layout_remove$address() {
        return wlr_output_layout_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_layout_remove(struct wlr_output_layout *layout, struct wlr_output *output)
     * }
     */
    public static void wlr_output_layout_remove(MemorySegment layout, MemorySegment output) {
        var mh$ = wlr_output_layout_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_layout_remove", layout, output);
            }
            mh$.invokeExact(layout, output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_layout_output_coords {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_layout_output_coords");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_layout_output_coords(struct wlr_output_layout *layout, struct wlr_output *reference, double *lx, double *ly)
     * }
     */
    public static FunctionDescriptor wlr_output_layout_output_coords$descriptor() {
        return wlr_output_layout_output_coords.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_layout_output_coords(struct wlr_output_layout *layout, struct wlr_output *reference, double *lx, double *ly)
     * }
     */
    public static MethodHandle wlr_output_layout_output_coords$handle() {
        return wlr_output_layout_output_coords.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_layout_output_coords(struct wlr_output_layout *layout, struct wlr_output *reference, double *lx, double *ly)
     * }
     */
    public static MemorySegment wlr_output_layout_output_coords$address() {
        return wlr_output_layout_output_coords.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_layout_output_coords(struct wlr_output_layout *layout, struct wlr_output *reference, double *lx, double *ly)
     * }
     */
    public static void wlr_output_layout_output_coords(MemorySegment layout, MemorySegment reference, MemorySegment lx, MemorySegment ly) {
        var mh$ = wlr_output_layout_output_coords.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_layout_output_coords", layout, reference, lx, ly);
            }
            mh$.invokeExact(layout, reference, lx, ly);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_layout_contains_point {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_layout_contains_point");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_output_layout_contains_point(struct wlr_output_layout *layout, struct wlr_output *reference, int lx, int ly)
     * }
     */
    public static FunctionDescriptor wlr_output_layout_contains_point$descriptor() {
        return wlr_output_layout_contains_point.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_output_layout_contains_point(struct wlr_output_layout *layout, struct wlr_output *reference, int lx, int ly)
     * }
     */
    public static MethodHandle wlr_output_layout_contains_point$handle() {
        return wlr_output_layout_contains_point.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_output_layout_contains_point(struct wlr_output_layout *layout, struct wlr_output *reference, int lx, int ly)
     * }
     */
    public static MemorySegment wlr_output_layout_contains_point$address() {
        return wlr_output_layout_contains_point.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_output_layout_contains_point(struct wlr_output_layout *layout, struct wlr_output *reference, int lx, int ly)
     * }
     */
    public static boolean wlr_output_layout_contains_point(MemorySegment layout, MemorySegment reference, int lx, int ly) {
        var mh$ = wlr_output_layout_contains_point.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_layout_contains_point", layout, reference, lx, ly);
            }
            return (boolean)mh$.invokeExact(layout, reference, lx, ly);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_layout_intersects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_layout_intersects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_output_layout_intersects(struct wlr_output_layout *layout, struct wlr_output *reference, const struct wlr_box *target_lbox)
     * }
     */
    public static FunctionDescriptor wlr_output_layout_intersects$descriptor() {
        return wlr_output_layout_intersects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_output_layout_intersects(struct wlr_output_layout *layout, struct wlr_output *reference, const struct wlr_box *target_lbox)
     * }
     */
    public static MethodHandle wlr_output_layout_intersects$handle() {
        return wlr_output_layout_intersects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_output_layout_intersects(struct wlr_output_layout *layout, struct wlr_output *reference, const struct wlr_box *target_lbox)
     * }
     */
    public static MemorySegment wlr_output_layout_intersects$address() {
        return wlr_output_layout_intersects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_output_layout_intersects(struct wlr_output_layout *layout, struct wlr_output *reference, const struct wlr_box *target_lbox)
     * }
     */
    public static boolean wlr_output_layout_intersects(MemorySegment layout, MemorySegment reference, MemorySegment target_lbox) {
        var mh$ = wlr_output_layout_intersects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_layout_intersects", layout, reference, target_lbox);
            }
            return (boolean)mh$.invokeExact(layout, reference, target_lbox);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_layout_closest_point {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_layout_closest_point");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_layout_closest_point(struct wlr_output_layout *layout, struct wlr_output *reference, double lx, double ly, double *dest_lx, double *dest_ly)
     * }
     */
    public static FunctionDescriptor wlr_output_layout_closest_point$descriptor() {
        return wlr_output_layout_closest_point.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_layout_closest_point(struct wlr_output_layout *layout, struct wlr_output *reference, double lx, double ly, double *dest_lx, double *dest_ly)
     * }
     */
    public static MethodHandle wlr_output_layout_closest_point$handle() {
        return wlr_output_layout_closest_point.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_layout_closest_point(struct wlr_output_layout *layout, struct wlr_output *reference, double lx, double ly, double *dest_lx, double *dest_ly)
     * }
     */
    public static MemorySegment wlr_output_layout_closest_point$address() {
        return wlr_output_layout_closest_point.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_layout_closest_point(struct wlr_output_layout *layout, struct wlr_output *reference, double lx, double ly, double *dest_lx, double *dest_ly)
     * }
     */
    public static void wlr_output_layout_closest_point(MemorySegment layout, MemorySegment reference, double lx, double ly, MemorySegment dest_lx, MemorySegment dest_ly) {
        var mh$ = wlr_output_layout_closest_point.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_layout_closest_point", layout, reference, lx, ly, dest_lx, dest_ly);
            }
            mh$.invokeExact(layout, reference, lx, ly, dest_lx, dest_ly);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_layout_get_box {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_layout_get_box");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_output_layout_get_box(struct wlr_output_layout *layout, struct wlr_output *reference, struct wlr_box *dest_box)
     * }
     */
    public static FunctionDescriptor wlr_output_layout_get_box$descriptor() {
        return wlr_output_layout_get_box.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_output_layout_get_box(struct wlr_output_layout *layout, struct wlr_output *reference, struct wlr_box *dest_box)
     * }
     */
    public static MethodHandle wlr_output_layout_get_box$handle() {
        return wlr_output_layout_get_box.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_output_layout_get_box(struct wlr_output_layout *layout, struct wlr_output *reference, struct wlr_box *dest_box)
     * }
     */
    public static MemorySegment wlr_output_layout_get_box$address() {
        return wlr_output_layout_get_box.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_output_layout_get_box(struct wlr_output_layout *layout, struct wlr_output *reference, struct wlr_box *dest_box)
     * }
     */
    public static void wlr_output_layout_get_box(MemorySegment layout, MemorySegment reference, MemorySegment dest_box) {
        var mh$ = wlr_output_layout_get_box.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_layout_get_box", layout, reference, dest_box);
            }
            mh$.invokeExact(layout, reference, dest_box);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_layout_get_center_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_layout_get_center_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_output *wlr_output_layout_get_center_output(struct wlr_output_layout *layout)
     * }
     */
    public static FunctionDescriptor wlr_output_layout_get_center_output$descriptor() {
        return wlr_output_layout_get_center_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_output *wlr_output_layout_get_center_output(struct wlr_output_layout *layout)
     * }
     */
    public static MethodHandle wlr_output_layout_get_center_output$handle() {
        return wlr_output_layout_get_center_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_output *wlr_output_layout_get_center_output(struct wlr_output_layout *layout)
     * }
     */
    public static MemorySegment wlr_output_layout_get_center_output$address() {
        return wlr_output_layout_get_center_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_output *wlr_output_layout_get_center_output(struct wlr_output_layout *layout)
     * }
     */
    public static MemorySegment wlr_output_layout_get_center_output(MemorySegment layout) {
        var mh$ = wlr_output_layout_get_center_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_layout_get_center_output", layout);
            }
            return (MemorySegment)mh$.invokeExact(layout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int WLR_DIRECTION_UP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_direction.WLR_DIRECTION_UP = 1
     * }
     */
    public static int WLR_DIRECTION_UP() {
        return WLR_DIRECTION_UP;
    }
    private static final int WLR_DIRECTION_DOWN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wlr_direction.WLR_DIRECTION_DOWN = 2
     * }
     */
    public static int WLR_DIRECTION_DOWN() {
        return WLR_DIRECTION_DOWN;
    }
    private static final int WLR_DIRECTION_LEFT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum wlr_direction.WLR_DIRECTION_LEFT = 4
     * }
     */
    public static int WLR_DIRECTION_LEFT() {
        return WLR_DIRECTION_LEFT;
    }
    private static final int WLR_DIRECTION_RIGHT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum wlr_direction.WLR_DIRECTION_RIGHT = 8
     * }
     */
    public static int WLR_DIRECTION_RIGHT() {
        return WLR_DIRECTION_RIGHT;
    }

    private static class wlr_output_layout_adjacent_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_layout_adjacent_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_output *wlr_output_layout_adjacent_output(struct wlr_output_layout *layout, enum wlr_direction direction, struct wlr_output *reference, double ref_lx, double ref_ly)
     * }
     */
    public static FunctionDescriptor wlr_output_layout_adjacent_output$descriptor() {
        return wlr_output_layout_adjacent_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_output *wlr_output_layout_adjacent_output(struct wlr_output_layout *layout, enum wlr_direction direction, struct wlr_output *reference, double ref_lx, double ref_ly)
     * }
     */
    public static MethodHandle wlr_output_layout_adjacent_output$handle() {
        return wlr_output_layout_adjacent_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_output *wlr_output_layout_adjacent_output(struct wlr_output_layout *layout, enum wlr_direction direction, struct wlr_output *reference, double ref_lx, double ref_ly)
     * }
     */
    public static MemorySegment wlr_output_layout_adjacent_output$address() {
        return wlr_output_layout_adjacent_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_output *wlr_output_layout_adjacent_output(struct wlr_output_layout *layout, enum wlr_direction direction, struct wlr_output *reference, double ref_lx, double ref_ly)
     * }
     */
    public static MemorySegment wlr_output_layout_adjacent_output(MemorySegment layout, int direction, MemorySegment reference, double ref_lx, double ref_ly) {
        var mh$ = wlr_output_layout_adjacent_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_layout_adjacent_output", layout, direction, reference, ref_lx, ref_ly);
            }
            return (MemorySegment)mh$.invokeExact(layout, direction, reference, ref_lx, ref_ly);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_output_layout_farthest_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_output_layout_farthest_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_output *wlr_output_layout_farthest_output(struct wlr_output_layout *layout, enum wlr_direction direction, struct wlr_output *reference, double ref_lx, double ref_ly)
     * }
     */
    public static FunctionDescriptor wlr_output_layout_farthest_output$descriptor() {
        return wlr_output_layout_farthest_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_output *wlr_output_layout_farthest_output(struct wlr_output_layout *layout, enum wlr_direction direction, struct wlr_output *reference, double ref_lx, double ref_ly)
     * }
     */
    public static MethodHandle wlr_output_layout_farthest_output$handle() {
        return wlr_output_layout_farthest_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_output *wlr_output_layout_farthest_output(struct wlr_output_layout *layout, enum wlr_direction direction, struct wlr_output *reference, double ref_lx, double ref_ly)
     * }
     */
    public static MemorySegment wlr_output_layout_farthest_output$address() {
        return wlr_output_layout_farthest_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_output *wlr_output_layout_farthest_output(struct wlr_output_layout *layout, enum wlr_direction direction, struct wlr_output *reference, double ref_lx, double ref_ly)
     * }
     */
    public static MemorySegment wlr_output_layout_farthest_output(MemorySegment layout, int direction, MemorySegment reference, double ref_lx, double ref_ly) {
        var mh$ = wlr_output_layout_farthest_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_output_layout_farthest_output", layout, direction, reference, ref_lx, ref_ly);
            }
            return (MemorySegment)mh$.invokeExact(layout, direction, reference, ref_lx, ref_ly);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_cursor_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER    );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_cursor_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_cursor *wlr_cursor_create()
     * }
     */
    public static FunctionDescriptor wlr_cursor_create$descriptor() {
        return wlr_cursor_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_cursor *wlr_cursor_create()
     * }
     */
    public static MethodHandle wlr_cursor_create$handle() {
        return wlr_cursor_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_cursor *wlr_cursor_create()
     * }
     */
    public static MemorySegment wlr_cursor_create$address() {
        return wlr_cursor_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_cursor *wlr_cursor_create()
     * }
     */
    public static MemorySegment wlr_cursor_create() {
        var mh$ = wlr_cursor_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_cursor_create");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_cursor_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_cursor_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_cursor_destroy(struct wlr_cursor *cur)
     * }
     */
    public static FunctionDescriptor wlr_cursor_destroy$descriptor() {
        return wlr_cursor_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_cursor_destroy(struct wlr_cursor *cur)
     * }
     */
    public static MethodHandle wlr_cursor_destroy$handle() {
        return wlr_cursor_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_cursor_destroy(struct wlr_cursor *cur)
     * }
     */
    public static MemorySegment wlr_cursor_destroy$address() {
        return wlr_cursor_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_cursor_destroy(struct wlr_cursor *cur)
     * }
     */
    public static void wlr_cursor_destroy(MemorySegment cur) {
        var mh$ = wlr_cursor_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_cursor_destroy", cur);
            }
            mh$.invokeExact(cur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_cursor_warp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_cursor_warp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_cursor_warp(struct wlr_cursor *cur, struct wlr_input_device *dev, double lx, double ly)
     * }
     */
    public static FunctionDescriptor wlr_cursor_warp$descriptor() {
        return wlr_cursor_warp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_cursor_warp(struct wlr_cursor *cur, struct wlr_input_device *dev, double lx, double ly)
     * }
     */
    public static MethodHandle wlr_cursor_warp$handle() {
        return wlr_cursor_warp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_cursor_warp(struct wlr_cursor *cur, struct wlr_input_device *dev, double lx, double ly)
     * }
     */
    public static MemorySegment wlr_cursor_warp$address() {
        return wlr_cursor_warp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_cursor_warp(struct wlr_cursor *cur, struct wlr_input_device *dev, double lx, double ly)
     * }
     */
    public static boolean wlr_cursor_warp(MemorySegment cur, MemorySegment dev, double lx, double ly) {
        var mh$ = wlr_cursor_warp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_cursor_warp", cur, dev, lx, ly);
            }
            return (boolean)mh$.invokeExact(cur, dev, lx, ly);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_cursor_absolute_to_layout_coords {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_cursor_absolute_to_layout_coords");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_cursor_absolute_to_layout_coords(struct wlr_cursor *cur, struct wlr_input_device *dev, double x, double y, double *lx, double *ly)
     * }
     */
    public static FunctionDescriptor wlr_cursor_absolute_to_layout_coords$descriptor() {
        return wlr_cursor_absolute_to_layout_coords.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_cursor_absolute_to_layout_coords(struct wlr_cursor *cur, struct wlr_input_device *dev, double x, double y, double *lx, double *ly)
     * }
     */
    public static MethodHandle wlr_cursor_absolute_to_layout_coords$handle() {
        return wlr_cursor_absolute_to_layout_coords.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_cursor_absolute_to_layout_coords(struct wlr_cursor *cur, struct wlr_input_device *dev, double x, double y, double *lx, double *ly)
     * }
     */
    public static MemorySegment wlr_cursor_absolute_to_layout_coords$address() {
        return wlr_cursor_absolute_to_layout_coords.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_cursor_absolute_to_layout_coords(struct wlr_cursor *cur, struct wlr_input_device *dev, double x, double y, double *lx, double *ly)
     * }
     */
    public static void wlr_cursor_absolute_to_layout_coords(MemorySegment cur, MemorySegment dev, double x, double y, MemorySegment lx, MemorySegment ly) {
        var mh$ = wlr_cursor_absolute_to_layout_coords.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_cursor_absolute_to_layout_coords", cur, dev, x, y, lx, ly);
            }
            mh$.invokeExact(cur, dev, x, y, lx, ly);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_cursor_warp_closest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_cursor_warp_closest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_cursor_warp_closest(struct wlr_cursor *cur, struct wlr_input_device *dev, double x, double y)
     * }
     */
    public static FunctionDescriptor wlr_cursor_warp_closest$descriptor() {
        return wlr_cursor_warp_closest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_cursor_warp_closest(struct wlr_cursor *cur, struct wlr_input_device *dev, double x, double y)
     * }
     */
    public static MethodHandle wlr_cursor_warp_closest$handle() {
        return wlr_cursor_warp_closest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_cursor_warp_closest(struct wlr_cursor *cur, struct wlr_input_device *dev, double x, double y)
     * }
     */
    public static MemorySegment wlr_cursor_warp_closest$address() {
        return wlr_cursor_warp_closest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_cursor_warp_closest(struct wlr_cursor *cur, struct wlr_input_device *dev, double x, double y)
     * }
     */
    public static void wlr_cursor_warp_closest(MemorySegment cur, MemorySegment dev, double x, double y) {
        var mh$ = wlr_cursor_warp_closest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_cursor_warp_closest", cur, dev, x, y);
            }
            mh$.invokeExact(cur, dev, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_cursor_warp_absolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_cursor_warp_absolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_cursor_warp_absolute(struct wlr_cursor *cur, struct wlr_input_device *dev, double x, double y)
     * }
     */
    public static FunctionDescriptor wlr_cursor_warp_absolute$descriptor() {
        return wlr_cursor_warp_absolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_cursor_warp_absolute(struct wlr_cursor *cur, struct wlr_input_device *dev, double x, double y)
     * }
     */
    public static MethodHandle wlr_cursor_warp_absolute$handle() {
        return wlr_cursor_warp_absolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_cursor_warp_absolute(struct wlr_cursor *cur, struct wlr_input_device *dev, double x, double y)
     * }
     */
    public static MemorySegment wlr_cursor_warp_absolute$address() {
        return wlr_cursor_warp_absolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_cursor_warp_absolute(struct wlr_cursor *cur, struct wlr_input_device *dev, double x, double y)
     * }
     */
    public static void wlr_cursor_warp_absolute(MemorySegment cur, MemorySegment dev, double x, double y) {
        var mh$ = wlr_cursor_warp_absolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_cursor_warp_absolute", cur, dev, x, y);
            }
            mh$.invokeExact(cur, dev, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_cursor_move {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_cursor_move");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_cursor_move(struct wlr_cursor *cur, struct wlr_input_device *dev, double delta_x, double delta_y)
     * }
     */
    public static FunctionDescriptor wlr_cursor_move$descriptor() {
        return wlr_cursor_move.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_cursor_move(struct wlr_cursor *cur, struct wlr_input_device *dev, double delta_x, double delta_y)
     * }
     */
    public static MethodHandle wlr_cursor_move$handle() {
        return wlr_cursor_move.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_cursor_move(struct wlr_cursor *cur, struct wlr_input_device *dev, double delta_x, double delta_y)
     * }
     */
    public static MemorySegment wlr_cursor_move$address() {
        return wlr_cursor_move.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_cursor_move(struct wlr_cursor *cur, struct wlr_input_device *dev, double delta_x, double delta_y)
     * }
     */
    public static void wlr_cursor_move(MemorySegment cur, MemorySegment dev, double delta_x, double delta_y) {
        var mh$ = wlr_cursor_move.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_cursor_move", cur, dev, delta_x, delta_y);
            }
            mh$.invokeExact(cur, dev, delta_x, delta_y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_cursor_set_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_cursor_set_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_cursor_set_buffer(struct wlr_cursor *cur, struct wlr_buffer *buffer, int32_t hotspot_x, int32_t hotspot_y, float scale)
     * }
     */
    public static FunctionDescriptor wlr_cursor_set_buffer$descriptor() {
        return wlr_cursor_set_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_cursor_set_buffer(struct wlr_cursor *cur, struct wlr_buffer *buffer, int32_t hotspot_x, int32_t hotspot_y, float scale)
     * }
     */
    public static MethodHandle wlr_cursor_set_buffer$handle() {
        return wlr_cursor_set_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_cursor_set_buffer(struct wlr_cursor *cur, struct wlr_buffer *buffer, int32_t hotspot_x, int32_t hotspot_y, float scale)
     * }
     */
    public static MemorySegment wlr_cursor_set_buffer$address() {
        return wlr_cursor_set_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_cursor_set_buffer(struct wlr_cursor *cur, struct wlr_buffer *buffer, int32_t hotspot_x, int32_t hotspot_y, float scale)
     * }
     */
    public static void wlr_cursor_set_buffer(MemorySegment cur, MemorySegment buffer, int hotspot_x, int hotspot_y, float scale) {
        var mh$ = wlr_cursor_set_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_cursor_set_buffer", cur, buffer, hotspot_x, hotspot_y, scale);
            }
            mh$.invokeExact(cur, buffer, hotspot_x, hotspot_y, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_cursor_unset_image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_cursor_unset_image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_cursor_unset_image(struct wlr_cursor *cur)
     * }
     */
    public static FunctionDescriptor wlr_cursor_unset_image$descriptor() {
        return wlr_cursor_unset_image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_cursor_unset_image(struct wlr_cursor *cur)
     * }
     */
    public static MethodHandle wlr_cursor_unset_image$handle() {
        return wlr_cursor_unset_image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_cursor_unset_image(struct wlr_cursor *cur)
     * }
     */
    public static MemorySegment wlr_cursor_unset_image$address() {
        return wlr_cursor_unset_image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_cursor_unset_image(struct wlr_cursor *cur)
     * }
     */
    public static void wlr_cursor_unset_image(MemorySegment cur) {
        var mh$ = wlr_cursor_unset_image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_cursor_unset_image", cur);
            }
            mh$.invokeExact(cur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_cursor_set_xcursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_cursor_set_xcursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_cursor_set_xcursor(struct wlr_cursor *cur, struct wlr_xcursor_manager *manager, const char *name)
     * }
     */
    public static FunctionDescriptor wlr_cursor_set_xcursor$descriptor() {
        return wlr_cursor_set_xcursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_cursor_set_xcursor(struct wlr_cursor *cur, struct wlr_xcursor_manager *manager, const char *name)
     * }
     */
    public static MethodHandle wlr_cursor_set_xcursor$handle() {
        return wlr_cursor_set_xcursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_cursor_set_xcursor(struct wlr_cursor *cur, struct wlr_xcursor_manager *manager, const char *name)
     * }
     */
    public static MemorySegment wlr_cursor_set_xcursor$address() {
        return wlr_cursor_set_xcursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_cursor_set_xcursor(struct wlr_cursor *cur, struct wlr_xcursor_manager *manager, const char *name)
     * }
     */
    public static void wlr_cursor_set_xcursor(MemorySegment cur, MemorySegment manager, MemorySegment name) {
        var mh$ = wlr_cursor_set_xcursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_cursor_set_xcursor", cur, manager, name);
            }
            mh$.invokeExact(cur, manager, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_cursor_set_surface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_cursor_set_surface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_cursor_set_surface(struct wlr_cursor *cur, struct wlr_surface *surface, int32_t hotspot_x, int32_t hotspot_y)
     * }
     */
    public static FunctionDescriptor wlr_cursor_set_surface$descriptor() {
        return wlr_cursor_set_surface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_cursor_set_surface(struct wlr_cursor *cur, struct wlr_surface *surface, int32_t hotspot_x, int32_t hotspot_y)
     * }
     */
    public static MethodHandle wlr_cursor_set_surface$handle() {
        return wlr_cursor_set_surface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_cursor_set_surface(struct wlr_cursor *cur, struct wlr_surface *surface, int32_t hotspot_x, int32_t hotspot_y)
     * }
     */
    public static MemorySegment wlr_cursor_set_surface$address() {
        return wlr_cursor_set_surface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_cursor_set_surface(struct wlr_cursor *cur, struct wlr_surface *surface, int32_t hotspot_x, int32_t hotspot_y)
     * }
     */
    public static void wlr_cursor_set_surface(MemorySegment cur, MemorySegment surface, int hotspot_x, int hotspot_y) {
        var mh$ = wlr_cursor_set_surface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_cursor_set_surface", cur, surface, hotspot_x, hotspot_y);
            }
            mh$.invokeExact(cur, surface, hotspot_x, hotspot_y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_cursor_attach_input_device {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_cursor_attach_input_device");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_cursor_attach_input_device(struct wlr_cursor *cur, struct wlr_input_device *dev)
     * }
     */
    public static FunctionDescriptor wlr_cursor_attach_input_device$descriptor() {
        return wlr_cursor_attach_input_device.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_cursor_attach_input_device(struct wlr_cursor *cur, struct wlr_input_device *dev)
     * }
     */
    public static MethodHandle wlr_cursor_attach_input_device$handle() {
        return wlr_cursor_attach_input_device.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_cursor_attach_input_device(struct wlr_cursor *cur, struct wlr_input_device *dev)
     * }
     */
    public static MemorySegment wlr_cursor_attach_input_device$address() {
        return wlr_cursor_attach_input_device.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_cursor_attach_input_device(struct wlr_cursor *cur, struct wlr_input_device *dev)
     * }
     */
    public static void wlr_cursor_attach_input_device(MemorySegment cur, MemorySegment dev) {
        var mh$ = wlr_cursor_attach_input_device.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_cursor_attach_input_device", cur, dev);
            }
            mh$.invokeExact(cur, dev);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_cursor_detach_input_device {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_cursor_detach_input_device");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_cursor_detach_input_device(struct wlr_cursor *cur, struct wlr_input_device *dev)
     * }
     */
    public static FunctionDescriptor wlr_cursor_detach_input_device$descriptor() {
        return wlr_cursor_detach_input_device.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_cursor_detach_input_device(struct wlr_cursor *cur, struct wlr_input_device *dev)
     * }
     */
    public static MethodHandle wlr_cursor_detach_input_device$handle() {
        return wlr_cursor_detach_input_device.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_cursor_detach_input_device(struct wlr_cursor *cur, struct wlr_input_device *dev)
     * }
     */
    public static MemorySegment wlr_cursor_detach_input_device$address() {
        return wlr_cursor_detach_input_device.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_cursor_detach_input_device(struct wlr_cursor *cur, struct wlr_input_device *dev)
     * }
     */
    public static void wlr_cursor_detach_input_device(MemorySegment cur, MemorySegment dev) {
        var mh$ = wlr_cursor_detach_input_device.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_cursor_detach_input_device", cur, dev);
            }
            mh$.invokeExact(cur, dev);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_cursor_attach_output_layout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_cursor_attach_output_layout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_cursor_attach_output_layout(struct wlr_cursor *cur, struct wlr_output_layout *l)
     * }
     */
    public static FunctionDescriptor wlr_cursor_attach_output_layout$descriptor() {
        return wlr_cursor_attach_output_layout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_cursor_attach_output_layout(struct wlr_cursor *cur, struct wlr_output_layout *l)
     * }
     */
    public static MethodHandle wlr_cursor_attach_output_layout$handle() {
        return wlr_cursor_attach_output_layout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_cursor_attach_output_layout(struct wlr_cursor *cur, struct wlr_output_layout *l)
     * }
     */
    public static MemorySegment wlr_cursor_attach_output_layout$address() {
        return wlr_cursor_attach_output_layout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_cursor_attach_output_layout(struct wlr_cursor *cur, struct wlr_output_layout *l)
     * }
     */
    public static void wlr_cursor_attach_output_layout(MemorySegment cur, MemorySegment l) {
        var mh$ = wlr_cursor_attach_output_layout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_cursor_attach_output_layout", cur, l);
            }
            mh$.invokeExact(cur, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_cursor_map_to_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_cursor_map_to_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_cursor_map_to_output(struct wlr_cursor *cur, struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_cursor_map_to_output$descriptor() {
        return wlr_cursor_map_to_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_cursor_map_to_output(struct wlr_cursor *cur, struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_cursor_map_to_output$handle() {
        return wlr_cursor_map_to_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_cursor_map_to_output(struct wlr_cursor *cur, struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_cursor_map_to_output$address() {
        return wlr_cursor_map_to_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_cursor_map_to_output(struct wlr_cursor *cur, struct wlr_output *output)
     * }
     */
    public static void wlr_cursor_map_to_output(MemorySegment cur, MemorySegment output) {
        var mh$ = wlr_cursor_map_to_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_cursor_map_to_output", cur, output);
            }
            mh$.invokeExact(cur, output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_cursor_map_input_to_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_cursor_map_input_to_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_cursor_map_input_to_output(struct wlr_cursor *cur, struct wlr_input_device *dev, struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_cursor_map_input_to_output$descriptor() {
        return wlr_cursor_map_input_to_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_cursor_map_input_to_output(struct wlr_cursor *cur, struct wlr_input_device *dev, struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_cursor_map_input_to_output$handle() {
        return wlr_cursor_map_input_to_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_cursor_map_input_to_output(struct wlr_cursor *cur, struct wlr_input_device *dev, struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_cursor_map_input_to_output$address() {
        return wlr_cursor_map_input_to_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_cursor_map_input_to_output(struct wlr_cursor *cur, struct wlr_input_device *dev, struct wlr_output *output)
     * }
     */
    public static void wlr_cursor_map_input_to_output(MemorySegment cur, MemorySegment dev, MemorySegment output) {
        var mh$ = wlr_cursor_map_input_to_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_cursor_map_input_to_output", cur, dev, output);
            }
            mh$.invokeExact(cur, dev, output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_cursor_map_to_region {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_cursor_map_to_region");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_cursor_map_to_region(struct wlr_cursor *cur, const struct wlr_box *box)
     * }
     */
    public static FunctionDescriptor wlr_cursor_map_to_region$descriptor() {
        return wlr_cursor_map_to_region.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_cursor_map_to_region(struct wlr_cursor *cur, const struct wlr_box *box)
     * }
     */
    public static MethodHandle wlr_cursor_map_to_region$handle() {
        return wlr_cursor_map_to_region.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_cursor_map_to_region(struct wlr_cursor *cur, const struct wlr_box *box)
     * }
     */
    public static MemorySegment wlr_cursor_map_to_region$address() {
        return wlr_cursor_map_to_region.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_cursor_map_to_region(struct wlr_cursor *cur, const struct wlr_box *box)
     * }
     */
    public static void wlr_cursor_map_to_region(MemorySegment cur, MemorySegment box) {
        var mh$ = wlr_cursor_map_to_region.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_cursor_map_to_region", cur, box);
            }
            mh$.invokeExact(cur, box);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_cursor_map_input_to_region {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_cursor_map_input_to_region");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_cursor_map_input_to_region(struct wlr_cursor *cur, struct wlr_input_device *dev, const struct wlr_box *box)
     * }
     */
    public static FunctionDescriptor wlr_cursor_map_input_to_region$descriptor() {
        return wlr_cursor_map_input_to_region.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_cursor_map_input_to_region(struct wlr_cursor *cur, struct wlr_input_device *dev, const struct wlr_box *box)
     * }
     */
    public static MethodHandle wlr_cursor_map_input_to_region$handle() {
        return wlr_cursor_map_input_to_region.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_cursor_map_input_to_region(struct wlr_cursor *cur, struct wlr_input_device *dev, const struct wlr_box *box)
     * }
     */
    public static MemorySegment wlr_cursor_map_input_to_region$address() {
        return wlr_cursor_map_input_to_region.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_cursor_map_input_to_region(struct wlr_cursor *cur, struct wlr_input_device *dev, const struct wlr_box *box)
     * }
     */
    public static void wlr_cursor_map_input_to_region(MemorySegment cur, MemorySegment dev, MemorySegment box) {
        var mh$ = wlr_cursor_map_input_to_region.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_cursor_map_input_to_region", cur, dev, box);
            }
            mh$.invokeExact(cur, dev, box);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int WLR_SURFACE_STATE_BUFFER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_surface_state_field.WLR_SURFACE_STATE_BUFFER = 1
     * }
     */
    public static int WLR_SURFACE_STATE_BUFFER() {
        return WLR_SURFACE_STATE_BUFFER;
    }
    private static final int WLR_SURFACE_STATE_SURFACE_DAMAGE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wlr_surface_state_field.WLR_SURFACE_STATE_SURFACE_DAMAGE = 2
     * }
     */
    public static int WLR_SURFACE_STATE_SURFACE_DAMAGE() {
        return WLR_SURFACE_STATE_SURFACE_DAMAGE;
    }
    private static final int WLR_SURFACE_STATE_BUFFER_DAMAGE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum wlr_surface_state_field.WLR_SURFACE_STATE_BUFFER_DAMAGE = 4
     * }
     */
    public static int WLR_SURFACE_STATE_BUFFER_DAMAGE() {
        return WLR_SURFACE_STATE_BUFFER_DAMAGE;
    }
    private static final int WLR_SURFACE_STATE_OPAQUE_REGION = (int)8L;
    /**
     * {@snippet lang=c :
     * enum wlr_surface_state_field.WLR_SURFACE_STATE_OPAQUE_REGION = 8
     * }
     */
    public static int WLR_SURFACE_STATE_OPAQUE_REGION() {
        return WLR_SURFACE_STATE_OPAQUE_REGION;
    }
    private static final int WLR_SURFACE_STATE_INPUT_REGION = (int)16L;
    /**
     * {@snippet lang=c :
     * enum wlr_surface_state_field.WLR_SURFACE_STATE_INPUT_REGION = 16
     * }
     */
    public static int WLR_SURFACE_STATE_INPUT_REGION() {
        return WLR_SURFACE_STATE_INPUT_REGION;
    }
    private static final int WLR_SURFACE_STATE_TRANSFORM = (int)32L;
    /**
     * {@snippet lang=c :
     * enum wlr_surface_state_field.WLR_SURFACE_STATE_TRANSFORM = 32
     * }
     */
    public static int WLR_SURFACE_STATE_TRANSFORM() {
        return WLR_SURFACE_STATE_TRANSFORM;
    }
    private static final int WLR_SURFACE_STATE_SCALE = (int)64L;
    /**
     * {@snippet lang=c :
     * enum wlr_surface_state_field.WLR_SURFACE_STATE_SCALE = 64
     * }
     */
    public static int WLR_SURFACE_STATE_SCALE() {
        return WLR_SURFACE_STATE_SCALE;
    }
    private static final int WLR_SURFACE_STATE_FRAME_CALLBACK_LIST = (int)128L;
    /**
     * {@snippet lang=c :
     * enum wlr_surface_state_field.WLR_SURFACE_STATE_FRAME_CALLBACK_LIST = 128
     * }
     */
    public static int WLR_SURFACE_STATE_FRAME_CALLBACK_LIST() {
        return WLR_SURFACE_STATE_FRAME_CALLBACK_LIST;
    }
    private static final int WLR_SURFACE_STATE_VIEWPORT = (int)256L;
    /**
     * {@snippet lang=c :
     * enum wlr_surface_state_field.WLR_SURFACE_STATE_VIEWPORT = 256
     * }
     */
    public static int WLR_SURFACE_STATE_VIEWPORT() {
        return WLR_SURFACE_STATE_VIEWPORT;
    }
    private static final int WLR_SURFACE_STATE_OFFSET = (int)512L;
    /**
     * {@snippet lang=c :
     * enum wlr_surface_state_field.WLR_SURFACE_STATE_OFFSET = 512
     * }
     */
    public static int WLR_SURFACE_STATE_OFFSET() {
        return WLR_SURFACE_STATE_OFFSET;
    }

    private static class wlr_surface_set_role {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_set_role");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_surface_set_role(struct wlr_surface *surface, const struct wlr_surface_role *role, struct wl_resource *error_resource, uint32_t error_code)
     * }
     */
    public static FunctionDescriptor wlr_surface_set_role$descriptor() {
        return wlr_surface_set_role.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_surface_set_role(struct wlr_surface *surface, const struct wlr_surface_role *role, struct wl_resource *error_resource, uint32_t error_code)
     * }
     */
    public static MethodHandle wlr_surface_set_role$handle() {
        return wlr_surface_set_role.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_surface_set_role(struct wlr_surface *surface, const struct wlr_surface_role *role, struct wl_resource *error_resource, uint32_t error_code)
     * }
     */
    public static MemorySegment wlr_surface_set_role$address() {
        return wlr_surface_set_role.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_surface_set_role(struct wlr_surface *surface, const struct wlr_surface_role *role, struct wl_resource *error_resource, uint32_t error_code)
     * }
     */
    public static boolean wlr_surface_set_role(MemorySegment surface, MemorySegment role, MemorySegment error_resource, int error_code) {
        var mh$ = wlr_surface_set_role.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_set_role", surface, role, error_resource, error_code);
            }
            return (boolean)mh$.invokeExact(surface, role, error_resource, error_code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_set_role_object {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_set_role_object");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_surface_set_role_object(struct wlr_surface *surface, struct wl_resource *role_resource)
     * }
     */
    public static FunctionDescriptor wlr_surface_set_role_object$descriptor() {
        return wlr_surface_set_role_object.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_surface_set_role_object(struct wlr_surface *surface, struct wl_resource *role_resource)
     * }
     */
    public static MethodHandle wlr_surface_set_role_object$handle() {
        return wlr_surface_set_role_object.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_surface_set_role_object(struct wlr_surface *surface, struct wl_resource *role_resource)
     * }
     */
    public static MemorySegment wlr_surface_set_role_object$address() {
        return wlr_surface_set_role_object.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_surface_set_role_object(struct wlr_surface *surface, struct wl_resource *role_resource)
     * }
     */
    public static void wlr_surface_set_role_object(MemorySegment surface, MemorySegment role_resource) {
        var mh$ = wlr_surface_set_role_object.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_set_role_object", surface, role_resource);
            }
            mh$.invokeExact(surface, role_resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_map {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_map");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_surface_map(struct wlr_surface *surface)
     * }
     */
    public static FunctionDescriptor wlr_surface_map$descriptor() {
        return wlr_surface_map.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_surface_map(struct wlr_surface *surface)
     * }
     */
    public static MethodHandle wlr_surface_map$handle() {
        return wlr_surface_map.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_surface_map(struct wlr_surface *surface)
     * }
     */
    public static MemorySegment wlr_surface_map$address() {
        return wlr_surface_map.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_surface_map(struct wlr_surface *surface)
     * }
     */
    public static void wlr_surface_map(MemorySegment surface) {
        var mh$ = wlr_surface_map.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_map", surface);
            }
            mh$.invokeExact(surface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_unmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_unmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_surface_unmap(struct wlr_surface *surface)
     * }
     */
    public static FunctionDescriptor wlr_surface_unmap$descriptor() {
        return wlr_surface_unmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_surface_unmap(struct wlr_surface *surface)
     * }
     */
    public static MethodHandle wlr_surface_unmap$handle() {
        return wlr_surface_unmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_surface_unmap(struct wlr_surface *surface)
     * }
     */
    public static MemorySegment wlr_surface_unmap$address() {
        return wlr_surface_unmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_surface_unmap(struct wlr_surface *surface)
     * }
     */
    public static void wlr_surface_unmap(MemorySegment surface) {
        var mh$ = wlr_surface_unmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_unmap", surface);
            }
            mh$.invokeExact(surface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_has_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_has_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_surface_has_buffer(struct wlr_surface *surface)
     * }
     */
    public static FunctionDescriptor wlr_surface_has_buffer$descriptor() {
        return wlr_surface_has_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_surface_has_buffer(struct wlr_surface *surface)
     * }
     */
    public static MethodHandle wlr_surface_has_buffer$handle() {
        return wlr_surface_has_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_surface_has_buffer(struct wlr_surface *surface)
     * }
     */
    public static MemorySegment wlr_surface_has_buffer$address() {
        return wlr_surface_has_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_surface_has_buffer(struct wlr_surface *surface)
     * }
     */
    public static boolean wlr_surface_has_buffer(MemorySegment surface) {
        var mh$ = wlr_surface_has_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_has_buffer", surface);
            }
            return (boolean)mh$.invokeExact(surface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_get_texture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_get_texture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_texture *wlr_surface_get_texture(struct wlr_surface *surface)
     * }
     */
    public static FunctionDescriptor wlr_surface_get_texture$descriptor() {
        return wlr_surface_get_texture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_texture *wlr_surface_get_texture(struct wlr_surface *surface)
     * }
     */
    public static MethodHandle wlr_surface_get_texture$handle() {
        return wlr_surface_get_texture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_texture *wlr_surface_get_texture(struct wlr_surface *surface)
     * }
     */
    public static MemorySegment wlr_surface_get_texture$address() {
        return wlr_surface_get_texture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_texture *wlr_surface_get_texture(struct wlr_surface *surface)
     * }
     */
    public static MemorySegment wlr_surface_get_texture(MemorySegment surface) {
        var mh$ = wlr_surface_get_texture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_get_texture", surface);
            }
            return (MemorySegment)mh$.invokeExact(surface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_get_root_surface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_get_root_surface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_surface *wlr_surface_get_root_surface(struct wlr_surface *surface)
     * }
     */
    public static FunctionDescriptor wlr_surface_get_root_surface$descriptor() {
        return wlr_surface_get_root_surface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_surface *wlr_surface_get_root_surface(struct wlr_surface *surface)
     * }
     */
    public static MethodHandle wlr_surface_get_root_surface$handle() {
        return wlr_surface_get_root_surface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_surface *wlr_surface_get_root_surface(struct wlr_surface *surface)
     * }
     */
    public static MemorySegment wlr_surface_get_root_surface$address() {
        return wlr_surface_get_root_surface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_surface *wlr_surface_get_root_surface(struct wlr_surface *surface)
     * }
     */
    public static MemorySegment wlr_surface_get_root_surface(MemorySegment surface) {
        var mh$ = wlr_surface_get_root_surface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_get_root_surface", surface);
            }
            return (MemorySegment)mh$.invokeExact(surface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_point_accepts_input {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_point_accepts_input");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_surface_point_accepts_input(struct wlr_surface *surface, double sx, double sy)
     * }
     */
    public static FunctionDescriptor wlr_surface_point_accepts_input$descriptor() {
        return wlr_surface_point_accepts_input.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_surface_point_accepts_input(struct wlr_surface *surface, double sx, double sy)
     * }
     */
    public static MethodHandle wlr_surface_point_accepts_input$handle() {
        return wlr_surface_point_accepts_input.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_surface_point_accepts_input(struct wlr_surface *surface, double sx, double sy)
     * }
     */
    public static MemorySegment wlr_surface_point_accepts_input$address() {
        return wlr_surface_point_accepts_input.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_surface_point_accepts_input(struct wlr_surface *surface, double sx, double sy)
     * }
     */
    public static boolean wlr_surface_point_accepts_input(MemorySegment surface, double sx, double sy) {
        var mh$ = wlr_surface_point_accepts_input.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_point_accepts_input", surface, sx, sy);
            }
            return (boolean)mh$.invokeExact(surface, sx, sy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_surface_at {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_surface_at");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_surface *wlr_surface_surface_at(struct wlr_surface *surface, double sx, double sy, double *sub_x, double *sub_y)
     * }
     */
    public static FunctionDescriptor wlr_surface_surface_at$descriptor() {
        return wlr_surface_surface_at.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_surface *wlr_surface_surface_at(struct wlr_surface *surface, double sx, double sy, double *sub_x, double *sub_y)
     * }
     */
    public static MethodHandle wlr_surface_surface_at$handle() {
        return wlr_surface_surface_at.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_surface *wlr_surface_surface_at(struct wlr_surface *surface, double sx, double sy, double *sub_x, double *sub_y)
     * }
     */
    public static MemorySegment wlr_surface_surface_at$address() {
        return wlr_surface_surface_at.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_surface *wlr_surface_surface_at(struct wlr_surface *surface, double sx, double sy, double *sub_x, double *sub_y)
     * }
     */
    public static MemorySegment wlr_surface_surface_at(MemorySegment surface, double sx, double sy, MemorySegment sub_x, MemorySegment sub_y) {
        var mh$ = wlr_surface_surface_at.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_surface_at", surface, sx, sy, sub_x, sub_y);
            }
            return (MemorySegment)mh$.invokeExact(surface, sx, sy, sub_x, sub_y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_send_enter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_send_enter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_surface_send_enter(struct wlr_surface *surface, struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_surface_send_enter$descriptor() {
        return wlr_surface_send_enter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_surface_send_enter(struct wlr_surface *surface, struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_surface_send_enter$handle() {
        return wlr_surface_send_enter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_surface_send_enter(struct wlr_surface *surface, struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_surface_send_enter$address() {
        return wlr_surface_send_enter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_surface_send_enter(struct wlr_surface *surface, struct wlr_output *output)
     * }
     */
    public static void wlr_surface_send_enter(MemorySegment surface, MemorySegment output) {
        var mh$ = wlr_surface_send_enter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_send_enter", surface, output);
            }
            mh$.invokeExact(surface, output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_send_leave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_send_leave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_surface_send_leave(struct wlr_surface *surface, struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_surface_send_leave$descriptor() {
        return wlr_surface_send_leave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_surface_send_leave(struct wlr_surface *surface, struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_surface_send_leave$handle() {
        return wlr_surface_send_leave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_surface_send_leave(struct wlr_surface *surface, struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_surface_send_leave$address() {
        return wlr_surface_send_leave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_surface_send_leave(struct wlr_surface *surface, struct wlr_output *output)
     * }
     */
    public static void wlr_surface_send_leave(MemorySegment surface, MemorySegment output) {
        var mh$ = wlr_surface_send_leave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_send_leave", surface, output);
            }
            mh$.invokeExact(surface, output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_send_frame_done {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_send_frame_done");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_surface_send_frame_done(struct wlr_surface *surface, const struct timespec *when)
     * }
     */
    public static FunctionDescriptor wlr_surface_send_frame_done$descriptor() {
        return wlr_surface_send_frame_done.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_surface_send_frame_done(struct wlr_surface *surface, const struct timespec *when)
     * }
     */
    public static MethodHandle wlr_surface_send_frame_done$handle() {
        return wlr_surface_send_frame_done.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_surface_send_frame_done(struct wlr_surface *surface, const struct timespec *when)
     * }
     */
    public static MemorySegment wlr_surface_send_frame_done$address() {
        return wlr_surface_send_frame_done.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_surface_send_frame_done(struct wlr_surface *surface, const struct timespec *when)
     * }
     */
    public static void wlr_surface_send_frame_done(MemorySegment surface, MemorySegment when) {
        var mh$ = wlr_surface_send_frame_done.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_send_frame_done", surface, when);
            }
            mh$.invokeExact(surface, when);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_get_extends {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_get_extends");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_surface_get_extends(struct wlr_surface *surface, struct wlr_box *box)
     * }
     */
    public static FunctionDescriptor wlr_surface_get_extends$descriptor() {
        return wlr_surface_get_extends.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_surface_get_extends(struct wlr_surface *surface, struct wlr_box *box)
     * }
     */
    public static MethodHandle wlr_surface_get_extends$handle() {
        return wlr_surface_get_extends.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_surface_get_extends(struct wlr_surface *surface, struct wlr_box *box)
     * }
     */
    public static MemorySegment wlr_surface_get_extends$address() {
        return wlr_surface_get_extends.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_surface_get_extends(struct wlr_surface *surface, struct wlr_box *box)
     * }
     */
    public static void wlr_surface_get_extends(MemorySegment surface, MemorySegment box) {
        var mh$ = wlr_surface_get_extends.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_get_extends", surface, box);
            }
            mh$.invokeExact(surface, box);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_from_resource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_from_resource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_surface *wlr_surface_from_resource(struct wl_resource *resource)
     * }
     */
    public static FunctionDescriptor wlr_surface_from_resource$descriptor() {
        return wlr_surface_from_resource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_surface *wlr_surface_from_resource(struct wl_resource *resource)
     * }
     */
    public static MethodHandle wlr_surface_from_resource$handle() {
        return wlr_surface_from_resource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_surface *wlr_surface_from_resource(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wlr_surface_from_resource$address() {
        return wlr_surface_from_resource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_surface *wlr_surface_from_resource(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wlr_surface_from_resource(MemorySegment resource) {
        var mh$ = wlr_surface_from_resource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_from_resource", resource);
            }
            return (MemorySegment)mh$.invokeExact(resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_for_each_surface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_for_each_surface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_surface_for_each_surface(struct wlr_surface *surface, wlr_surface_iterator_func_t iterator, void *user_data)
     * }
     */
    public static FunctionDescriptor wlr_surface_for_each_surface$descriptor() {
        return wlr_surface_for_each_surface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_surface_for_each_surface(struct wlr_surface *surface, wlr_surface_iterator_func_t iterator, void *user_data)
     * }
     */
    public static MethodHandle wlr_surface_for_each_surface$handle() {
        return wlr_surface_for_each_surface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_surface_for_each_surface(struct wlr_surface *surface, wlr_surface_iterator_func_t iterator, void *user_data)
     * }
     */
    public static MemorySegment wlr_surface_for_each_surface$address() {
        return wlr_surface_for_each_surface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_surface_for_each_surface(struct wlr_surface *surface, wlr_surface_iterator_func_t iterator, void *user_data)
     * }
     */
    public static void wlr_surface_for_each_surface(MemorySegment surface, MemorySegment iterator, MemorySegment user_data) {
        var mh$ = wlr_surface_for_each_surface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_for_each_surface", surface, iterator, user_data);
            }
            mh$.invokeExact(surface, iterator, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_get_effective_damage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_get_effective_damage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_surface_get_effective_damage(struct wlr_surface *surface, pixman_region32_t *damage)
     * }
     */
    public static FunctionDescriptor wlr_surface_get_effective_damage$descriptor() {
        return wlr_surface_get_effective_damage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_surface_get_effective_damage(struct wlr_surface *surface, pixman_region32_t *damage)
     * }
     */
    public static MethodHandle wlr_surface_get_effective_damage$handle() {
        return wlr_surface_get_effective_damage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_surface_get_effective_damage(struct wlr_surface *surface, pixman_region32_t *damage)
     * }
     */
    public static MemorySegment wlr_surface_get_effective_damage$address() {
        return wlr_surface_get_effective_damage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_surface_get_effective_damage(struct wlr_surface *surface, pixman_region32_t *damage)
     * }
     */
    public static void wlr_surface_get_effective_damage(MemorySegment surface, MemorySegment damage) {
        var mh$ = wlr_surface_get_effective_damage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_get_effective_damage", surface, damage);
            }
            mh$.invokeExact(surface, damage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_get_buffer_source_box {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_get_buffer_source_box");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_surface_get_buffer_source_box(struct wlr_surface *surface, struct wlr_fbox *box)
     * }
     */
    public static FunctionDescriptor wlr_surface_get_buffer_source_box$descriptor() {
        return wlr_surface_get_buffer_source_box.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_surface_get_buffer_source_box(struct wlr_surface *surface, struct wlr_fbox *box)
     * }
     */
    public static MethodHandle wlr_surface_get_buffer_source_box$handle() {
        return wlr_surface_get_buffer_source_box.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_surface_get_buffer_source_box(struct wlr_surface *surface, struct wlr_fbox *box)
     * }
     */
    public static MemorySegment wlr_surface_get_buffer_source_box$address() {
        return wlr_surface_get_buffer_source_box.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_surface_get_buffer_source_box(struct wlr_surface *surface, struct wlr_fbox *box)
     * }
     */
    public static void wlr_surface_get_buffer_source_box(MemorySegment surface, MemorySegment box) {
        var mh$ = wlr_surface_get_buffer_source_box.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_get_buffer_source_box", surface, box);
            }
            mh$.invokeExact(surface, box);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_lock_pending {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_lock_pending");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t wlr_surface_lock_pending(struct wlr_surface *surface)
     * }
     */
    public static FunctionDescriptor wlr_surface_lock_pending$descriptor() {
        return wlr_surface_lock_pending.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t wlr_surface_lock_pending(struct wlr_surface *surface)
     * }
     */
    public static MethodHandle wlr_surface_lock_pending$handle() {
        return wlr_surface_lock_pending.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t wlr_surface_lock_pending(struct wlr_surface *surface)
     * }
     */
    public static MemorySegment wlr_surface_lock_pending$address() {
        return wlr_surface_lock_pending.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t wlr_surface_lock_pending(struct wlr_surface *surface)
     * }
     */
    public static int wlr_surface_lock_pending(MemorySegment surface) {
        var mh$ = wlr_surface_lock_pending.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_lock_pending", surface);
            }
            return (int)mh$.invokeExact(surface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_unlock_cached {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_unlock_cached");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_surface_unlock_cached(struct wlr_surface *surface, uint32_t seq)
     * }
     */
    public static FunctionDescriptor wlr_surface_unlock_cached$descriptor() {
        return wlr_surface_unlock_cached.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_surface_unlock_cached(struct wlr_surface *surface, uint32_t seq)
     * }
     */
    public static MethodHandle wlr_surface_unlock_cached$handle() {
        return wlr_surface_unlock_cached.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_surface_unlock_cached(struct wlr_surface *surface, uint32_t seq)
     * }
     */
    public static MemorySegment wlr_surface_unlock_cached$address() {
        return wlr_surface_unlock_cached.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_surface_unlock_cached(struct wlr_surface *surface, uint32_t seq)
     * }
     */
    public static void wlr_surface_unlock_cached(MemorySegment surface, int seq) {
        var mh$ = wlr_surface_unlock_cached.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_unlock_cached", surface, seq);
            }
            mh$.invokeExact(surface, seq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_set_preferred_buffer_scale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_set_preferred_buffer_scale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_surface_set_preferred_buffer_scale(struct wlr_surface *surface, int32_t scale)
     * }
     */
    public static FunctionDescriptor wlr_surface_set_preferred_buffer_scale$descriptor() {
        return wlr_surface_set_preferred_buffer_scale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_surface_set_preferred_buffer_scale(struct wlr_surface *surface, int32_t scale)
     * }
     */
    public static MethodHandle wlr_surface_set_preferred_buffer_scale$handle() {
        return wlr_surface_set_preferred_buffer_scale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_surface_set_preferred_buffer_scale(struct wlr_surface *surface, int32_t scale)
     * }
     */
    public static MemorySegment wlr_surface_set_preferred_buffer_scale$address() {
        return wlr_surface_set_preferred_buffer_scale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_surface_set_preferred_buffer_scale(struct wlr_surface *surface, int32_t scale)
     * }
     */
    public static void wlr_surface_set_preferred_buffer_scale(MemorySegment surface, int scale) {
        var mh$ = wlr_surface_set_preferred_buffer_scale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_set_preferred_buffer_scale", surface, scale);
            }
            mh$.invokeExact(surface, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_set_preferred_buffer_transform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_set_preferred_buffer_transform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_surface_set_preferred_buffer_transform(struct wlr_surface *surface, enum wl_output_transform transform)
     * }
     */
    public static FunctionDescriptor wlr_surface_set_preferred_buffer_transform$descriptor() {
        return wlr_surface_set_preferred_buffer_transform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_surface_set_preferred_buffer_transform(struct wlr_surface *surface, enum wl_output_transform transform)
     * }
     */
    public static MethodHandle wlr_surface_set_preferred_buffer_transform$handle() {
        return wlr_surface_set_preferred_buffer_transform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_surface_set_preferred_buffer_transform(struct wlr_surface *surface, enum wl_output_transform transform)
     * }
     */
    public static MemorySegment wlr_surface_set_preferred_buffer_transform$address() {
        return wlr_surface_set_preferred_buffer_transform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_surface_set_preferred_buffer_transform(struct wlr_surface *surface, enum wl_output_transform transform)
     * }
     */
    public static void wlr_surface_set_preferred_buffer_transform(MemorySegment surface, int transform) {
        var mh$ = wlr_surface_set_preferred_buffer_transform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_set_preferred_buffer_transform", surface, transform);
            }
            mh$.invokeExact(surface, transform);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_compositor_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_compositor_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_compositor *wlr_compositor_create(struct wl_display *display, uint32_t version, struct wlr_renderer *renderer)
     * }
     */
    public static FunctionDescriptor wlr_compositor_create$descriptor() {
        return wlr_compositor_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_compositor *wlr_compositor_create(struct wl_display *display, uint32_t version, struct wlr_renderer *renderer)
     * }
     */
    public static MethodHandle wlr_compositor_create$handle() {
        return wlr_compositor_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_compositor *wlr_compositor_create(struct wl_display *display, uint32_t version, struct wlr_renderer *renderer)
     * }
     */
    public static MemorySegment wlr_compositor_create$address() {
        return wlr_compositor_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_compositor *wlr_compositor_create(struct wl_display *display, uint32_t version, struct wlr_renderer *renderer)
     * }
     */
    public static MemorySegment wlr_compositor_create(MemorySegment display, int version, MemorySegment renderer) {
        var mh$ = wlr_compositor_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_compositor_create", display, version, renderer);
            }
            return (MemorySegment)mh$.invokeExact(display, version, renderer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int WLR_BUTTON_RELEASED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wlr_button_state.WLR_BUTTON_RELEASED = 0
     * }
     */
    public static int WLR_BUTTON_RELEASED() {
        return WLR_BUTTON_RELEASED;
    }
    private static final int WLR_BUTTON_PRESSED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_button_state.WLR_BUTTON_PRESSED = 1
     * }
     */
    public static int WLR_BUTTON_PRESSED() {
        return WLR_BUTTON_PRESSED;
    }
    private static final int WLR_INPUT_DEVICE_KEYBOARD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wlr_input_device_type.WLR_INPUT_DEVICE_KEYBOARD = 0
     * }
     */
    public static int WLR_INPUT_DEVICE_KEYBOARD() {
        return WLR_INPUT_DEVICE_KEYBOARD;
    }
    private static final int WLR_INPUT_DEVICE_POINTER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_input_device_type.WLR_INPUT_DEVICE_POINTER = 1
     * }
     */
    public static int WLR_INPUT_DEVICE_POINTER() {
        return WLR_INPUT_DEVICE_POINTER;
    }
    private static final int WLR_INPUT_DEVICE_TOUCH = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wlr_input_device_type.WLR_INPUT_DEVICE_TOUCH = 2
     * }
     */
    public static int WLR_INPUT_DEVICE_TOUCH() {
        return WLR_INPUT_DEVICE_TOUCH;
    }
    private static final int WLR_INPUT_DEVICE_TABLET_TOOL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum wlr_input_device_type.WLR_INPUT_DEVICE_TABLET_TOOL = 3
     * }
     */
    public static int WLR_INPUT_DEVICE_TABLET_TOOL() {
        return WLR_INPUT_DEVICE_TABLET_TOOL;
    }
    private static final int WLR_INPUT_DEVICE_TABLET_PAD = (int)4L;
    /**
     * {@snippet lang=c :
     * enum wlr_input_device_type.WLR_INPUT_DEVICE_TABLET_PAD = 4
     * }
     */
    public static int WLR_INPUT_DEVICE_TABLET_PAD() {
        return WLR_INPUT_DEVICE_TABLET_PAD;
    }
    private static final int WLR_INPUT_DEVICE_SWITCH = (int)5L;
    /**
     * {@snippet lang=c :
     * enum wlr_input_device_type.WLR_INPUT_DEVICE_SWITCH = 5
     * }
     */
    public static int WLR_INPUT_DEVICE_SWITCH() {
        return WLR_INPUT_DEVICE_SWITCH;
    }

    private static class stdin$constants {
        public static final AddressLayout LAYOUT = C.C_POINTER;
        public static final MemorySegment SEGMENT = C.findOrThrow("stdin").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static AddressLayout stdin$layout() {
        return stdin$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin$segment() {
        return stdin$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin() {
        return stdin$constants.SEGMENT.get(stdin$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static void stdin(MemorySegment varValue) {
        stdin$constants.SEGMENT.set(stdin$constants.LAYOUT, 0L, varValue);
    }

    private static class stdout$constants {
        public static final AddressLayout LAYOUT = C.C_POINTER;
        public static final MemorySegment SEGMENT = C.findOrThrow("stdout").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static AddressLayout stdout$layout() {
        return stdout$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout$segment() {
        return stdout$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout() {
        return stdout$constants.SEGMENT.get(stdout$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static void stdout(MemorySegment varValue) {
        stdout$constants.SEGMENT.set(stdout$constants.LAYOUT, 0L, varValue);
    }

    private static class stderr$constants {
        public static final AddressLayout LAYOUT = C.C_POINTER;
        public static final MemorySegment SEGMENT = C.findOrThrow("stderr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static AddressLayout stderr$layout() {
        return stderr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr$segment() {
        return stderr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr() {
        return stderr$constants.SEGMENT.get(stderr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static void stderr(MemorySegment varValue) {
        stderr$constants.SEGMENT.set(stderr$constants.LAYOUT, 0L, varValue);
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static int remove(MemorySegment __filename) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", __filename);
            }
            return (int)mh$.invokeExact(__filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("renameat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MemorySegment renameat$address() {
        return renameat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static int renameat(int __oldfd, MemorySegment __old, int __newfd, MemorySegment __new) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", __oldfd, __old, __newfd, __new);
            }
            return (int)mh$.invokeExact(__oldfd, __old, __newfd, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static int fclose(MemorySegment __stream) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER    );

        public static final MemorySegment ADDR = C.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam(MemorySegment x0) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("tmpnam_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static FunctionDescriptor tmpnam_r$descriptor() {
        return tmpnam_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MethodHandle tmpnam_r$handle() {
        return tmpnam_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r$address() {
        return tmpnam_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r(MemorySegment __s) {
        var mh$ = tmpnam_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam_r", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __pfx) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __pfx);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __pfx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static int fflush(MemorySegment __stream) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fflush_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush_unlocked$descriptor() {
        return fflush_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fflush_unlocked$handle() {
        return fflush_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fflush_unlocked$address() {
        return fflush_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static int fflush_unlocked(MemorySegment __stream) {
        var mh$ = fflush_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __modes) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen(MemorySegment __filename, MemorySegment __modes, MemorySegment __stream) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", __filename, __modes, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen(int __fd, MemorySegment __modes) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", __fd, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__fd, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopencookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            _IO_cookie_io_functions_t.layout()
        );

        public static final MemorySegment ADDR = C.findOrThrow("fopencookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static FunctionDescriptor fopencookie$descriptor() {
        return fopencookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MethodHandle fopencookie$handle() {
        return fopencookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MemorySegment fopencookie$address() {
        return fopencookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MemorySegment fopencookie(MemorySegment __magic_cookie, MemorySegment __modes, MemorySegment __io_funcs) {
        var mh$ = fopencookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopencookie", __magic_cookie, __modes, __io_funcs);
            }
            return (MemorySegment)mh$.invokeExact(__magic_cookie, __modes, __io_funcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_LONG,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fmemopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen$address() {
        return fmemopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __s, long __len, MemorySegment __modes) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __s, __len, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__s, __len, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("open_memstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream$address() {
        return open_memstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufloc, MemorySegment __sizeloc) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufloc, __sizeloc);
            }
            return (MemorySegment)mh$.invokeExact(__bufloc, __sizeloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static void setbuf(MemorySegment __stream, MemorySegment __buf) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", __stream, __buf);
            }
            mh$.invokeExact(__stream, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_LONG
        );

        public static final MemorySegment ADDR = C.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static int setvbuf(MemorySegment __stream, MemorySegment __buf, int __modes, long __n) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", __stream, __buf, __modes, __n);
            }
            return (int)mh$.invokeExact(__stream, __buf, __modes, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_LONG
        );

        public static final MemorySegment ADDR = C.findOrThrow("setbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MemorySegment setbuffer$address() {
        return setbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static void setbuffer(MemorySegment __stream, MemorySegment __buf, long __size) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", __stream, __buf, __size);
            }
            mh$.invokeExact(__stream, __buf, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("setlinebuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MemorySegment setlinebuf$address() {
        return setlinebuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static void setlinebuf(MemorySegment __stream) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                C.C_INT,
                C.C_POINTER,
                C.C_POINTER
            );
        private static final MemorySegment ADDR = C.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", __stream, __format, x2);
                }
                return (int) spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int printf(const char *restrict __format, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                C.C_INT,
                C.C_POINTER
            );
        private static final MemorySegment ADDR = C.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int printf(const char *restrict __format, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", __format, x1);
                }
                return (int) spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                C.C_INT,
                C.C_POINTER,
                C.C_POINTER
            );
        private static final MemorySegment ADDR = C.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", __s, __format, x2);
                }
                return (int) spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfprintf$descriptor() {
        return vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfprintf$handle() {
        return vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfprintf$address() {
        return vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vprintf$descriptor() {
        return vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vprintf$handle() {
        return vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vprintf$address() {
        return vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vprintf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vprintf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsprintf$descriptor() {
        return vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsprintf$handle() {
        return vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsprintf$address() {
        return vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                C.C_INT,
                C.C_POINTER,
                C.C_LONG,
                C.C_POINTER
            );
        private static final MemorySegment ADDR = C.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, long __maxlen, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __s, __maxlen, __format, x3);
                }
                return (int) spreader.invokeExact(__s, __maxlen, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_LONG,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsnprintf$descriptor() {
        return vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsnprintf$handle() {
        return vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsnprintf$address() {
        return vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsnprintf(MemorySegment __s, long __maxlen, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsnprintf", __s, __maxlen, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __maxlen, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vasprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("vasprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vasprintf$descriptor() {
        return vasprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vasprintf$handle() {
        return vasprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vasprintf$address() {
        return vasprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static int vasprintf(MemorySegment __ptr, MemorySegment __f, MemorySegment __arg) {
        var mh$ = vasprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vasprintf", __ptr, __f, __arg);
            }
            return (int)mh$.invokeExact(__ptr, __f, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int __asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
     * }
     */
    public static class __asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                C.C_INT,
                C.C_POINTER,
                C.C_POINTER
            );
        private static final MemorySegment ADDR = C.findOrThrow("__asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int __asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
         * }
         */
        public static __asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __ptr, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__asprintf", __ptr, __fmt, x2);
                }
                return (int) spreader.invokeExact(__ptr, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
     * }
     */
    public static class asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                C.C_INT,
                C.C_POINTER,
                C.C_POINTER
            );
        private static final MemorySegment ADDR = C.findOrThrow("asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
         * }
         */
        public static asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __ptr, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("asprintf", __ptr, __fmt, x2);
                }
                return (int) spreader.invokeExact(__ptr, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vdprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("vdprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vdprintf$descriptor() {
        return vdprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vdprintf$handle() {
        return vdprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vdprintf$address() {
        return vdprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static int vdprintf(int __fd, MemorySegment __fmt, MemorySegment __arg) {
        var mh$ = vdprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vdprintf", __fd, __fmt, __arg);
            }
            return (int)mh$.invokeExact(__fd, __fmt, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int dprintf(int __fd, const char *restrict __fmt, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                C.C_INT,
                C.C_INT,
                C.C_POINTER
            );
        private static final MemorySegment ADDR = C.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int dprintf(int __fd, const char *restrict __fmt, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int __fd, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", __fd, __fmt, x2);
                }
                return (int) spreader.invokeExact(__fd, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                C.C_INT,
                C.C_POINTER,
                C.C_POINTER
            );
        private static final MemorySegment ADDR = C.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", __stream, __format, x2);
                }
                return (int) spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int scanf(const char *restrict __format, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                C.C_INT,
                C.C_POINTER
            );
        private static final MemorySegment ADDR = C.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int scanf(const char *restrict __format, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", __format, x1);
                }
                return (int) spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                C.C_INT,
                C.C_POINTER,
                C.C_POINTER
            );
        private static final MemorySegment ADDR = C.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", __s, __format, x2);
                }
                return (int) spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfscanf$descriptor() {
        return vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfscanf$handle() {
        return vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfscanf$address() {
        return vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("vscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vscanf$descriptor() {
        return vscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vscanf$handle() {
        return vscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vscanf$address() {
        return vscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vscanf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vscanf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsscanf$descriptor() {
        return vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsscanf$handle() {
        return vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsscanf$address() {
        return vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static int fgetc(MemorySegment __stream) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static int getc(MemorySegment __stream) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT    );

        public static final MemorySegment ADDR = C.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("getc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment getc_unlocked$address() {
        return getc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static int getc_unlocked(MemorySegment __stream) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT    );

        public static final MemorySegment ADDR = C.findOrThrow("getchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MemorySegment getchar_unlocked$address() {
        return getchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fgetc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc_unlocked$descriptor() {
        return fgetc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc_unlocked$handle() {
        return fgetc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc_unlocked$address() {
        return fgetc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static int fgetc_unlocked(MemorySegment __stream) {
        var mh$ = fgetc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static int fputc(int __c, MemorySegment __stream) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static int putc(int __c, MemorySegment __stream) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static int putchar(int __c) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fputc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc_unlocked$descriptor() {
        return fputc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc_unlocked$handle() {
        return fputc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc_unlocked$address() {
        return fputc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int fputc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = fputc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("putc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc_unlocked$address() {
        return putc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int putc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("putchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MemorySegment putchar_unlocked$address() {
        return putchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static int putchar_unlocked(int __c) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static int getw(MemorySegment __stream) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static int putw(int __w, MemorySegment __stream) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", __w, __stream);
            }
            return (int)mh$.invokeExact(__w, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets(MemorySegment __s, int __n, MemorySegment __stream) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", __s, __n, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__s, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("__getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor __getdelim$descriptor() {
        return __getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle __getdelim$handle() {
        return __getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment __getdelim$address() {
        return __getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long __getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = __getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getdelim$address() {
        return getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("getline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getline$address() {
        return getline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __lineptr, MemorySegment __n, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __lineptr, __n, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static int fputs(MemorySegment __s, MemorySegment __stream) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", __s, __stream);
            }
            return (int)mh$.invokeExact(__s, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static int puts(MemorySegment __s) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", __s);
            }
            return (int)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static int ungetc(int __c, MemorySegment __stream) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER,
            C.C_LONG,
            C.C_LONG,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER,
            C.C_LONG,
            C.C_LONG,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __n, MemorySegment __s) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __n, __s);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER,
            C.C_LONG,
            C.C_LONG,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fread_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread_unlocked$descriptor() {
        return fread_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread_unlocked$handle() {
        return fread_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread_unlocked$address() {
        return fread_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER,
            C.C_LONG,
            C.C_LONG,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fwrite_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fwrite_unlocked$descriptor() {
        return fwrite_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fwrite_unlocked$handle() {
        return fwrite_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fwrite_unlocked$address() {
        return fwrite_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fwrite_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fwrite_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_LONG,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static int fseek(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static long ftell(MemorySegment __stream) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static void rewind(MemorySegment __stream) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_LONG,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("fseeko");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MemorySegment fseeko$address() {
        return fseeko.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("ftello");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MemorySegment ftello$address() {
        return ftello.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static int fgetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static int fsetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static void clearerr(MemorySegment __stream) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static int feof(MemorySegment __stream) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static int ferror(MemorySegment __stream) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("clearerr_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr_unlocked$descriptor() {
        return clearerr_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr_unlocked$handle() {
        return clearerr_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr_unlocked$address() {
        return clearerr_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static void clearerr_unlocked(MemorySegment __stream) {
        var mh$ = clearerr_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr_unlocked", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("feof_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof_unlocked$descriptor() {
        return feof_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle feof_unlocked$handle() {
        return feof_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment feof_unlocked$address() {
        return feof_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static int feof_unlocked(MemorySegment __stream) {
        var mh$ = feof_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("ferror_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror_unlocked$descriptor() {
        return ferror_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle ferror_unlocked$handle() {
        return ferror_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment ferror_unlocked$address() {
        return ferror_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static int ferror_unlocked(MemorySegment __stream) {
        var mh$ = ferror_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static void perror(MemorySegment __s) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", __s);
            }
            mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static int fileno(MemorySegment __stream) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fileno_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno_unlocked$descriptor() {
        return fileno_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fileno_unlocked$handle() {
        return fileno_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fileno_unlocked$address() {
        return fileno_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static int fileno_unlocked(MemorySegment __stream) {
        var mh$ = fileno_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MemorySegment pclose$address() {
        return pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static int pclose(MemorySegment __stream) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen$address() {
        return popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen(MemorySegment __command, MemorySegment __modes) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", __command, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__command, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid(MemorySegment __s) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("flockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MemorySegment flockfile$address() {
        return flockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static void flockfile(MemorySegment __stream) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("ftrylockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MemorySegment ftrylockfile$address() {
        return ftrylockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static int ftrylockfile(MemorySegment __stream) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("funlockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MemorySegment funlockfile$address() {
        return funlockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static void funlockfile(MemorySegment __stream) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __uflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("__uflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static FunctionDescriptor __uflow$descriptor() {
        return __uflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MethodHandle __uflow$handle() {
        return __uflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MemorySegment __uflow$address() {
        return __uflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static int __uflow(MemorySegment x0) {
        var mh$ = __uflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__uflow", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static FunctionDescriptor __overflow$descriptor() {
        return __overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MethodHandle __overflow$handle() {
        return __overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MemorySegment __overflow$address() {
        return __overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static int __overflow(MemorySegment x0, int x1) {
        var mh$ = __overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__overflow", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint32_t xkb_keycode_t
     * }
     */
    public static final OfInt xkb_keycode_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t xkb_keysym_t
     * }
     */
    public static final OfInt xkb_keysym_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t xkb_layout_index_t
     * }
     */
    public static final OfInt xkb_layout_index_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t xkb_layout_mask_t
     * }
     */
    public static final OfInt xkb_layout_mask_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t xkb_level_index_t
     * }
     */
    public static final OfInt xkb_level_index_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t xkb_mod_index_t
     * }
     */
    public static final OfInt xkb_mod_index_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t xkb_mod_mask_t
     * }
     */
    public static final OfInt xkb_mod_mask_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t xkb_led_index_t
     * }
     */
    public static final OfInt xkb_led_index_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t xkb_led_mask_t
     * }
     */
    public static final OfInt xkb_led_mask_t = C.C_INT;

    private static class xkb_keysym_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_LONG
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keysym_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xkb_keysym_get_name(xkb_keysym_t keysym, char *buffer, size_t size)
     * }
     */
    public static FunctionDescriptor xkb_keysym_get_name$descriptor() {
        return xkb_keysym_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xkb_keysym_get_name(xkb_keysym_t keysym, char *buffer, size_t size)
     * }
     */
    public static MethodHandle xkb_keysym_get_name$handle() {
        return xkb_keysym_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xkb_keysym_get_name(xkb_keysym_t keysym, char *buffer, size_t size)
     * }
     */
    public static MemorySegment xkb_keysym_get_name$address() {
        return xkb_keysym_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xkb_keysym_get_name(xkb_keysym_t keysym, char *buffer, size_t size)
     * }
     */
    public static int xkb_keysym_get_name(int keysym, MemorySegment buffer, long size) {
        var mh$ = xkb_keysym_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keysym_get_name", keysym, buffer, size);
            }
            return (int)mh$.invokeExact(keysym, buffer, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int XKB_KEYSYM_NO_FLAGS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum xkb_keysym_flags.XKB_KEYSYM_NO_FLAGS = 0
     * }
     */
    public static int XKB_KEYSYM_NO_FLAGS() {
        return XKB_KEYSYM_NO_FLAGS;
    }
    private static final int XKB_KEYSYM_CASE_INSENSITIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum xkb_keysym_flags.XKB_KEYSYM_CASE_INSENSITIVE = 1
     * }
     */
    public static int XKB_KEYSYM_CASE_INSENSITIVE() {
        return XKB_KEYSYM_CASE_INSENSITIVE;
    }

    private static class xkb_keysym_from_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keysym_from_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_keysym_t xkb_keysym_from_name(const char *name, enum xkb_keysym_flags flags)
     * }
     */
    public static FunctionDescriptor xkb_keysym_from_name$descriptor() {
        return xkb_keysym_from_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_keysym_t xkb_keysym_from_name(const char *name, enum xkb_keysym_flags flags)
     * }
     */
    public static MethodHandle xkb_keysym_from_name$handle() {
        return xkb_keysym_from_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_keysym_t xkb_keysym_from_name(const char *name, enum xkb_keysym_flags flags)
     * }
     */
    public static MemorySegment xkb_keysym_from_name$address() {
        return xkb_keysym_from_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_keysym_t xkb_keysym_from_name(const char *name, enum xkb_keysym_flags flags)
     * }
     */
    public static int xkb_keysym_from_name(MemorySegment name, int flags) {
        var mh$ = xkb_keysym_from_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keysym_from_name", name, flags);
            }
            return (int)mh$.invokeExact(name, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keysym_to_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_LONG
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keysym_to_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xkb_keysym_to_utf8(xkb_keysym_t keysym, char *buffer, size_t size)
     * }
     */
    public static FunctionDescriptor xkb_keysym_to_utf8$descriptor() {
        return xkb_keysym_to_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xkb_keysym_to_utf8(xkb_keysym_t keysym, char *buffer, size_t size)
     * }
     */
    public static MethodHandle xkb_keysym_to_utf8$handle() {
        return xkb_keysym_to_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xkb_keysym_to_utf8(xkb_keysym_t keysym, char *buffer, size_t size)
     * }
     */
    public static MemorySegment xkb_keysym_to_utf8$address() {
        return xkb_keysym_to_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xkb_keysym_to_utf8(xkb_keysym_t keysym, char *buffer, size_t size)
     * }
     */
    public static int xkb_keysym_to_utf8(int keysym, MemorySegment buffer, long size) {
        var mh$ = xkb_keysym_to_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keysym_to_utf8", keysym, buffer, size);
            }
            return (int)mh$.invokeExact(keysym, buffer, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keysym_to_utf32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keysym_to_utf32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t xkb_keysym_to_utf32(xkb_keysym_t keysym)
     * }
     */
    public static FunctionDescriptor xkb_keysym_to_utf32$descriptor() {
        return xkb_keysym_to_utf32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t xkb_keysym_to_utf32(xkb_keysym_t keysym)
     * }
     */
    public static MethodHandle xkb_keysym_to_utf32$handle() {
        return xkb_keysym_to_utf32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t xkb_keysym_to_utf32(xkb_keysym_t keysym)
     * }
     */
    public static MemorySegment xkb_keysym_to_utf32$address() {
        return xkb_keysym_to_utf32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t xkb_keysym_to_utf32(xkb_keysym_t keysym)
     * }
     */
    public static int xkb_keysym_to_utf32(int keysym) {
        var mh$ = xkb_keysym_to_utf32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keysym_to_utf32", keysym);
            }
            return (int)mh$.invokeExact(keysym);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_utf32_to_keysym {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_utf32_to_keysym");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_keysym_t xkb_utf32_to_keysym(uint32_t ucs)
     * }
     */
    public static FunctionDescriptor xkb_utf32_to_keysym$descriptor() {
        return xkb_utf32_to_keysym.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_keysym_t xkb_utf32_to_keysym(uint32_t ucs)
     * }
     */
    public static MethodHandle xkb_utf32_to_keysym$handle() {
        return xkb_utf32_to_keysym.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_keysym_t xkb_utf32_to_keysym(uint32_t ucs)
     * }
     */
    public static MemorySegment xkb_utf32_to_keysym$address() {
        return xkb_utf32_to_keysym.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_keysym_t xkb_utf32_to_keysym(uint32_t ucs)
     * }
     */
    public static int xkb_utf32_to_keysym(int ucs) {
        var mh$ = xkb_utf32_to_keysym.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_utf32_to_keysym", ucs);
            }
            return (int)mh$.invokeExact(ucs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keysym_to_upper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keysym_to_upper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_keysym_t xkb_keysym_to_upper(xkb_keysym_t ks)
     * }
     */
    public static FunctionDescriptor xkb_keysym_to_upper$descriptor() {
        return xkb_keysym_to_upper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_keysym_t xkb_keysym_to_upper(xkb_keysym_t ks)
     * }
     */
    public static MethodHandle xkb_keysym_to_upper$handle() {
        return xkb_keysym_to_upper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_keysym_t xkb_keysym_to_upper(xkb_keysym_t ks)
     * }
     */
    public static MemorySegment xkb_keysym_to_upper$address() {
        return xkb_keysym_to_upper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_keysym_t xkb_keysym_to_upper(xkb_keysym_t ks)
     * }
     */
    public static int xkb_keysym_to_upper(int ks) {
        var mh$ = xkb_keysym_to_upper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keysym_to_upper", ks);
            }
            return (int)mh$.invokeExact(ks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keysym_to_lower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keysym_to_lower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_keysym_t xkb_keysym_to_lower(xkb_keysym_t ks)
     * }
     */
    public static FunctionDescriptor xkb_keysym_to_lower$descriptor() {
        return xkb_keysym_to_lower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_keysym_t xkb_keysym_to_lower(xkb_keysym_t ks)
     * }
     */
    public static MethodHandle xkb_keysym_to_lower$handle() {
        return xkb_keysym_to_lower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_keysym_t xkb_keysym_to_lower(xkb_keysym_t ks)
     * }
     */
    public static MemorySegment xkb_keysym_to_lower$address() {
        return xkb_keysym_to_lower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_keysym_t xkb_keysym_to_lower(xkb_keysym_t ks)
     * }
     */
    public static int xkb_keysym_to_lower(int ks) {
        var mh$ = xkb_keysym_to_lower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keysym_to_lower", ks);
            }
            return (int)mh$.invokeExact(ks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int XKB_CONTEXT_NO_FLAGS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum xkb_context_flags.XKB_CONTEXT_NO_FLAGS = 0
     * }
     */
    public static int XKB_CONTEXT_NO_FLAGS() {
        return XKB_CONTEXT_NO_FLAGS;
    }
    private static final int XKB_CONTEXT_NO_DEFAULT_INCLUDES = (int)1L;
    /**
     * {@snippet lang=c :
     * enum xkb_context_flags.XKB_CONTEXT_NO_DEFAULT_INCLUDES = 1
     * }
     */
    public static int XKB_CONTEXT_NO_DEFAULT_INCLUDES() {
        return XKB_CONTEXT_NO_DEFAULT_INCLUDES;
    }
    private static final int XKB_CONTEXT_NO_ENVIRONMENT_NAMES = (int)2L;
    /**
     * {@snippet lang=c :
     * enum xkb_context_flags.XKB_CONTEXT_NO_ENVIRONMENT_NAMES = 2
     * }
     */
    public static int XKB_CONTEXT_NO_ENVIRONMENT_NAMES() {
        return XKB_CONTEXT_NO_ENVIRONMENT_NAMES;
    }
    private static final int XKB_CONTEXT_NO_SECURE_GETENV = (int)4L;
    /**
     * {@snippet lang=c :
     * enum xkb_context_flags.XKB_CONTEXT_NO_SECURE_GETENV = 4
     * }
     */
    public static int XKB_CONTEXT_NO_SECURE_GETENV() {
        return XKB_CONTEXT_NO_SECURE_GETENV;
    }

    private static class xkb_context_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_context_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct xkb_context *xkb_context_new(enum xkb_context_flags flags)
     * }
     */
    public static FunctionDescriptor xkb_context_new$descriptor() {
        return xkb_context_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct xkb_context *xkb_context_new(enum xkb_context_flags flags)
     * }
     */
    public static MethodHandle xkb_context_new$handle() {
        return xkb_context_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct xkb_context *xkb_context_new(enum xkb_context_flags flags)
     * }
     */
    public static MemorySegment xkb_context_new$address() {
        return xkb_context_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct xkb_context *xkb_context_new(enum xkb_context_flags flags)
     * }
     */
    public static MemorySegment xkb_context_new(int flags) {
        var mh$ = xkb_context_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_context_new", flags);
            }
            return (MemorySegment)mh$.invokeExact(flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_context_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_context_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct xkb_context *xkb_context_ref(struct xkb_context *context)
     * }
     */
    public static FunctionDescriptor xkb_context_ref$descriptor() {
        return xkb_context_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct xkb_context *xkb_context_ref(struct xkb_context *context)
     * }
     */
    public static MethodHandle xkb_context_ref$handle() {
        return xkb_context_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct xkb_context *xkb_context_ref(struct xkb_context *context)
     * }
     */
    public static MemorySegment xkb_context_ref$address() {
        return xkb_context_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct xkb_context *xkb_context_ref(struct xkb_context *context)
     * }
     */
    public static MemorySegment xkb_context_ref(MemorySegment context) {
        var mh$ = xkb_context_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_context_ref", context);
            }
            return (MemorySegment)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_context_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_context_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xkb_context_unref(struct xkb_context *context)
     * }
     */
    public static FunctionDescriptor xkb_context_unref$descriptor() {
        return xkb_context_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xkb_context_unref(struct xkb_context *context)
     * }
     */
    public static MethodHandle xkb_context_unref$handle() {
        return xkb_context_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xkb_context_unref(struct xkb_context *context)
     * }
     */
    public static MemorySegment xkb_context_unref$address() {
        return xkb_context_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xkb_context_unref(struct xkb_context *context)
     * }
     */
    public static void xkb_context_unref(MemorySegment context) {
        var mh$ = xkb_context_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_context_unref", context);
            }
            mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_context_set_user_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_context_set_user_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xkb_context_set_user_data(struct xkb_context *context, void *user_data)
     * }
     */
    public static FunctionDescriptor xkb_context_set_user_data$descriptor() {
        return xkb_context_set_user_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xkb_context_set_user_data(struct xkb_context *context, void *user_data)
     * }
     */
    public static MethodHandle xkb_context_set_user_data$handle() {
        return xkb_context_set_user_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xkb_context_set_user_data(struct xkb_context *context, void *user_data)
     * }
     */
    public static MemorySegment xkb_context_set_user_data$address() {
        return xkb_context_set_user_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xkb_context_set_user_data(struct xkb_context *context, void *user_data)
     * }
     */
    public static void xkb_context_set_user_data(MemorySegment context, MemorySegment user_data) {
        var mh$ = xkb_context_set_user_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_context_set_user_data", context, user_data);
            }
            mh$.invokeExact(context, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_context_get_user_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_context_get_user_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *xkb_context_get_user_data(struct xkb_context *context)
     * }
     */
    public static FunctionDescriptor xkb_context_get_user_data$descriptor() {
        return xkb_context_get_user_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *xkb_context_get_user_data(struct xkb_context *context)
     * }
     */
    public static MethodHandle xkb_context_get_user_data$handle() {
        return xkb_context_get_user_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *xkb_context_get_user_data(struct xkb_context *context)
     * }
     */
    public static MemorySegment xkb_context_get_user_data$address() {
        return xkb_context_get_user_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *xkb_context_get_user_data(struct xkb_context *context)
     * }
     */
    public static MemorySegment xkb_context_get_user_data(MemorySegment context) {
        var mh$ = xkb_context_get_user_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_context_get_user_data", context);
            }
            return (MemorySegment)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_context_include_path_append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_context_include_path_append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xkb_context_include_path_append(struct xkb_context *context, const char *path)
     * }
     */
    public static FunctionDescriptor xkb_context_include_path_append$descriptor() {
        return xkb_context_include_path_append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xkb_context_include_path_append(struct xkb_context *context, const char *path)
     * }
     */
    public static MethodHandle xkb_context_include_path_append$handle() {
        return xkb_context_include_path_append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xkb_context_include_path_append(struct xkb_context *context, const char *path)
     * }
     */
    public static MemorySegment xkb_context_include_path_append$address() {
        return xkb_context_include_path_append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xkb_context_include_path_append(struct xkb_context *context, const char *path)
     * }
     */
    public static int xkb_context_include_path_append(MemorySegment context, MemorySegment path) {
        var mh$ = xkb_context_include_path_append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_context_include_path_append", context, path);
            }
            return (int)mh$.invokeExact(context, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_context_include_path_append_default {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_context_include_path_append_default");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xkb_context_include_path_append_default(struct xkb_context *context)
     * }
     */
    public static FunctionDescriptor xkb_context_include_path_append_default$descriptor() {
        return xkb_context_include_path_append_default.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xkb_context_include_path_append_default(struct xkb_context *context)
     * }
     */
    public static MethodHandle xkb_context_include_path_append_default$handle() {
        return xkb_context_include_path_append_default.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xkb_context_include_path_append_default(struct xkb_context *context)
     * }
     */
    public static MemorySegment xkb_context_include_path_append_default$address() {
        return xkb_context_include_path_append_default.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xkb_context_include_path_append_default(struct xkb_context *context)
     * }
     */
    public static int xkb_context_include_path_append_default(MemorySegment context) {
        var mh$ = xkb_context_include_path_append_default.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_context_include_path_append_default", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_context_include_path_reset_defaults {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_context_include_path_reset_defaults");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xkb_context_include_path_reset_defaults(struct xkb_context *context)
     * }
     */
    public static FunctionDescriptor xkb_context_include_path_reset_defaults$descriptor() {
        return xkb_context_include_path_reset_defaults.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xkb_context_include_path_reset_defaults(struct xkb_context *context)
     * }
     */
    public static MethodHandle xkb_context_include_path_reset_defaults$handle() {
        return xkb_context_include_path_reset_defaults.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xkb_context_include_path_reset_defaults(struct xkb_context *context)
     * }
     */
    public static MemorySegment xkb_context_include_path_reset_defaults$address() {
        return xkb_context_include_path_reset_defaults.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xkb_context_include_path_reset_defaults(struct xkb_context *context)
     * }
     */
    public static int xkb_context_include_path_reset_defaults(MemorySegment context) {
        var mh$ = xkb_context_include_path_reset_defaults.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_context_include_path_reset_defaults", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_context_include_path_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_context_include_path_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xkb_context_include_path_clear(struct xkb_context *context)
     * }
     */
    public static FunctionDescriptor xkb_context_include_path_clear$descriptor() {
        return xkb_context_include_path_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xkb_context_include_path_clear(struct xkb_context *context)
     * }
     */
    public static MethodHandle xkb_context_include_path_clear$handle() {
        return xkb_context_include_path_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xkb_context_include_path_clear(struct xkb_context *context)
     * }
     */
    public static MemorySegment xkb_context_include_path_clear$address() {
        return xkb_context_include_path_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xkb_context_include_path_clear(struct xkb_context *context)
     * }
     */
    public static void xkb_context_include_path_clear(MemorySegment context) {
        var mh$ = xkb_context_include_path_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_context_include_path_clear", context);
            }
            mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_context_num_include_paths {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_context_num_include_paths");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int xkb_context_num_include_paths(struct xkb_context *context)
     * }
     */
    public static FunctionDescriptor xkb_context_num_include_paths$descriptor() {
        return xkb_context_num_include_paths.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int xkb_context_num_include_paths(struct xkb_context *context)
     * }
     */
    public static MethodHandle xkb_context_num_include_paths$handle() {
        return xkb_context_num_include_paths.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int xkb_context_num_include_paths(struct xkb_context *context)
     * }
     */
    public static MemorySegment xkb_context_num_include_paths$address() {
        return xkb_context_num_include_paths.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int xkb_context_num_include_paths(struct xkb_context *context)
     * }
     */
    public static int xkb_context_num_include_paths(MemorySegment context) {
        var mh$ = xkb_context_num_include_paths.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_context_num_include_paths", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_context_include_path_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_context_include_path_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *xkb_context_include_path_get(struct xkb_context *context, unsigned int index)
     * }
     */
    public static FunctionDescriptor xkb_context_include_path_get$descriptor() {
        return xkb_context_include_path_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *xkb_context_include_path_get(struct xkb_context *context, unsigned int index)
     * }
     */
    public static MethodHandle xkb_context_include_path_get$handle() {
        return xkb_context_include_path_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *xkb_context_include_path_get(struct xkb_context *context, unsigned int index)
     * }
     */
    public static MemorySegment xkb_context_include_path_get$address() {
        return xkb_context_include_path_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *xkb_context_include_path_get(struct xkb_context *context, unsigned int index)
     * }
     */
    public static MemorySegment xkb_context_include_path_get(MemorySegment context, int index) {
        var mh$ = xkb_context_include_path_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_context_include_path_get", context, index);
            }
            return (MemorySegment)mh$.invokeExact(context, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int XKB_LOG_LEVEL_CRITICAL = (int)10L;
    /**
     * {@snippet lang=c :
     * enum xkb_log_level.XKB_LOG_LEVEL_CRITICAL = 10
     * }
     */
    public static int XKB_LOG_LEVEL_CRITICAL() {
        return XKB_LOG_LEVEL_CRITICAL;
    }
    private static final int XKB_LOG_LEVEL_ERROR = (int)20L;
    /**
     * {@snippet lang=c :
     * enum xkb_log_level.XKB_LOG_LEVEL_ERROR = 20
     * }
     */
    public static int XKB_LOG_LEVEL_ERROR() {
        return XKB_LOG_LEVEL_ERROR;
    }
    private static final int XKB_LOG_LEVEL_WARNING = (int)30L;
    /**
     * {@snippet lang=c :
     * enum xkb_log_level.XKB_LOG_LEVEL_WARNING = 30
     * }
     */
    public static int XKB_LOG_LEVEL_WARNING() {
        return XKB_LOG_LEVEL_WARNING;
    }
    private static final int XKB_LOG_LEVEL_INFO = (int)40L;
    /**
     * {@snippet lang=c :
     * enum xkb_log_level.XKB_LOG_LEVEL_INFO = 40
     * }
     */
    public static int XKB_LOG_LEVEL_INFO() {
        return XKB_LOG_LEVEL_INFO;
    }
    private static final int XKB_LOG_LEVEL_DEBUG = (int)50L;
    /**
     * {@snippet lang=c :
     * enum xkb_log_level.XKB_LOG_LEVEL_DEBUG = 50
     * }
     */
    public static int XKB_LOG_LEVEL_DEBUG() {
        return XKB_LOG_LEVEL_DEBUG;
    }

    private static class xkb_context_set_log_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_context_set_log_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xkb_context_set_log_level(struct xkb_context *context, enum xkb_log_level level)
     * }
     */
    public static FunctionDescriptor xkb_context_set_log_level$descriptor() {
        return xkb_context_set_log_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xkb_context_set_log_level(struct xkb_context *context, enum xkb_log_level level)
     * }
     */
    public static MethodHandle xkb_context_set_log_level$handle() {
        return xkb_context_set_log_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xkb_context_set_log_level(struct xkb_context *context, enum xkb_log_level level)
     * }
     */
    public static MemorySegment xkb_context_set_log_level$address() {
        return xkb_context_set_log_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xkb_context_set_log_level(struct xkb_context *context, enum xkb_log_level level)
     * }
     */
    public static void xkb_context_set_log_level(MemorySegment context, int level) {
        var mh$ = xkb_context_set_log_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_context_set_log_level", context, level);
            }
            mh$.invokeExact(context, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_context_get_log_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_context_get_log_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum xkb_log_level xkb_context_get_log_level(struct xkb_context *context)
     * }
     */
    public static FunctionDescriptor xkb_context_get_log_level$descriptor() {
        return xkb_context_get_log_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum xkb_log_level xkb_context_get_log_level(struct xkb_context *context)
     * }
     */
    public static MethodHandle xkb_context_get_log_level$handle() {
        return xkb_context_get_log_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum xkb_log_level xkb_context_get_log_level(struct xkb_context *context)
     * }
     */
    public static MemorySegment xkb_context_get_log_level$address() {
        return xkb_context_get_log_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum xkb_log_level xkb_context_get_log_level(struct xkb_context *context)
     * }
     */
    public static int xkb_context_get_log_level(MemorySegment context) {
        var mh$ = xkb_context_get_log_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_context_get_log_level", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_context_set_log_verbosity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_context_set_log_verbosity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xkb_context_set_log_verbosity(struct xkb_context *context, int verbosity)
     * }
     */
    public static FunctionDescriptor xkb_context_set_log_verbosity$descriptor() {
        return xkb_context_set_log_verbosity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xkb_context_set_log_verbosity(struct xkb_context *context, int verbosity)
     * }
     */
    public static MethodHandle xkb_context_set_log_verbosity$handle() {
        return xkb_context_set_log_verbosity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xkb_context_set_log_verbosity(struct xkb_context *context, int verbosity)
     * }
     */
    public static MemorySegment xkb_context_set_log_verbosity$address() {
        return xkb_context_set_log_verbosity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xkb_context_set_log_verbosity(struct xkb_context *context, int verbosity)
     * }
     */
    public static void xkb_context_set_log_verbosity(MemorySegment context, int verbosity) {
        var mh$ = xkb_context_set_log_verbosity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_context_set_log_verbosity", context, verbosity);
            }
            mh$.invokeExact(context, verbosity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_context_get_log_verbosity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_context_get_log_verbosity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xkb_context_get_log_verbosity(struct xkb_context *context)
     * }
     */
    public static FunctionDescriptor xkb_context_get_log_verbosity$descriptor() {
        return xkb_context_get_log_verbosity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xkb_context_get_log_verbosity(struct xkb_context *context)
     * }
     */
    public static MethodHandle xkb_context_get_log_verbosity$handle() {
        return xkb_context_get_log_verbosity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xkb_context_get_log_verbosity(struct xkb_context *context)
     * }
     */
    public static MemorySegment xkb_context_get_log_verbosity$address() {
        return xkb_context_get_log_verbosity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xkb_context_get_log_verbosity(struct xkb_context *context)
     * }
     */
    public static int xkb_context_get_log_verbosity(MemorySegment context) {
        var mh$ = xkb_context_get_log_verbosity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_context_get_log_verbosity", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_context_set_log_fn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_context_set_log_fn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xkb_context_set_log_fn(struct xkb_context *context, void (*log_fn)(struct xkb_context *, enum xkb_log_level, const char *, struct __va_list_tag *))
     * }
     */
    public static FunctionDescriptor xkb_context_set_log_fn$descriptor() {
        return xkb_context_set_log_fn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xkb_context_set_log_fn(struct xkb_context *context, void (*log_fn)(struct xkb_context *, enum xkb_log_level, const char *, struct __va_list_tag *))
     * }
     */
    public static MethodHandle xkb_context_set_log_fn$handle() {
        return xkb_context_set_log_fn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xkb_context_set_log_fn(struct xkb_context *context, void (*log_fn)(struct xkb_context *, enum xkb_log_level, const char *, struct __va_list_tag *))
     * }
     */
    public static MemorySegment xkb_context_set_log_fn$address() {
        return xkb_context_set_log_fn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xkb_context_set_log_fn(struct xkb_context *context, void (*log_fn)(struct xkb_context *, enum xkb_log_level, const char *, struct __va_list_tag *))
     * }
     */
    public static void xkb_context_set_log_fn(MemorySegment context, MemorySegment log_fn) {
        var mh$ = xkb_context_set_log_fn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_context_set_log_fn", context, log_fn);
            }
            mh$.invokeExact(context, log_fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int XKB_KEYMAP_COMPILE_NO_FLAGS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum xkb_keymap_compile_flags.XKB_KEYMAP_COMPILE_NO_FLAGS = 0
     * }
     */
    public static int XKB_KEYMAP_COMPILE_NO_FLAGS() {
        return XKB_KEYMAP_COMPILE_NO_FLAGS;
    }

    private static class xkb_keymap_new_from_names {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_new_from_names");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_keymap_new_from_names(struct xkb_context *context, const struct xkb_rule_names *names, enum xkb_keymap_compile_flags flags)
     * }
     */
    public static FunctionDescriptor xkb_keymap_new_from_names$descriptor() {
        return xkb_keymap_new_from_names.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_keymap_new_from_names(struct xkb_context *context, const struct xkb_rule_names *names, enum xkb_keymap_compile_flags flags)
     * }
     */
    public static MethodHandle xkb_keymap_new_from_names$handle() {
        return xkb_keymap_new_from_names.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_keymap_new_from_names(struct xkb_context *context, const struct xkb_rule_names *names, enum xkb_keymap_compile_flags flags)
     * }
     */
    public static MemorySegment xkb_keymap_new_from_names$address() {
        return xkb_keymap_new_from_names.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_keymap_new_from_names(struct xkb_context *context, const struct xkb_rule_names *names, enum xkb_keymap_compile_flags flags)
     * }
     */
    public static MemorySegment xkb_keymap_new_from_names(MemorySegment context, MemorySegment names, int flags) {
        var mh$ = xkb_keymap_new_from_names.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_new_from_names", context, names, flags);
            }
            return (MemorySegment)mh$.invokeExact(context, names, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int XKB_KEYMAP_FORMAT_TEXT_V1 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum xkb_keymap_format.XKB_KEYMAP_FORMAT_TEXT_V1 = 1
     * }
     */
    public static int XKB_KEYMAP_FORMAT_TEXT_V1() {
        return XKB_KEYMAP_FORMAT_TEXT_V1;
    }

    private static class xkb_keymap_new_from_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_new_from_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_keymap_new_from_file(struct xkb_context *context, FILE *file, enum xkb_keymap_format format, enum xkb_keymap_compile_flags flags)
     * }
     */
    public static FunctionDescriptor xkb_keymap_new_from_file$descriptor() {
        return xkb_keymap_new_from_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_keymap_new_from_file(struct xkb_context *context, FILE *file, enum xkb_keymap_format format, enum xkb_keymap_compile_flags flags)
     * }
     */
    public static MethodHandle xkb_keymap_new_from_file$handle() {
        return xkb_keymap_new_from_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_keymap_new_from_file(struct xkb_context *context, FILE *file, enum xkb_keymap_format format, enum xkb_keymap_compile_flags flags)
     * }
     */
    public static MemorySegment xkb_keymap_new_from_file$address() {
        return xkb_keymap_new_from_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_keymap_new_from_file(struct xkb_context *context, FILE *file, enum xkb_keymap_format format, enum xkb_keymap_compile_flags flags)
     * }
     */
    public static MemorySegment xkb_keymap_new_from_file(MemorySegment context, MemorySegment file, int format, int flags) {
        var mh$ = xkb_keymap_new_from_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_new_from_file", context, file, format, flags);
            }
            return (MemorySegment)mh$.invokeExact(context, file, format, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_new_from_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_new_from_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_keymap_new_from_string(struct xkb_context *context, const char *string, enum xkb_keymap_format format, enum xkb_keymap_compile_flags flags)
     * }
     */
    public static FunctionDescriptor xkb_keymap_new_from_string$descriptor() {
        return xkb_keymap_new_from_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_keymap_new_from_string(struct xkb_context *context, const char *string, enum xkb_keymap_format format, enum xkb_keymap_compile_flags flags)
     * }
     */
    public static MethodHandle xkb_keymap_new_from_string$handle() {
        return xkb_keymap_new_from_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_keymap_new_from_string(struct xkb_context *context, const char *string, enum xkb_keymap_format format, enum xkb_keymap_compile_flags flags)
     * }
     */
    public static MemorySegment xkb_keymap_new_from_string$address() {
        return xkb_keymap_new_from_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_keymap_new_from_string(struct xkb_context *context, const char *string, enum xkb_keymap_format format, enum xkb_keymap_compile_flags flags)
     * }
     */
    public static MemorySegment xkb_keymap_new_from_string(MemorySegment context, MemorySegment string, int format, int flags) {
        var mh$ = xkb_keymap_new_from_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_new_from_string", context, string, format, flags);
            }
            return (MemorySegment)mh$.invokeExact(context, string, format, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_new_from_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_LONG,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_new_from_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_keymap_new_from_buffer(struct xkb_context *context, const char *buffer, size_t length, enum xkb_keymap_format format, enum xkb_keymap_compile_flags flags)
     * }
     */
    public static FunctionDescriptor xkb_keymap_new_from_buffer$descriptor() {
        return xkb_keymap_new_from_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_keymap_new_from_buffer(struct xkb_context *context, const char *buffer, size_t length, enum xkb_keymap_format format, enum xkb_keymap_compile_flags flags)
     * }
     */
    public static MethodHandle xkb_keymap_new_from_buffer$handle() {
        return xkb_keymap_new_from_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_keymap_new_from_buffer(struct xkb_context *context, const char *buffer, size_t length, enum xkb_keymap_format format, enum xkb_keymap_compile_flags flags)
     * }
     */
    public static MemorySegment xkb_keymap_new_from_buffer$address() {
        return xkb_keymap_new_from_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_keymap_new_from_buffer(struct xkb_context *context, const char *buffer, size_t length, enum xkb_keymap_format format, enum xkb_keymap_compile_flags flags)
     * }
     */
    public static MemorySegment xkb_keymap_new_from_buffer(MemorySegment context, MemorySegment buffer, long length, int format, int flags) {
        var mh$ = xkb_keymap_new_from_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_new_from_buffer", context, buffer, length, format, flags);
            }
            return (MemorySegment)mh$.invokeExact(context, buffer, length, format, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_keymap_ref(struct xkb_keymap *keymap)
     * }
     */
    public static FunctionDescriptor xkb_keymap_ref$descriptor() {
        return xkb_keymap_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_keymap_ref(struct xkb_keymap *keymap)
     * }
     */
    public static MethodHandle xkb_keymap_ref$handle() {
        return xkb_keymap_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_keymap_ref(struct xkb_keymap *keymap)
     * }
     */
    public static MemorySegment xkb_keymap_ref$address() {
        return xkb_keymap_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_keymap_ref(struct xkb_keymap *keymap)
     * }
     */
    public static MemorySegment xkb_keymap_ref(MemorySegment keymap) {
        var mh$ = xkb_keymap_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_ref", keymap);
            }
            return (MemorySegment)mh$.invokeExact(keymap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xkb_keymap_unref(struct xkb_keymap *keymap)
     * }
     */
    public static FunctionDescriptor xkb_keymap_unref$descriptor() {
        return xkb_keymap_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xkb_keymap_unref(struct xkb_keymap *keymap)
     * }
     */
    public static MethodHandle xkb_keymap_unref$handle() {
        return xkb_keymap_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xkb_keymap_unref(struct xkb_keymap *keymap)
     * }
     */
    public static MemorySegment xkb_keymap_unref$address() {
        return xkb_keymap_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xkb_keymap_unref(struct xkb_keymap *keymap)
     * }
     */
    public static void xkb_keymap_unref(MemorySegment keymap) {
        var mh$ = xkb_keymap_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_unref", keymap);
            }
            mh$.invokeExact(keymap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_get_as_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_get_as_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *xkb_keymap_get_as_string(struct xkb_keymap *keymap, enum xkb_keymap_format format)
     * }
     */
    public static FunctionDescriptor xkb_keymap_get_as_string$descriptor() {
        return xkb_keymap_get_as_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *xkb_keymap_get_as_string(struct xkb_keymap *keymap, enum xkb_keymap_format format)
     * }
     */
    public static MethodHandle xkb_keymap_get_as_string$handle() {
        return xkb_keymap_get_as_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *xkb_keymap_get_as_string(struct xkb_keymap *keymap, enum xkb_keymap_format format)
     * }
     */
    public static MemorySegment xkb_keymap_get_as_string$address() {
        return xkb_keymap_get_as_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *xkb_keymap_get_as_string(struct xkb_keymap *keymap, enum xkb_keymap_format format)
     * }
     */
    public static MemorySegment xkb_keymap_get_as_string(MemorySegment keymap, int format) {
        var mh$ = xkb_keymap_get_as_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_get_as_string", keymap, format);
            }
            return (MemorySegment)mh$.invokeExact(keymap, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_min_keycode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_min_keycode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_keycode_t xkb_keymap_min_keycode(struct xkb_keymap *keymap)
     * }
     */
    public static FunctionDescriptor xkb_keymap_min_keycode$descriptor() {
        return xkb_keymap_min_keycode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_keycode_t xkb_keymap_min_keycode(struct xkb_keymap *keymap)
     * }
     */
    public static MethodHandle xkb_keymap_min_keycode$handle() {
        return xkb_keymap_min_keycode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_keycode_t xkb_keymap_min_keycode(struct xkb_keymap *keymap)
     * }
     */
    public static MemorySegment xkb_keymap_min_keycode$address() {
        return xkb_keymap_min_keycode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_keycode_t xkb_keymap_min_keycode(struct xkb_keymap *keymap)
     * }
     */
    public static int xkb_keymap_min_keycode(MemorySegment keymap) {
        var mh$ = xkb_keymap_min_keycode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_min_keycode", keymap);
            }
            return (int)mh$.invokeExact(keymap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_max_keycode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_max_keycode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_keycode_t xkb_keymap_max_keycode(struct xkb_keymap *keymap)
     * }
     */
    public static FunctionDescriptor xkb_keymap_max_keycode$descriptor() {
        return xkb_keymap_max_keycode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_keycode_t xkb_keymap_max_keycode(struct xkb_keymap *keymap)
     * }
     */
    public static MethodHandle xkb_keymap_max_keycode$handle() {
        return xkb_keymap_max_keycode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_keycode_t xkb_keymap_max_keycode(struct xkb_keymap *keymap)
     * }
     */
    public static MemorySegment xkb_keymap_max_keycode$address() {
        return xkb_keymap_max_keycode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_keycode_t xkb_keymap_max_keycode(struct xkb_keymap *keymap)
     * }
     */
    public static int xkb_keymap_max_keycode(MemorySegment keymap) {
        var mh$ = xkb_keymap_max_keycode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_max_keycode", keymap);
            }
            return (int)mh$.invokeExact(keymap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_key_for_each {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_key_for_each");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xkb_keymap_key_for_each(struct xkb_keymap *keymap, xkb_keymap_key_iter_t iter, void *data)
     * }
     */
    public static FunctionDescriptor xkb_keymap_key_for_each$descriptor() {
        return xkb_keymap_key_for_each.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xkb_keymap_key_for_each(struct xkb_keymap *keymap, xkb_keymap_key_iter_t iter, void *data)
     * }
     */
    public static MethodHandle xkb_keymap_key_for_each$handle() {
        return xkb_keymap_key_for_each.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xkb_keymap_key_for_each(struct xkb_keymap *keymap, xkb_keymap_key_iter_t iter, void *data)
     * }
     */
    public static MemorySegment xkb_keymap_key_for_each$address() {
        return xkb_keymap_key_for_each.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xkb_keymap_key_for_each(struct xkb_keymap *keymap, xkb_keymap_key_iter_t iter, void *data)
     * }
     */
    public static void xkb_keymap_key_for_each(MemorySegment keymap, MemorySegment iter, MemorySegment data) {
        var mh$ = xkb_keymap_key_for_each.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_key_for_each", keymap, iter, data);
            }
            mh$.invokeExact(keymap, iter, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_key_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_key_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *xkb_keymap_key_get_name(struct xkb_keymap *keymap, xkb_keycode_t key)
     * }
     */
    public static FunctionDescriptor xkb_keymap_key_get_name$descriptor() {
        return xkb_keymap_key_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *xkb_keymap_key_get_name(struct xkb_keymap *keymap, xkb_keycode_t key)
     * }
     */
    public static MethodHandle xkb_keymap_key_get_name$handle() {
        return xkb_keymap_key_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *xkb_keymap_key_get_name(struct xkb_keymap *keymap, xkb_keycode_t key)
     * }
     */
    public static MemorySegment xkb_keymap_key_get_name$address() {
        return xkb_keymap_key_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *xkb_keymap_key_get_name(struct xkb_keymap *keymap, xkb_keycode_t key)
     * }
     */
    public static MemorySegment xkb_keymap_key_get_name(MemorySegment keymap, int key) {
        var mh$ = xkb_keymap_key_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_key_get_name", keymap, key);
            }
            return (MemorySegment)mh$.invokeExact(keymap, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_key_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_key_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_keycode_t xkb_keymap_key_by_name(struct xkb_keymap *keymap, const char *name)
     * }
     */
    public static FunctionDescriptor xkb_keymap_key_by_name$descriptor() {
        return xkb_keymap_key_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_keycode_t xkb_keymap_key_by_name(struct xkb_keymap *keymap, const char *name)
     * }
     */
    public static MethodHandle xkb_keymap_key_by_name$handle() {
        return xkb_keymap_key_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_keycode_t xkb_keymap_key_by_name(struct xkb_keymap *keymap, const char *name)
     * }
     */
    public static MemorySegment xkb_keymap_key_by_name$address() {
        return xkb_keymap_key_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_keycode_t xkb_keymap_key_by_name(struct xkb_keymap *keymap, const char *name)
     * }
     */
    public static int xkb_keymap_key_by_name(MemorySegment keymap, MemorySegment name) {
        var mh$ = xkb_keymap_key_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_key_by_name", keymap, name);
            }
            return (int)mh$.invokeExact(keymap, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_num_mods {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_num_mods");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_mod_index_t xkb_keymap_num_mods(struct xkb_keymap *keymap)
     * }
     */
    public static FunctionDescriptor xkb_keymap_num_mods$descriptor() {
        return xkb_keymap_num_mods.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_mod_index_t xkb_keymap_num_mods(struct xkb_keymap *keymap)
     * }
     */
    public static MethodHandle xkb_keymap_num_mods$handle() {
        return xkb_keymap_num_mods.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_mod_index_t xkb_keymap_num_mods(struct xkb_keymap *keymap)
     * }
     */
    public static MemorySegment xkb_keymap_num_mods$address() {
        return xkb_keymap_num_mods.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_mod_index_t xkb_keymap_num_mods(struct xkb_keymap *keymap)
     * }
     */
    public static int xkb_keymap_num_mods(MemorySegment keymap) {
        var mh$ = xkb_keymap_num_mods.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_num_mods", keymap);
            }
            return (int)mh$.invokeExact(keymap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_mod_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_mod_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *xkb_keymap_mod_get_name(struct xkb_keymap *keymap, xkb_mod_index_t idx)
     * }
     */
    public static FunctionDescriptor xkb_keymap_mod_get_name$descriptor() {
        return xkb_keymap_mod_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *xkb_keymap_mod_get_name(struct xkb_keymap *keymap, xkb_mod_index_t idx)
     * }
     */
    public static MethodHandle xkb_keymap_mod_get_name$handle() {
        return xkb_keymap_mod_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *xkb_keymap_mod_get_name(struct xkb_keymap *keymap, xkb_mod_index_t idx)
     * }
     */
    public static MemorySegment xkb_keymap_mod_get_name$address() {
        return xkb_keymap_mod_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *xkb_keymap_mod_get_name(struct xkb_keymap *keymap, xkb_mod_index_t idx)
     * }
     */
    public static MemorySegment xkb_keymap_mod_get_name(MemorySegment keymap, int idx) {
        var mh$ = xkb_keymap_mod_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_mod_get_name", keymap, idx);
            }
            return (MemorySegment)mh$.invokeExact(keymap, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_mod_get_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_mod_get_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_mod_index_t xkb_keymap_mod_get_index(struct xkb_keymap *keymap, const char *name)
     * }
     */
    public static FunctionDescriptor xkb_keymap_mod_get_index$descriptor() {
        return xkb_keymap_mod_get_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_mod_index_t xkb_keymap_mod_get_index(struct xkb_keymap *keymap, const char *name)
     * }
     */
    public static MethodHandle xkb_keymap_mod_get_index$handle() {
        return xkb_keymap_mod_get_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_mod_index_t xkb_keymap_mod_get_index(struct xkb_keymap *keymap, const char *name)
     * }
     */
    public static MemorySegment xkb_keymap_mod_get_index$address() {
        return xkb_keymap_mod_get_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_mod_index_t xkb_keymap_mod_get_index(struct xkb_keymap *keymap, const char *name)
     * }
     */
    public static int xkb_keymap_mod_get_index(MemorySegment keymap, MemorySegment name) {
        var mh$ = xkb_keymap_mod_get_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_mod_get_index", keymap, name);
            }
            return (int)mh$.invokeExact(keymap, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_num_layouts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_num_layouts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_layout_index_t xkb_keymap_num_layouts(struct xkb_keymap *keymap)
     * }
     */
    public static FunctionDescriptor xkb_keymap_num_layouts$descriptor() {
        return xkb_keymap_num_layouts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_layout_index_t xkb_keymap_num_layouts(struct xkb_keymap *keymap)
     * }
     */
    public static MethodHandle xkb_keymap_num_layouts$handle() {
        return xkb_keymap_num_layouts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_layout_index_t xkb_keymap_num_layouts(struct xkb_keymap *keymap)
     * }
     */
    public static MemorySegment xkb_keymap_num_layouts$address() {
        return xkb_keymap_num_layouts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_layout_index_t xkb_keymap_num_layouts(struct xkb_keymap *keymap)
     * }
     */
    public static int xkb_keymap_num_layouts(MemorySegment keymap) {
        var mh$ = xkb_keymap_num_layouts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_num_layouts", keymap);
            }
            return (int)mh$.invokeExact(keymap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_layout_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_layout_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *xkb_keymap_layout_get_name(struct xkb_keymap *keymap, xkb_layout_index_t idx)
     * }
     */
    public static FunctionDescriptor xkb_keymap_layout_get_name$descriptor() {
        return xkb_keymap_layout_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *xkb_keymap_layout_get_name(struct xkb_keymap *keymap, xkb_layout_index_t idx)
     * }
     */
    public static MethodHandle xkb_keymap_layout_get_name$handle() {
        return xkb_keymap_layout_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *xkb_keymap_layout_get_name(struct xkb_keymap *keymap, xkb_layout_index_t idx)
     * }
     */
    public static MemorySegment xkb_keymap_layout_get_name$address() {
        return xkb_keymap_layout_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *xkb_keymap_layout_get_name(struct xkb_keymap *keymap, xkb_layout_index_t idx)
     * }
     */
    public static MemorySegment xkb_keymap_layout_get_name(MemorySegment keymap, int idx) {
        var mh$ = xkb_keymap_layout_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_layout_get_name", keymap, idx);
            }
            return (MemorySegment)mh$.invokeExact(keymap, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_layout_get_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_layout_get_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_layout_index_t xkb_keymap_layout_get_index(struct xkb_keymap *keymap, const char *name)
     * }
     */
    public static FunctionDescriptor xkb_keymap_layout_get_index$descriptor() {
        return xkb_keymap_layout_get_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_layout_index_t xkb_keymap_layout_get_index(struct xkb_keymap *keymap, const char *name)
     * }
     */
    public static MethodHandle xkb_keymap_layout_get_index$handle() {
        return xkb_keymap_layout_get_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_layout_index_t xkb_keymap_layout_get_index(struct xkb_keymap *keymap, const char *name)
     * }
     */
    public static MemorySegment xkb_keymap_layout_get_index$address() {
        return xkb_keymap_layout_get_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_layout_index_t xkb_keymap_layout_get_index(struct xkb_keymap *keymap, const char *name)
     * }
     */
    public static int xkb_keymap_layout_get_index(MemorySegment keymap, MemorySegment name) {
        var mh$ = xkb_keymap_layout_get_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_layout_get_index", keymap, name);
            }
            return (int)mh$.invokeExact(keymap, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_num_leds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_num_leds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_led_index_t xkb_keymap_num_leds(struct xkb_keymap *keymap)
     * }
     */
    public static FunctionDescriptor xkb_keymap_num_leds$descriptor() {
        return xkb_keymap_num_leds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_led_index_t xkb_keymap_num_leds(struct xkb_keymap *keymap)
     * }
     */
    public static MethodHandle xkb_keymap_num_leds$handle() {
        return xkb_keymap_num_leds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_led_index_t xkb_keymap_num_leds(struct xkb_keymap *keymap)
     * }
     */
    public static MemorySegment xkb_keymap_num_leds$address() {
        return xkb_keymap_num_leds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_led_index_t xkb_keymap_num_leds(struct xkb_keymap *keymap)
     * }
     */
    public static int xkb_keymap_num_leds(MemorySegment keymap) {
        var mh$ = xkb_keymap_num_leds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_num_leds", keymap);
            }
            return (int)mh$.invokeExact(keymap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_led_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_led_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *xkb_keymap_led_get_name(struct xkb_keymap *keymap, xkb_led_index_t idx)
     * }
     */
    public static FunctionDescriptor xkb_keymap_led_get_name$descriptor() {
        return xkb_keymap_led_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *xkb_keymap_led_get_name(struct xkb_keymap *keymap, xkb_led_index_t idx)
     * }
     */
    public static MethodHandle xkb_keymap_led_get_name$handle() {
        return xkb_keymap_led_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *xkb_keymap_led_get_name(struct xkb_keymap *keymap, xkb_led_index_t idx)
     * }
     */
    public static MemorySegment xkb_keymap_led_get_name$address() {
        return xkb_keymap_led_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *xkb_keymap_led_get_name(struct xkb_keymap *keymap, xkb_led_index_t idx)
     * }
     */
    public static MemorySegment xkb_keymap_led_get_name(MemorySegment keymap, int idx) {
        var mh$ = xkb_keymap_led_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_led_get_name", keymap, idx);
            }
            return (MemorySegment)mh$.invokeExact(keymap, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_led_get_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_led_get_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_led_index_t xkb_keymap_led_get_index(struct xkb_keymap *keymap, const char *name)
     * }
     */
    public static FunctionDescriptor xkb_keymap_led_get_index$descriptor() {
        return xkb_keymap_led_get_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_led_index_t xkb_keymap_led_get_index(struct xkb_keymap *keymap, const char *name)
     * }
     */
    public static MethodHandle xkb_keymap_led_get_index$handle() {
        return xkb_keymap_led_get_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_led_index_t xkb_keymap_led_get_index(struct xkb_keymap *keymap, const char *name)
     * }
     */
    public static MemorySegment xkb_keymap_led_get_index$address() {
        return xkb_keymap_led_get_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_led_index_t xkb_keymap_led_get_index(struct xkb_keymap *keymap, const char *name)
     * }
     */
    public static int xkb_keymap_led_get_index(MemorySegment keymap, MemorySegment name) {
        var mh$ = xkb_keymap_led_get_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_led_get_index", keymap, name);
            }
            return (int)mh$.invokeExact(keymap, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_num_layouts_for_key {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_num_layouts_for_key");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_layout_index_t xkb_keymap_num_layouts_for_key(struct xkb_keymap *keymap, xkb_keycode_t key)
     * }
     */
    public static FunctionDescriptor xkb_keymap_num_layouts_for_key$descriptor() {
        return xkb_keymap_num_layouts_for_key.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_layout_index_t xkb_keymap_num_layouts_for_key(struct xkb_keymap *keymap, xkb_keycode_t key)
     * }
     */
    public static MethodHandle xkb_keymap_num_layouts_for_key$handle() {
        return xkb_keymap_num_layouts_for_key.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_layout_index_t xkb_keymap_num_layouts_for_key(struct xkb_keymap *keymap, xkb_keycode_t key)
     * }
     */
    public static MemorySegment xkb_keymap_num_layouts_for_key$address() {
        return xkb_keymap_num_layouts_for_key.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_layout_index_t xkb_keymap_num_layouts_for_key(struct xkb_keymap *keymap, xkb_keycode_t key)
     * }
     */
    public static int xkb_keymap_num_layouts_for_key(MemorySegment keymap, int key) {
        var mh$ = xkb_keymap_num_layouts_for_key.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_num_layouts_for_key", keymap, key);
            }
            return (int)mh$.invokeExact(keymap, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_num_levels_for_key {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_num_levels_for_key");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_level_index_t xkb_keymap_num_levels_for_key(struct xkb_keymap *keymap, xkb_keycode_t key, xkb_layout_index_t layout)
     * }
     */
    public static FunctionDescriptor xkb_keymap_num_levels_for_key$descriptor() {
        return xkb_keymap_num_levels_for_key.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_level_index_t xkb_keymap_num_levels_for_key(struct xkb_keymap *keymap, xkb_keycode_t key, xkb_layout_index_t layout)
     * }
     */
    public static MethodHandle xkb_keymap_num_levels_for_key$handle() {
        return xkb_keymap_num_levels_for_key.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_level_index_t xkb_keymap_num_levels_for_key(struct xkb_keymap *keymap, xkb_keycode_t key, xkb_layout_index_t layout)
     * }
     */
    public static MemorySegment xkb_keymap_num_levels_for_key$address() {
        return xkb_keymap_num_levels_for_key.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_level_index_t xkb_keymap_num_levels_for_key(struct xkb_keymap *keymap, xkb_keycode_t key, xkb_layout_index_t layout)
     * }
     */
    public static int xkb_keymap_num_levels_for_key(MemorySegment keymap, int key, int layout) {
        var mh$ = xkb_keymap_num_levels_for_key.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_num_levels_for_key", keymap, key, layout);
            }
            return (int)mh$.invokeExact(keymap, key, layout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_key_get_mods_for_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_LONG
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_key_get_mods_for_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t xkb_keymap_key_get_mods_for_level(struct xkb_keymap *keymap, xkb_keycode_t key, xkb_layout_index_t layout, xkb_level_index_t level, xkb_mod_mask_t *masks_out, size_t masks_size)
     * }
     */
    public static FunctionDescriptor xkb_keymap_key_get_mods_for_level$descriptor() {
        return xkb_keymap_key_get_mods_for_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t xkb_keymap_key_get_mods_for_level(struct xkb_keymap *keymap, xkb_keycode_t key, xkb_layout_index_t layout, xkb_level_index_t level, xkb_mod_mask_t *masks_out, size_t masks_size)
     * }
     */
    public static MethodHandle xkb_keymap_key_get_mods_for_level$handle() {
        return xkb_keymap_key_get_mods_for_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t xkb_keymap_key_get_mods_for_level(struct xkb_keymap *keymap, xkb_keycode_t key, xkb_layout_index_t layout, xkb_level_index_t level, xkb_mod_mask_t *masks_out, size_t masks_size)
     * }
     */
    public static MemorySegment xkb_keymap_key_get_mods_for_level$address() {
        return xkb_keymap_key_get_mods_for_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t xkb_keymap_key_get_mods_for_level(struct xkb_keymap *keymap, xkb_keycode_t key, xkb_layout_index_t layout, xkb_level_index_t level, xkb_mod_mask_t *masks_out, size_t masks_size)
     * }
     */
    public static long xkb_keymap_key_get_mods_for_level(MemorySegment keymap, int key, int layout, int level, MemorySegment masks_out, long masks_size) {
        var mh$ = xkb_keymap_key_get_mods_for_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_key_get_mods_for_level", keymap, key, layout, level, masks_out, masks_size);
            }
            return (long)mh$.invokeExact(keymap, key, layout, level, masks_out, masks_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_key_get_syms_by_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_key_get_syms_by_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xkb_keymap_key_get_syms_by_level(struct xkb_keymap *keymap, xkb_keycode_t key, xkb_layout_index_t layout, xkb_level_index_t level, const xkb_keysym_t **syms_out)
     * }
     */
    public static FunctionDescriptor xkb_keymap_key_get_syms_by_level$descriptor() {
        return xkb_keymap_key_get_syms_by_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xkb_keymap_key_get_syms_by_level(struct xkb_keymap *keymap, xkb_keycode_t key, xkb_layout_index_t layout, xkb_level_index_t level, const xkb_keysym_t **syms_out)
     * }
     */
    public static MethodHandle xkb_keymap_key_get_syms_by_level$handle() {
        return xkb_keymap_key_get_syms_by_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xkb_keymap_key_get_syms_by_level(struct xkb_keymap *keymap, xkb_keycode_t key, xkb_layout_index_t layout, xkb_level_index_t level, const xkb_keysym_t **syms_out)
     * }
     */
    public static MemorySegment xkb_keymap_key_get_syms_by_level$address() {
        return xkb_keymap_key_get_syms_by_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xkb_keymap_key_get_syms_by_level(struct xkb_keymap *keymap, xkb_keycode_t key, xkb_layout_index_t layout, xkb_level_index_t level, const xkb_keysym_t **syms_out)
     * }
     */
    public static int xkb_keymap_key_get_syms_by_level(MemorySegment keymap, int key, int layout, int level, MemorySegment syms_out) {
        var mh$ = xkb_keymap_key_get_syms_by_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_key_get_syms_by_level", keymap, key, layout, level, syms_out);
            }
            return (int)mh$.invokeExact(keymap, key, layout, level, syms_out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_keymap_key_repeats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_keymap_key_repeats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xkb_keymap_key_repeats(struct xkb_keymap *keymap, xkb_keycode_t key)
     * }
     */
    public static FunctionDescriptor xkb_keymap_key_repeats$descriptor() {
        return xkb_keymap_key_repeats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xkb_keymap_key_repeats(struct xkb_keymap *keymap, xkb_keycode_t key)
     * }
     */
    public static MethodHandle xkb_keymap_key_repeats$handle() {
        return xkb_keymap_key_repeats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xkb_keymap_key_repeats(struct xkb_keymap *keymap, xkb_keycode_t key)
     * }
     */
    public static MemorySegment xkb_keymap_key_repeats$address() {
        return xkb_keymap_key_repeats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xkb_keymap_key_repeats(struct xkb_keymap *keymap, xkb_keycode_t key)
     * }
     */
    public static int xkb_keymap_key_repeats(MemorySegment keymap, int key) {
        var mh$ = xkb_keymap_key_repeats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_keymap_key_repeats", keymap, key);
            }
            return (int)mh$.invokeExact(keymap, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct xkb_state *xkb_state_new(struct xkb_keymap *keymap)
     * }
     */
    public static FunctionDescriptor xkb_state_new$descriptor() {
        return xkb_state_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct xkb_state *xkb_state_new(struct xkb_keymap *keymap)
     * }
     */
    public static MethodHandle xkb_state_new$handle() {
        return xkb_state_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct xkb_state *xkb_state_new(struct xkb_keymap *keymap)
     * }
     */
    public static MemorySegment xkb_state_new$address() {
        return xkb_state_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct xkb_state *xkb_state_new(struct xkb_keymap *keymap)
     * }
     */
    public static MemorySegment xkb_state_new(MemorySegment keymap) {
        var mh$ = xkb_state_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_new", keymap);
            }
            return (MemorySegment)mh$.invokeExact(keymap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct xkb_state *xkb_state_ref(struct xkb_state *state)
     * }
     */
    public static FunctionDescriptor xkb_state_ref$descriptor() {
        return xkb_state_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct xkb_state *xkb_state_ref(struct xkb_state *state)
     * }
     */
    public static MethodHandle xkb_state_ref$handle() {
        return xkb_state_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct xkb_state *xkb_state_ref(struct xkb_state *state)
     * }
     */
    public static MemorySegment xkb_state_ref$address() {
        return xkb_state_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct xkb_state *xkb_state_ref(struct xkb_state *state)
     * }
     */
    public static MemorySegment xkb_state_ref(MemorySegment state) {
        var mh$ = xkb_state_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_ref", state);
            }
            return (MemorySegment)mh$.invokeExact(state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xkb_state_unref(struct xkb_state *state)
     * }
     */
    public static FunctionDescriptor xkb_state_unref$descriptor() {
        return xkb_state_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xkb_state_unref(struct xkb_state *state)
     * }
     */
    public static MethodHandle xkb_state_unref$handle() {
        return xkb_state_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xkb_state_unref(struct xkb_state *state)
     * }
     */
    public static MemorySegment xkb_state_unref$address() {
        return xkb_state_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xkb_state_unref(struct xkb_state *state)
     * }
     */
    public static void xkb_state_unref(MemorySegment state) {
        var mh$ = xkb_state_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_unref", state);
            }
            mh$.invokeExact(state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_get_keymap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_get_keymap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_state_get_keymap(struct xkb_state *state)
     * }
     */
    public static FunctionDescriptor xkb_state_get_keymap$descriptor() {
        return xkb_state_get_keymap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_state_get_keymap(struct xkb_state *state)
     * }
     */
    public static MethodHandle xkb_state_get_keymap$handle() {
        return xkb_state_get_keymap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_state_get_keymap(struct xkb_state *state)
     * }
     */
    public static MemorySegment xkb_state_get_keymap$address() {
        return xkb_state_get_keymap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct xkb_keymap *xkb_state_get_keymap(struct xkb_state *state)
     * }
     */
    public static MemorySegment xkb_state_get_keymap(MemorySegment state) {
        var mh$ = xkb_state_get_keymap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_get_keymap", state);
            }
            return (MemorySegment)mh$.invokeExact(state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int XKB_KEY_UP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum xkb_key_direction.XKB_KEY_UP = 0
     * }
     */
    public static int XKB_KEY_UP() {
        return XKB_KEY_UP;
    }
    private static final int XKB_KEY_DOWN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum xkb_key_direction.XKB_KEY_DOWN = 1
     * }
     */
    public static int XKB_KEY_DOWN() {
        return XKB_KEY_DOWN;
    }
    private static final int XKB_STATE_MODS_DEPRESSED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum xkb_state_component.XKB_STATE_MODS_DEPRESSED = 1
     * }
     */
    public static int XKB_STATE_MODS_DEPRESSED() {
        return XKB_STATE_MODS_DEPRESSED;
    }
    private static final int XKB_STATE_MODS_LATCHED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum xkb_state_component.XKB_STATE_MODS_LATCHED = 2
     * }
     */
    public static int XKB_STATE_MODS_LATCHED() {
        return XKB_STATE_MODS_LATCHED;
    }
    private static final int XKB_STATE_MODS_LOCKED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum xkb_state_component.XKB_STATE_MODS_LOCKED = 4
     * }
     */
    public static int XKB_STATE_MODS_LOCKED() {
        return XKB_STATE_MODS_LOCKED;
    }
    private static final int XKB_STATE_MODS_EFFECTIVE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum xkb_state_component.XKB_STATE_MODS_EFFECTIVE = 8
     * }
     */
    public static int XKB_STATE_MODS_EFFECTIVE() {
        return XKB_STATE_MODS_EFFECTIVE;
    }
    private static final int XKB_STATE_LAYOUT_DEPRESSED = (int)16L;
    /**
     * {@snippet lang=c :
     * enum xkb_state_component.XKB_STATE_LAYOUT_DEPRESSED = 16
     * }
     */
    public static int XKB_STATE_LAYOUT_DEPRESSED() {
        return XKB_STATE_LAYOUT_DEPRESSED;
    }
    private static final int XKB_STATE_LAYOUT_LATCHED = (int)32L;
    /**
     * {@snippet lang=c :
     * enum xkb_state_component.XKB_STATE_LAYOUT_LATCHED = 32
     * }
     */
    public static int XKB_STATE_LAYOUT_LATCHED() {
        return XKB_STATE_LAYOUT_LATCHED;
    }
    private static final int XKB_STATE_LAYOUT_LOCKED = (int)64L;
    /**
     * {@snippet lang=c :
     * enum xkb_state_component.XKB_STATE_LAYOUT_LOCKED = 64
     * }
     */
    public static int XKB_STATE_LAYOUT_LOCKED() {
        return XKB_STATE_LAYOUT_LOCKED;
    }
    private static final int XKB_STATE_LAYOUT_EFFECTIVE = (int)128L;
    /**
     * {@snippet lang=c :
     * enum xkb_state_component.XKB_STATE_LAYOUT_EFFECTIVE = 128
     * }
     */
    public static int XKB_STATE_LAYOUT_EFFECTIVE() {
        return XKB_STATE_LAYOUT_EFFECTIVE;
    }
    private static final int XKB_STATE_LEDS = (int)256L;
    /**
     * {@snippet lang=c :
     * enum xkb_state_component.XKB_STATE_LEDS = 256
     * }
     */
    public static int XKB_STATE_LEDS() {
        return XKB_STATE_LEDS;
    }

    private static class xkb_state_update_key {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_update_key");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum xkb_state_component xkb_state_update_key(struct xkb_state *state, xkb_keycode_t key, enum xkb_key_direction direction)
     * }
     */
    public static FunctionDescriptor xkb_state_update_key$descriptor() {
        return xkb_state_update_key.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum xkb_state_component xkb_state_update_key(struct xkb_state *state, xkb_keycode_t key, enum xkb_key_direction direction)
     * }
     */
    public static MethodHandle xkb_state_update_key$handle() {
        return xkb_state_update_key.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum xkb_state_component xkb_state_update_key(struct xkb_state *state, xkb_keycode_t key, enum xkb_key_direction direction)
     * }
     */
    public static MemorySegment xkb_state_update_key$address() {
        return xkb_state_update_key.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum xkb_state_component xkb_state_update_key(struct xkb_state *state, xkb_keycode_t key, enum xkb_key_direction direction)
     * }
     */
    public static int xkb_state_update_key(MemorySegment state, int key, int direction) {
        var mh$ = xkb_state_update_key.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_update_key", state, key, direction);
            }
            return (int)mh$.invokeExact(state, key, direction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_update_mask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_update_mask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum xkb_state_component xkb_state_update_mask(struct xkb_state *state, xkb_mod_mask_t depressed_mods, xkb_mod_mask_t latched_mods, xkb_mod_mask_t locked_mods, xkb_layout_index_t depressed_layout, xkb_layout_index_t latched_layout, xkb_layout_index_t locked_layout)
     * }
     */
    public static FunctionDescriptor xkb_state_update_mask$descriptor() {
        return xkb_state_update_mask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum xkb_state_component xkb_state_update_mask(struct xkb_state *state, xkb_mod_mask_t depressed_mods, xkb_mod_mask_t latched_mods, xkb_mod_mask_t locked_mods, xkb_layout_index_t depressed_layout, xkb_layout_index_t latched_layout, xkb_layout_index_t locked_layout)
     * }
     */
    public static MethodHandle xkb_state_update_mask$handle() {
        return xkb_state_update_mask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum xkb_state_component xkb_state_update_mask(struct xkb_state *state, xkb_mod_mask_t depressed_mods, xkb_mod_mask_t latched_mods, xkb_mod_mask_t locked_mods, xkb_layout_index_t depressed_layout, xkb_layout_index_t latched_layout, xkb_layout_index_t locked_layout)
     * }
     */
    public static MemorySegment xkb_state_update_mask$address() {
        return xkb_state_update_mask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum xkb_state_component xkb_state_update_mask(struct xkb_state *state, xkb_mod_mask_t depressed_mods, xkb_mod_mask_t latched_mods, xkb_mod_mask_t locked_mods, xkb_layout_index_t depressed_layout, xkb_layout_index_t latched_layout, xkb_layout_index_t locked_layout)
     * }
     */
    public static int xkb_state_update_mask(MemorySegment state, int depressed_mods, int latched_mods, int locked_mods, int depressed_layout, int latched_layout, int locked_layout) {
        var mh$ = xkb_state_update_mask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_update_mask", state, depressed_mods, latched_mods, locked_mods, depressed_layout, latched_layout, locked_layout);
            }
            return (int)mh$.invokeExact(state, depressed_mods, latched_mods, locked_mods, depressed_layout, latched_layout, locked_layout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_key_get_syms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_key_get_syms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xkb_state_key_get_syms(struct xkb_state *state, xkb_keycode_t key, const xkb_keysym_t **syms_out)
     * }
     */
    public static FunctionDescriptor xkb_state_key_get_syms$descriptor() {
        return xkb_state_key_get_syms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xkb_state_key_get_syms(struct xkb_state *state, xkb_keycode_t key, const xkb_keysym_t **syms_out)
     * }
     */
    public static MethodHandle xkb_state_key_get_syms$handle() {
        return xkb_state_key_get_syms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xkb_state_key_get_syms(struct xkb_state *state, xkb_keycode_t key, const xkb_keysym_t **syms_out)
     * }
     */
    public static MemorySegment xkb_state_key_get_syms$address() {
        return xkb_state_key_get_syms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xkb_state_key_get_syms(struct xkb_state *state, xkb_keycode_t key, const xkb_keysym_t **syms_out)
     * }
     */
    public static int xkb_state_key_get_syms(MemorySegment state, int key, MemorySegment syms_out) {
        var mh$ = xkb_state_key_get_syms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_key_get_syms", state, key, syms_out);
            }
            return (int)mh$.invokeExact(state, key, syms_out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_key_get_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER,
            C.C_LONG
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_key_get_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xkb_state_key_get_utf8(struct xkb_state *state, xkb_keycode_t key, char *buffer, size_t size)
     * }
     */
    public static FunctionDescriptor xkb_state_key_get_utf8$descriptor() {
        return xkb_state_key_get_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xkb_state_key_get_utf8(struct xkb_state *state, xkb_keycode_t key, char *buffer, size_t size)
     * }
     */
    public static MethodHandle xkb_state_key_get_utf8$handle() {
        return xkb_state_key_get_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xkb_state_key_get_utf8(struct xkb_state *state, xkb_keycode_t key, char *buffer, size_t size)
     * }
     */
    public static MemorySegment xkb_state_key_get_utf8$address() {
        return xkb_state_key_get_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xkb_state_key_get_utf8(struct xkb_state *state, xkb_keycode_t key, char *buffer, size_t size)
     * }
     */
    public static int xkb_state_key_get_utf8(MemorySegment state, int key, MemorySegment buffer, long size) {
        var mh$ = xkb_state_key_get_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_key_get_utf8", state, key, buffer, size);
            }
            return (int)mh$.invokeExact(state, key, buffer, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_key_get_utf32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_key_get_utf32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t xkb_state_key_get_utf32(struct xkb_state *state, xkb_keycode_t key)
     * }
     */
    public static FunctionDescriptor xkb_state_key_get_utf32$descriptor() {
        return xkb_state_key_get_utf32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t xkb_state_key_get_utf32(struct xkb_state *state, xkb_keycode_t key)
     * }
     */
    public static MethodHandle xkb_state_key_get_utf32$handle() {
        return xkb_state_key_get_utf32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t xkb_state_key_get_utf32(struct xkb_state *state, xkb_keycode_t key)
     * }
     */
    public static MemorySegment xkb_state_key_get_utf32$address() {
        return xkb_state_key_get_utf32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t xkb_state_key_get_utf32(struct xkb_state *state, xkb_keycode_t key)
     * }
     */
    public static int xkb_state_key_get_utf32(MemorySegment state, int key) {
        var mh$ = xkb_state_key_get_utf32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_key_get_utf32", state, key);
            }
            return (int)mh$.invokeExact(state, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_key_get_one_sym {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_key_get_one_sym");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_keysym_t xkb_state_key_get_one_sym(struct xkb_state *state, xkb_keycode_t key)
     * }
     */
    public static FunctionDescriptor xkb_state_key_get_one_sym$descriptor() {
        return xkb_state_key_get_one_sym.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_keysym_t xkb_state_key_get_one_sym(struct xkb_state *state, xkb_keycode_t key)
     * }
     */
    public static MethodHandle xkb_state_key_get_one_sym$handle() {
        return xkb_state_key_get_one_sym.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_keysym_t xkb_state_key_get_one_sym(struct xkb_state *state, xkb_keycode_t key)
     * }
     */
    public static MemorySegment xkb_state_key_get_one_sym$address() {
        return xkb_state_key_get_one_sym.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_keysym_t xkb_state_key_get_one_sym(struct xkb_state *state, xkb_keycode_t key)
     * }
     */
    public static int xkb_state_key_get_one_sym(MemorySegment state, int key) {
        var mh$ = xkb_state_key_get_one_sym.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_key_get_one_sym", state, key);
            }
            return (int)mh$.invokeExact(state, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_key_get_layout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_key_get_layout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_layout_index_t xkb_state_key_get_layout(struct xkb_state *state, xkb_keycode_t key)
     * }
     */
    public static FunctionDescriptor xkb_state_key_get_layout$descriptor() {
        return xkb_state_key_get_layout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_layout_index_t xkb_state_key_get_layout(struct xkb_state *state, xkb_keycode_t key)
     * }
     */
    public static MethodHandle xkb_state_key_get_layout$handle() {
        return xkb_state_key_get_layout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_layout_index_t xkb_state_key_get_layout(struct xkb_state *state, xkb_keycode_t key)
     * }
     */
    public static MemorySegment xkb_state_key_get_layout$address() {
        return xkb_state_key_get_layout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_layout_index_t xkb_state_key_get_layout(struct xkb_state *state, xkb_keycode_t key)
     * }
     */
    public static int xkb_state_key_get_layout(MemorySegment state, int key) {
        var mh$ = xkb_state_key_get_layout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_key_get_layout", state, key);
            }
            return (int)mh$.invokeExact(state, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_key_get_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_key_get_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_level_index_t xkb_state_key_get_level(struct xkb_state *state, xkb_keycode_t key, xkb_layout_index_t layout)
     * }
     */
    public static FunctionDescriptor xkb_state_key_get_level$descriptor() {
        return xkb_state_key_get_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_level_index_t xkb_state_key_get_level(struct xkb_state *state, xkb_keycode_t key, xkb_layout_index_t layout)
     * }
     */
    public static MethodHandle xkb_state_key_get_level$handle() {
        return xkb_state_key_get_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_level_index_t xkb_state_key_get_level(struct xkb_state *state, xkb_keycode_t key, xkb_layout_index_t layout)
     * }
     */
    public static MemorySegment xkb_state_key_get_level$address() {
        return xkb_state_key_get_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_level_index_t xkb_state_key_get_level(struct xkb_state *state, xkb_keycode_t key, xkb_layout_index_t layout)
     * }
     */
    public static int xkb_state_key_get_level(MemorySegment state, int key, int layout) {
        var mh$ = xkb_state_key_get_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_key_get_level", state, key, layout);
            }
            return (int)mh$.invokeExact(state, key, layout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int XKB_STATE_MATCH_ANY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum xkb_state_match.XKB_STATE_MATCH_ANY = 1
     * }
     */
    public static int XKB_STATE_MATCH_ANY() {
        return XKB_STATE_MATCH_ANY;
    }
    private static final int XKB_STATE_MATCH_ALL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum xkb_state_match.XKB_STATE_MATCH_ALL = 2
     * }
     */
    public static int XKB_STATE_MATCH_ALL() {
        return XKB_STATE_MATCH_ALL;
    }
    private static final int XKB_STATE_MATCH_NON_EXCLUSIVE = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum xkb_state_match.XKB_STATE_MATCH_NON_EXCLUSIVE = 65536
     * }
     */
    public static int XKB_STATE_MATCH_NON_EXCLUSIVE() {
        return XKB_STATE_MATCH_NON_EXCLUSIVE;
    }

    private static class xkb_state_serialize_mods {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_serialize_mods");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_mod_mask_t xkb_state_serialize_mods(struct xkb_state *state, enum xkb_state_component components)
     * }
     */
    public static FunctionDescriptor xkb_state_serialize_mods$descriptor() {
        return xkb_state_serialize_mods.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_mod_mask_t xkb_state_serialize_mods(struct xkb_state *state, enum xkb_state_component components)
     * }
     */
    public static MethodHandle xkb_state_serialize_mods$handle() {
        return xkb_state_serialize_mods.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_mod_mask_t xkb_state_serialize_mods(struct xkb_state *state, enum xkb_state_component components)
     * }
     */
    public static MemorySegment xkb_state_serialize_mods$address() {
        return xkb_state_serialize_mods.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_mod_mask_t xkb_state_serialize_mods(struct xkb_state *state, enum xkb_state_component components)
     * }
     */
    public static int xkb_state_serialize_mods(MemorySegment state, int components) {
        var mh$ = xkb_state_serialize_mods.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_serialize_mods", state, components);
            }
            return (int)mh$.invokeExact(state, components);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_serialize_layout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_serialize_layout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_layout_index_t xkb_state_serialize_layout(struct xkb_state *state, enum xkb_state_component components)
     * }
     */
    public static FunctionDescriptor xkb_state_serialize_layout$descriptor() {
        return xkb_state_serialize_layout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_layout_index_t xkb_state_serialize_layout(struct xkb_state *state, enum xkb_state_component components)
     * }
     */
    public static MethodHandle xkb_state_serialize_layout$handle() {
        return xkb_state_serialize_layout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_layout_index_t xkb_state_serialize_layout(struct xkb_state *state, enum xkb_state_component components)
     * }
     */
    public static MemorySegment xkb_state_serialize_layout$address() {
        return xkb_state_serialize_layout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_layout_index_t xkb_state_serialize_layout(struct xkb_state *state, enum xkb_state_component components)
     * }
     */
    public static int xkb_state_serialize_layout(MemorySegment state, int components) {
        var mh$ = xkb_state_serialize_layout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_serialize_layout", state, components);
            }
            return (int)mh$.invokeExact(state, components);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_mod_name_is_active {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_mod_name_is_active");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xkb_state_mod_name_is_active(struct xkb_state *state, const char *name, enum xkb_state_component type)
     * }
     */
    public static FunctionDescriptor xkb_state_mod_name_is_active$descriptor() {
        return xkb_state_mod_name_is_active.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xkb_state_mod_name_is_active(struct xkb_state *state, const char *name, enum xkb_state_component type)
     * }
     */
    public static MethodHandle xkb_state_mod_name_is_active$handle() {
        return xkb_state_mod_name_is_active.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xkb_state_mod_name_is_active(struct xkb_state *state, const char *name, enum xkb_state_component type)
     * }
     */
    public static MemorySegment xkb_state_mod_name_is_active$address() {
        return xkb_state_mod_name_is_active.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xkb_state_mod_name_is_active(struct xkb_state *state, const char *name, enum xkb_state_component type)
     * }
     */
    public static int xkb_state_mod_name_is_active(MemorySegment state, MemorySegment name, int type) {
        var mh$ = xkb_state_mod_name_is_active.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_mod_name_is_active", state, name, type);
            }
            return (int)mh$.invokeExact(state, name, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int xkb_state_mod_names_are_active(struct xkb_state *state, enum xkb_state_component type, enum xkb_state_match match, ...)
     * }
     */
    public static class xkb_state_mod_names_are_active {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                C.C_INT,
                C.C_POINTER,
                C.C_INT,
                C.C_INT
            );
        private static final MemorySegment ADDR = C.findOrThrow("xkb_state_mod_names_are_active");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private xkb_state_mod_names_are_active(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int xkb_state_mod_names_are_active(struct xkb_state *state, enum xkb_state_component type, enum xkb_state_match match, ...)
         * }
         */
        public static xkb_state_mod_names_are_active makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new xkb_state_mod_names_are_active(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment state, int type, int match, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("xkb_state_mod_names_are_active", state, type, match, x3);
                }
                return (int) spreader.invokeExact(state, type, match, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class xkb_state_mod_index_is_active {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_mod_index_is_active");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xkb_state_mod_index_is_active(struct xkb_state *state, xkb_mod_index_t idx, enum xkb_state_component type)
     * }
     */
    public static FunctionDescriptor xkb_state_mod_index_is_active$descriptor() {
        return xkb_state_mod_index_is_active.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xkb_state_mod_index_is_active(struct xkb_state *state, xkb_mod_index_t idx, enum xkb_state_component type)
     * }
     */
    public static MethodHandle xkb_state_mod_index_is_active$handle() {
        return xkb_state_mod_index_is_active.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xkb_state_mod_index_is_active(struct xkb_state *state, xkb_mod_index_t idx, enum xkb_state_component type)
     * }
     */
    public static MemorySegment xkb_state_mod_index_is_active$address() {
        return xkb_state_mod_index_is_active.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xkb_state_mod_index_is_active(struct xkb_state *state, xkb_mod_index_t idx, enum xkb_state_component type)
     * }
     */
    public static int xkb_state_mod_index_is_active(MemorySegment state, int idx, int type) {
        var mh$ = xkb_state_mod_index_is_active.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_mod_index_is_active", state, idx, type);
            }
            return (int)mh$.invokeExact(state, idx, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int xkb_state_mod_indices_are_active(struct xkb_state *state, enum xkb_state_component type, enum xkb_state_match match, ...)
     * }
     */
    public static class xkb_state_mod_indices_are_active {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                C.C_INT,
                C.C_POINTER,
                C.C_INT,
                C.C_INT
            );
        private static final MemorySegment ADDR = C.findOrThrow("xkb_state_mod_indices_are_active");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private xkb_state_mod_indices_are_active(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int xkb_state_mod_indices_are_active(struct xkb_state *state, enum xkb_state_component type, enum xkb_state_match match, ...)
         * }
         */
        public static xkb_state_mod_indices_are_active makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new xkb_state_mod_indices_are_active(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment state, int type, int match, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("xkb_state_mod_indices_are_active", state, type, match, x3);
                }
                return (int) spreader.invokeExact(state, type, match, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    private static final int XKB_CONSUMED_MODE_XKB = (int)0L;
    /**
     * {@snippet lang=c :
     * enum xkb_consumed_mode.XKB_CONSUMED_MODE_XKB = 0
     * }
     */
    public static int XKB_CONSUMED_MODE_XKB() {
        return XKB_CONSUMED_MODE_XKB;
    }
    private static final int XKB_CONSUMED_MODE_GTK = (int)1L;
    /**
     * {@snippet lang=c :
     * enum xkb_consumed_mode.XKB_CONSUMED_MODE_GTK = 1
     * }
     */
    public static int XKB_CONSUMED_MODE_GTK() {
        return XKB_CONSUMED_MODE_GTK;
    }

    private static class xkb_state_key_get_consumed_mods2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_key_get_consumed_mods2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_mod_mask_t xkb_state_key_get_consumed_mods2(struct xkb_state *state, xkb_keycode_t key, enum xkb_consumed_mode mode)
     * }
     */
    public static FunctionDescriptor xkb_state_key_get_consumed_mods2$descriptor() {
        return xkb_state_key_get_consumed_mods2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_mod_mask_t xkb_state_key_get_consumed_mods2(struct xkb_state *state, xkb_keycode_t key, enum xkb_consumed_mode mode)
     * }
     */
    public static MethodHandle xkb_state_key_get_consumed_mods2$handle() {
        return xkb_state_key_get_consumed_mods2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_mod_mask_t xkb_state_key_get_consumed_mods2(struct xkb_state *state, xkb_keycode_t key, enum xkb_consumed_mode mode)
     * }
     */
    public static MemorySegment xkb_state_key_get_consumed_mods2$address() {
        return xkb_state_key_get_consumed_mods2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_mod_mask_t xkb_state_key_get_consumed_mods2(struct xkb_state *state, xkb_keycode_t key, enum xkb_consumed_mode mode)
     * }
     */
    public static int xkb_state_key_get_consumed_mods2(MemorySegment state, int key, int mode) {
        var mh$ = xkb_state_key_get_consumed_mods2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_key_get_consumed_mods2", state, key, mode);
            }
            return (int)mh$.invokeExact(state, key, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_key_get_consumed_mods {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_key_get_consumed_mods");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_mod_mask_t xkb_state_key_get_consumed_mods(struct xkb_state *state, xkb_keycode_t key)
     * }
     */
    public static FunctionDescriptor xkb_state_key_get_consumed_mods$descriptor() {
        return xkb_state_key_get_consumed_mods.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_mod_mask_t xkb_state_key_get_consumed_mods(struct xkb_state *state, xkb_keycode_t key)
     * }
     */
    public static MethodHandle xkb_state_key_get_consumed_mods$handle() {
        return xkb_state_key_get_consumed_mods.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_mod_mask_t xkb_state_key_get_consumed_mods(struct xkb_state *state, xkb_keycode_t key)
     * }
     */
    public static MemorySegment xkb_state_key_get_consumed_mods$address() {
        return xkb_state_key_get_consumed_mods.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_mod_mask_t xkb_state_key_get_consumed_mods(struct xkb_state *state, xkb_keycode_t key)
     * }
     */
    public static int xkb_state_key_get_consumed_mods(MemorySegment state, int key) {
        var mh$ = xkb_state_key_get_consumed_mods.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_key_get_consumed_mods", state, key);
            }
            return (int)mh$.invokeExact(state, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_mod_index_is_consumed2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_mod_index_is_consumed2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xkb_state_mod_index_is_consumed2(struct xkb_state *state, xkb_keycode_t key, xkb_mod_index_t idx, enum xkb_consumed_mode mode)
     * }
     */
    public static FunctionDescriptor xkb_state_mod_index_is_consumed2$descriptor() {
        return xkb_state_mod_index_is_consumed2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xkb_state_mod_index_is_consumed2(struct xkb_state *state, xkb_keycode_t key, xkb_mod_index_t idx, enum xkb_consumed_mode mode)
     * }
     */
    public static MethodHandle xkb_state_mod_index_is_consumed2$handle() {
        return xkb_state_mod_index_is_consumed2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xkb_state_mod_index_is_consumed2(struct xkb_state *state, xkb_keycode_t key, xkb_mod_index_t idx, enum xkb_consumed_mode mode)
     * }
     */
    public static MemorySegment xkb_state_mod_index_is_consumed2$address() {
        return xkb_state_mod_index_is_consumed2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xkb_state_mod_index_is_consumed2(struct xkb_state *state, xkb_keycode_t key, xkb_mod_index_t idx, enum xkb_consumed_mode mode)
     * }
     */
    public static int xkb_state_mod_index_is_consumed2(MemorySegment state, int key, int idx, int mode) {
        var mh$ = xkb_state_mod_index_is_consumed2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_mod_index_is_consumed2", state, key, idx, mode);
            }
            return (int)mh$.invokeExact(state, key, idx, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_mod_index_is_consumed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_mod_index_is_consumed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xkb_state_mod_index_is_consumed(struct xkb_state *state, xkb_keycode_t key, xkb_mod_index_t idx)
     * }
     */
    public static FunctionDescriptor xkb_state_mod_index_is_consumed$descriptor() {
        return xkb_state_mod_index_is_consumed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xkb_state_mod_index_is_consumed(struct xkb_state *state, xkb_keycode_t key, xkb_mod_index_t idx)
     * }
     */
    public static MethodHandle xkb_state_mod_index_is_consumed$handle() {
        return xkb_state_mod_index_is_consumed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xkb_state_mod_index_is_consumed(struct xkb_state *state, xkb_keycode_t key, xkb_mod_index_t idx)
     * }
     */
    public static MemorySegment xkb_state_mod_index_is_consumed$address() {
        return xkb_state_mod_index_is_consumed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xkb_state_mod_index_is_consumed(struct xkb_state *state, xkb_keycode_t key, xkb_mod_index_t idx)
     * }
     */
    public static int xkb_state_mod_index_is_consumed(MemorySegment state, int key, int idx) {
        var mh$ = xkb_state_mod_index_is_consumed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_mod_index_is_consumed", state, key, idx);
            }
            return (int)mh$.invokeExact(state, key, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_mod_mask_remove_consumed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_mod_mask_remove_consumed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xkb_mod_mask_t xkb_state_mod_mask_remove_consumed(struct xkb_state *state, xkb_keycode_t key, xkb_mod_mask_t mask)
     * }
     */
    public static FunctionDescriptor xkb_state_mod_mask_remove_consumed$descriptor() {
        return xkb_state_mod_mask_remove_consumed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xkb_mod_mask_t xkb_state_mod_mask_remove_consumed(struct xkb_state *state, xkb_keycode_t key, xkb_mod_mask_t mask)
     * }
     */
    public static MethodHandle xkb_state_mod_mask_remove_consumed$handle() {
        return xkb_state_mod_mask_remove_consumed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xkb_mod_mask_t xkb_state_mod_mask_remove_consumed(struct xkb_state *state, xkb_keycode_t key, xkb_mod_mask_t mask)
     * }
     */
    public static MemorySegment xkb_state_mod_mask_remove_consumed$address() {
        return xkb_state_mod_mask_remove_consumed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xkb_mod_mask_t xkb_state_mod_mask_remove_consumed(struct xkb_state *state, xkb_keycode_t key, xkb_mod_mask_t mask)
     * }
     */
    public static int xkb_state_mod_mask_remove_consumed(MemorySegment state, int key, int mask) {
        var mh$ = xkb_state_mod_mask_remove_consumed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_mod_mask_remove_consumed", state, key, mask);
            }
            return (int)mh$.invokeExact(state, key, mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_layout_name_is_active {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_layout_name_is_active");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xkb_state_layout_name_is_active(struct xkb_state *state, const char *name, enum xkb_state_component type)
     * }
     */
    public static FunctionDescriptor xkb_state_layout_name_is_active$descriptor() {
        return xkb_state_layout_name_is_active.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xkb_state_layout_name_is_active(struct xkb_state *state, const char *name, enum xkb_state_component type)
     * }
     */
    public static MethodHandle xkb_state_layout_name_is_active$handle() {
        return xkb_state_layout_name_is_active.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xkb_state_layout_name_is_active(struct xkb_state *state, const char *name, enum xkb_state_component type)
     * }
     */
    public static MemorySegment xkb_state_layout_name_is_active$address() {
        return xkb_state_layout_name_is_active.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xkb_state_layout_name_is_active(struct xkb_state *state, const char *name, enum xkb_state_component type)
     * }
     */
    public static int xkb_state_layout_name_is_active(MemorySegment state, MemorySegment name, int type) {
        var mh$ = xkb_state_layout_name_is_active.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_layout_name_is_active", state, name, type);
            }
            return (int)mh$.invokeExact(state, name, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_layout_index_is_active {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_layout_index_is_active");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xkb_state_layout_index_is_active(struct xkb_state *state, xkb_layout_index_t idx, enum xkb_state_component type)
     * }
     */
    public static FunctionDescriptor xkb_state_layout_index_is_active$descriptor() {
        return xkb_state_layout_index_is_active.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xkb_state_layout_index_is_active(struct xkb_state *state, xkb_layout_index_t idx, enum xkb_state_component type)
     * }
     */
    public static MethodHandle xkb_state_layout_index_is_active$handle() {
        return xkb_state_layout_index_is_active.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xkb_state_layout_index_is_active(struct xkb_state *state, xkb_layout_index_t idx, enum xkb_state_component type)
     * }
     */
    public static MemorySegment xkb_state_layout_index_is_active$address() {
        return xkb_state_layout_index_is_active.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xkb_state_layout_index_is_active(struct xkb_state *state, xkb_layout_index_t idx, enum xkb_state_component type)
     * }
     */
    public static int xkb_state_layout_index_is_active(MemorySegment state, int idx, int type) {
        var mh$ = xkb_state_layout_index_is_active.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_layout_index_is_active", state, idx, type);
            }
            return (int)mh$.invokeExact(state, idx, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_led_name_is_active {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_led_name_is_active");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xkb_state_led_name_is_active(struct xkb_state *state, const char *name)
     * }
     */
    public static FunctionDescriptor xkb_state_led_name_is_active$descriptor() {
        return xkb_state_led_name_is_active.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xkb_state_led_name_is_active(struct xkb_state *state, const char *name)
     * }
     */
    public static MethodHandle xkb_state_led_name_is_active$handle() {
        return xkb_state_led_name_is_active.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xkb_state_led_name_is_active(struct xkb_state *state, const char *name)
     * }
     */
    public static MemorySegment xkb_state_led_name_is_active$address() {
        return xkb_state_led_name_is_active.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xkb_state_led_name_is_active(struct xkb_state *state, const char *name)
     * }
     */
    public static int xkb_state_led_name_is_active(MemorySegment state, MemorySegment name) {
        var mh$ = xkb_state_led_name_is_active.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_led_name_is_active", state, name);
            }
            return (int)mh$.invokeExact(state, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xkb_state_led_index_is_active {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("xkb_state_led_index_is_active");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xkb_state_led_index_is_active(struct xkb_state *state, xkb_led_index_t idx)
     * }
     */
    public static FunctionDescriptor xkb_state_led_index_is_active$descriptor() {
        return xkb_state_led_index_is_active.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xkb_state_led_index_is_active(struct xkb_state *state, xkb_led_index_t idx)
     * }
     */
    public static MethodHandle xkb_state_led_index_is_active$handle() {
        return xkb_state_led_index_is_active.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xkb_state_led_index_is_active(struct xkb_state *state, xkb_led_index_t idx)
     * }
     */
    public static MemorySegment xkb_state_led_index_is_active$address() {
        return xkb_state_led_index_is_active.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xkb_state_led_index_is_active(struct xkb_state *state, xkb_led_index_t idx)
     * }
     */
    public static int xkb_state_led_index_is_active(MemorySegment state, int idx) {
        var mh$ = xkb_state_led_index_is_active.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xkb_state_led_index_is_active", state, idx);
            }
            return (int)mh$.invokeExact(state, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int WLR_LED_NUM_LOCK = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_keyboard_led.WLR_LED_NUM_LOCK = 1
     * }
     */
    public static int WLR_LED_NUM_LOCK() {
        return WLR_LED_NUM_LOCK;
    }
    private static final int WLR_LED_CAPS_LOCK = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wlr_keyboard_led.WLR_LED_CAPS_LOCK = 2
     * }
     */
    public static int WLR_LED_CAPS_LOCK() {
        return WLR_LED_CAPS_LOCK;
    }
    private static final int WLR_LED_SCROLL_LOCK = (int)4L;
    /**
     * {@snippet lang=c :
     * enum wlr_keyboard_led.WLR_LED_SCROLL_LOCK = 4
     * }
     */
    public static int WLR_LED_SCROLL_LOCK() {
        return WLR_LED_SCROLL_LOCK;
    }
    private static final int WLR_MODIFIER_SHIFT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_keyboard_modifier.WLR_MODIFIER_SHIFT = 1
     * }
     */
    public static int WLR_MODIFIER_SHIFT() {
        return WLR_MODIFIER_SHIFT;
    }
    private static final int WLR_MODIFIER_CAPS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wlr_keyboard_modifier.WLR_MODIFIER_CAPS = 2
     * }
     */
    public static int WLR_MODIFIER_CAPS() {
        return WLR_MODIFIER_CAPS;
    }
    private static final int WLR_MODIFIER_CTRL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum wlr_keyboard_modifier.WLR_MODIFIER_CTRL = 4
     * }
     */
    public static int WLR_MODIFIER_CTRL() {
        return WLR_MODIFIER_CTRL;
    }
    private static final int WLR_MODIFIER_ALT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum wlr_keyboard_modifier.WLR_MODIFIER_ALT = 8
     * }
     */
    public static int WLR_MODIFIER_ALT() {
        return WLR_MODIFIER_ALT;
    }
    private static final int WLR_MODIFIER_MOD2 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum wlr_keyboard_modifier.WLR_MODIFIER_MOD2 = 16
     * }
     */
    public static int WLR_MODIFIER_MOD2() {
        return WLR_MODIFIER_MOD2;
    }
    private static final int WLR_MODIFIER_MOD3 = (int)32L;
    /**
     * {@snippet lang=c :
     * enum wlr_keyboard_modifier.WLR_MODIFIER_MOD3 = 32
     * }
     */
    public static int WLR_MODIFIER_MOD3() {
        return WLR_MODIFIER_MOD3;
    }
    private static final int WLR_MODIFIER_LOGO = (int)64L;
    /**
     * {@snippet lang=c :
     * enum wlr_keyboard_modifier.WLR_MODIFIER_LOGO = 64
     * }
     */
    public static int WLR_MODIFIER_LOGO() {
        return WLR_MODIFIER_LOGO;
    }
    private static final int WLR_MODIFIER_MOD5 = (int)128L;
    /**
     * {@snippet lang=c :
     * enum wlr_keyboard_modifier.WLR_MODIFIER_MOD5 = 128
     * }
     */
    public static int WLR_MODIFIER_MOD5() {
        return WLR_MODIFIER_MOD5;
    }

    private static class wlr_keyboard_from_input_device {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_keyboard_from_input_device");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_keyboard *wlr_keyboard_from_input_device(struct wlr_input_device *input_device)
     * }
     */
    public static FunctionDescriptor wlr_keyboard_from_input_device$descriptor() {
        return wlr_keyboard_from_input_device.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_keyboard *wlr_keyboard_from_input_device(struct wlr_input_device *input_device)
     * }
     */
    public static MethodHandle wlr_keyboard_from_input_device$handle() {
        return wlr_keyboard_from_input_device.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_keyboard *wlr_keyboard_from_input_device(struct wlr_input_device *input_device)
     * }
     */
    public static MemorySegment wlr_keyboard_from_input_device$address() {
        return wlr_keyboard_from_input_device.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_keyboard *wlr_keyboard_from_input_device(struct wlr_input_device *input_device)
     * }
     */
    public static MemorySegment wlr_keyboard_from_input_device(MemorySegment input_device) {
        var mh$ = wlr_keyboard_from_input_device.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_keyboard_from_input_device", input_device);
            }
            return (MemorySegment)mh$.invokeExact(input_device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_keyboard_set_keymap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_keyboard_set_keymap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_keyboard_set_keymap(struct wlr_keyboard *kb, struct xkb_keymap *keymap)
     * }
     */
    public static FunctionDescriptor wlr_keyboard_set_keymap$descriptor() {
        return wlr_keyboard_set_keymap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_keyboard_set_keymap(struct wlr_keyboard *kb, struct xkb_keymap *keymap)
     * }
     */
    public static MethodHandle wlr_keyboard_set_keymap$handle() {
        return wlr_keyboard_set_keymap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_keyboard_set_keymap(struct wlr_keyboard *kb, struct xkb_keymap *keymap)
     * }
     */
    public static MemorySegment wlr_keyboard_set_keymap$address() {
        return wlr_keyboard_set_keymap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_keyboard_set_keymap(struct wlr_keyboard *kb, struct xkb_keymap *keymap)
     * }
     */
    public static boolean wlr_keyboard_set_keymap(MemorySegment kb, MemorySegment keymap) {
        var mh$ = wlr_keyboard_set_keymap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_keyboard_set_keymap", kb, keymap);
            }
            return (boolean)mh$.invokeExact(kb, keymap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_keyboard_keymaps_match {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_keyboard_keymaps_match");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_keyboard_keymaps_match(struct xkb_keymap *km1, struct xkb_keymap *km2)
     * }
     */
    public static FunctionDescriptor wlr_keyboard_keymaps_match$descriptor() {
        return wlr_keyboard_keymaps_match.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_keyboard_keymaps_match(struct xkb_keymap *km1, struct xkb_keymap *km2)
     * }
     */
    public static MethodHandle wlr_keyboard_keymaps_match$handle() {
        return wlr_keyboard_keymaps_match.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_keyboard_keymaps_match(struct xkb_keymap *km1, struct xkb_keymap *km2)
     * }
     */
    public static MemorySegment wlr_keyboard_keymaps_match$address() {
        return wlr_keyboard_keymaps_match.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_keyboard_keymaps_match(struct xkb_keymap *km1, struct xkb_keymap *km2)
     * }
     */
    public static boolean wlr_keyboard_keymaps_match(MemorySegment km1, MemorySegment km2) {
        var mh$ = wlr_keyboard_keymaps_match.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_keyboard_keymaps_match", km1, km2);
            }
            return (boolean)mh$.invokeExact(km1, km2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_keyboard_set_repeat_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_keyboard_set_repeat_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_keyboard_set_repeat_info(struct wlr_keyboard *kb, int32_t rate_hz, int32_t delay_ms)
     * }
     */
    public static FunctionDescriptor wlr_keyboard_set_repeat_info$descriptor() {
        return wlr_keyboard_set_repeat_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_keyboard_set_repeat_info(struct wlr_keyboard *kb, int32_t rate_hz, int32_t delay_ms)
     * }
     */
    public static MethodHandle wlr_keyboard_set_repeat_info$handle() {
        return wlr_keyboard_set_repeat_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_keyboard_set_repeat_info(struct wlr_keyboard *kb, int32_t rate_hz, int32_t delay_ms)
     * }
     */
    public static MemorySegment wlr_keyboard_set_repeat_info$address() {
        return wlr_keyboard_set_repeat_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_keyboard_set_repeat_info(struct wlr_keyboard *kb, int32_t rate_hz, int32_t delay_ms)
     * }
     */
    public static void wlr_keyboard_set_repeat_info(MemorySegment kb, int rate_hz, int delay_ms) {
        var mh$ = wlr_keyboard_set_repeat_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_keyboard_set_repeat_info", kb, rate_hz, delay_ms);
            }
            mh$.invokeExact(kb, rate_hz, delay_ms);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_keyboard_led_update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_keyboard_led_update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_keyboard_led_update(struct wlr_keyboard *keyboard, uint32_t leds)
     * }
     */
    public static FunctionDescriptor wlr_keyboard_led_update$descriptor() {
        return wlr_keyboard_led_update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_keyboard_led_update(struct wlr_keyboard *keyboard, uint32_t leds)
     * }
     */
    public static MethodHandle wlr_keyboard_led_update$handle() {
        return wlr_keyboard_led_update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_keyboard_led_update(struct wlr_keyboard *keyboard, uint32_t leds)
     * }
     */
    public static MemorySegment wlr_keyboard_led_update$address() {
        return wlr_keyboard_led_update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_keyboard_led_update(struct wlr_keyboard *keyboard, uint32_t leds)
     * }
     */
    public static void wlr_keyboard_led_update(MemorySegment keyboard, int leds) {
        var mh$ = wlr_keyboard_led_update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_keyboard_led_update", keyboard, leds);
            }
            mh$.invokeExact(keyboard, leds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_keyboard_get_modifiers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_keyboard_get_modifiers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t wlr_keyboard_get_modifiers(struct wlr_keyboard *keyboard)
     * }
     */
    public static FunctionDescriptor wlr_keyboard_get_modifiers$descriptor() {
        return wlr_keyboard_get_modifiers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t wlr_keyboard_get_modifiers(struct wlr_keyboard *keyboard)
     * }
     */
    public static MethodHandle wlr_keyboard_get_modifiers$handle() {
        return wlr_keyboard_get_modifiers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t wlr_keyboard_get_modifiers(struct wlr_keyboard *keyboard)
     * }
     */
    public static MemorySegment wlr_keyboard_get_modifiers$address() {
        return wlr_keyboard_get_modifiers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t wlr_keyboard_get_modifiers(struct wlr_keyboard *keyboard)
     * }
     */
    public static int wlr_keyboard_get_modifiers(MemorySegment keyboard) {
        var mh$ = wlr_keyboard_get_modifiers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_keyboard_get_modifiers", keyboard);
            }
            return (int)mh$.invokeExact(keyboard);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int WLR_AXIS_SOURCE_WHEEL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wlr_axis_source.WLR_AXIS_SOURCE_WHEEL = 0
     * }
     */
    public static int WLR_AXIS_SOURCE_WHEEL() {
        return WLR_AXIS_SOURCE_WHEEL;
    }
    private static final int WLR_AXIS_SOURCE_FINGER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_axis_source.WLR_AXIS_SOURCE_FINGER = 1
     * }
     */
    public static int WLR_AXIS_SOURCE_FINGER() {
        return WLR_AXIS_SOURCE_FINGER;
    }
    private static final int WLR_AXIS_SOURCE_CONTINUOUS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wlr_axis_source.WLR_AXIS_SOURCE_CONTINUOUS = 2
     * }
     */
    public static int WLR_AXIS_SOURCE_CONTINUOUS() {
        return WLR_AXIS_SOURCE_CONTINUOUS;
    }
    private static final int WLR_AXIS_SOURCE_WHEEL_TILT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum wlr_axis_source.WLR_AXIS_SOURCE_WHEEL_TILT = 3
     * }
     */
    public static int WLR_AXIS_SOURCE_WHEEL_TILT() {
        return WLR_AXIS_SOURCE_WHEEL_TILT;
    }
    private static final int WLR_AXIS_ORIENTATION_VERTICAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wlr_axis_orientation.WLR_AXIS_ORIENTATION_VERTICAL = 0
     * }
     */
    public static int WLR_AXIS_ORIENTATION_VERTICAL() {
        return WLR_AXIS_ORIENTATION_VERTICAL;
    }
    private static final int WLR_AXIS_ORIENTATION_HORIZONTAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_axis_orientation.WLR_AXIS_ORIENTATION_HORIZONTAL = 1
     * }
     */
    public static int WLR_AXIS_ORIENTATION_HORIZONTAL() {
        return WLR_AXIS_ORIENTATION_HORIZONTAL;
    }

    private static class wlr_pointer_from_input_device {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_pointer_from_input_device");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_pointer *wlr_pointer_from_input_device(struct wlr_input_device *input_device)
     * }
     */
    public static FunctionDescriptor wlr_pointer_from_input_device$descriptor() {
        return wlr_pointer_from_input_device.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_pointer *wlr_pointer_from_input_device(struct wlr_input_device *input_device)
     * }
     */
    public static MethodHandle wlr_pointer_from_input_device$handle() {
        return wlr_pointer_from_input_device.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_pointer *wlr_pointer_from_input_device(struct wlr_input_device *input_device)
     * }
     */
    public static MemorySegment wlr_pointer_from_input_device$address() {
        return wlr_pointer_from_input_device.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_pointer *wlr_pointer_from_input_device(struct wlr_input_device *input_device)
     * }
     */
    public static MemorySegment wlr_pointer_from_input_device(MemorySegment input_device) {
        var mh$ = wlr_pointer_from_input_device.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_pointer_from_input_device", input_device);
            }
            return (MemorySegment)mh$.invokeExact(input_device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_seat *wlr_seat_create(struct wl_display *display, const char *name)
     * }
     */
    public static FunctionDescriptor wlr_seat_create$descriptor() {
        return wlr_seat_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_seat *wlr_seat_create(struct wl_display *display, const char *name)
     * }
     */
    public static MethodHandle wlr_seat_create$handle() {
        return wlr_seat_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_seat *wlr_seat_create(struct wl_display *display, const char *name)
     * }
     */
    public static MemorySegment wlr_seat_create$address() {
        return wlr_seat_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_seat *wlr_seat_create(struct wl_display *display, const char *name)
     * }
     */
    public static MemorySegment wlr_seat_create(MemorySegment display, MemorySegment name) {
        var mh$ = wlr_seat_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_create", display, name);
            }
            return (MemorySegment)mh$.invokeExact(display, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_destroy(struct wlr_seat *wlr_seat)
     * }
     */
    public static FunctionDescriptor wlr_seat_destroy$descriptor() {
        return wlr_seat_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_destroy(struct wlr_seat *wlr_seat)
     * }
     */
    public static MethodHandle wlr_seat_destroy$handle() {
        return wlr_seat_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_destroy(struct wlr_seat *wlr_seat)
     * }
     */
    public static MemorySegment wlr_seat_destroy$address() {
        return wlr_seat_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_destroy(struct wlr_seat *wlr_seat)
     * }
     */
    public static void wlr_seat_destroy(MemorySegment wlr_seat) {
        var mh$ = wlr_seat_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_destroy", wlr_seat);
            }
            mh$.invokeExact(wlr_seat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_client_for_wl_client {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_client_for_wl_client");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_seat_client *wlr_seat_client_for_wl_client(struct wlr_seat *wlr_seat, struct wl_client *wl_client)
     * }
     */
    public static FunctionDescriptor wlr_seat_client_for_wl_client$descriptor() {
        return wlr_seat_client_for_wl_client.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_seat_client *wlr_seat_client_for_wl_client(struct wlr_seat *wlr_seat, struct wl_client *wl_client)
     * }
     */
    public static MethodHandle wlr_seat_client_for_wl_client$handle() {
        return wlr_seat_client_for_wl_client.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_seat_client *wlr_seat_client_for_wl_client(struct wlr_seat *wlr_seat, struct wl_client *wl_client)
     * }
     */
    public static MemorySegment wlr_seat_client_for_wl_client$address() {
        return wlr_seat_client_for_wl_client.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_seat_client *wlr_seat_client_for_wl_client(struct wlr_seat *wlr_seat, struct wl_client *wl_client)
     * }
     */
    public static MemorySegment wlr_seat_client_for_wl_client(MemorySegment wlr_seat, MemorySegment wl_client) {
        var mh$ = wlr_seat_client_for_wl_client.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_client_for_wl_client", wlr_seat, wl_client);
            }
            return (MemorySegment)mh$.invokeExact(wlr_seat, wl_client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_set_capabilities {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_set_capabilities");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_set_capabilities(struct wlr_seat *wlr_seat, uint32_t capabilities)
     * }
     */
    public static FunctionDescriptor wlr_seat_set_capabilities$descriptor() {
        return wlr_seat_set_capabilities.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_set_capabilities(struct wlr_seat *wlr_seat, uint32_t capabilities)
     * }
     */
    public static MethodHandle wlr_seat_set_capabilities$handle() {
        return wlr_seat_set_capabilities.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_set_capabilities(struct wlr_seat *wlr_seat, uint32_t capabilities)
     * }
     */
    public static MemorySegment wlr_seat_set_capabilities$address() {
        return wlr_seat_set_capabilities.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_set_capabilities(struct wlr_seat *wlr_seat, uint32_t capabilities)
     * }
     */
    public static void wlr_seat_set_capabilities(MemorySegment wlr_seat, int capabilities) {
        var mh$ = wlr_seat_set_capabilities.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_set_capabilities", wlr_seat, capabilities);
            }
            mh$.invokeExact(wlr_seat, capabilities);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_set_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_set_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_set_name(struct wlr_seat *wlr_seat, const char *name)
     * }
     */
    public static FunctionDescriptor wlr_seat_set_name$descriptor() {
        return wlr_seat_set_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_set_name(struct wlr_seat *wlr_seat, const char *name)
     * }
     */
    public static MethodHandle wlr_seat_set_name$handle() {
        return wlr_seat_set_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_set_name(struct wlr_seat *wlr_seat, const char *name)
     * }
     */
    public static MemorySegment wlr_seat_set_name$address() {
        return wlr_seat_set_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_set_name(struct wlr_seat *wlr_seat, const char *name)
     * }
     */
    public static void wlr_seat_set_name(MemorySegment wlr_seat, MemorySegment name) {
        var mh$ = wlr_seat_set_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_set_name", wlr_seat, name);
            }
            mh$.invokeExact(wlr_seat, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_pointer_surface_has_focus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_pointer_surface_has_focus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_seat_pointer_surface_has_focus(struct wlr_seat *wlr_seat, struct wlr_surface *surface)
     * }
     */
    public static FunctionDescriptor wlr_seat_pointer_surface_has_focus$descriptor() {
        return wlr_seat_pointer_surface_has_focus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_seat_pointer_surface_has_focus(struct wlr_seat *wlr_seat, struct wlr_surface *surface)
     * }
     */
    public static MethodHandle wlr_seat_pointer_surface_has_focus$handle() {
        return wlr_seat_pointer_surface_has_focus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_seat_pointer_surface_has_focus(struct wlr_seat *wlr_seat, struct wlr_surface *surface)
     * }
     */
    public static MemorySegment wlr_seat_pointer_surface_has_focus$address() {
        return wlr_seat_pointer_surface_has_focus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_seat_pointer_surface_has_focus(struct wlr_seat *wlr_seat, struct wlr_surface *surface)
     * }
     */
    public static boolean wlr_seat_pointer_surface_has_focus(MemorySegment wlr_seat, MemorySegment surface) {
        var mh$ = wlr_seat_pointer_surface_has_focus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_pointer_surface_has_focus", wlr_seat, surface);
            }
            return (boolean)mh$.invokeExact(wlr_seat, surface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_pointer_enter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_pointer_enter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_enter(struct wlr_seat *wlr_seat, struct wlr_surface *surface, double sx, double sy)
     * }
     */
    public static FunctionDescriptor wlr_seat_pointer_enter$descriptor() {
        return wlr_seat_pointer_enter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_enter(struct wlr_seat *wlr_seat, struct wlr_surface *surface, double sx, double sy)
     * }
     */
    public static MethodHandle wlr_seat_pointer_enter$handle() {
        return wlr_seat_pointer_enter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_enter(struct wlr_seat *wlr_seat, struct wlr_surface *surface, double sx, double sy)
     * }
     */
    public static MemorySegment wlr_seat_pointer_enter$address() {
        return wlr_seat_pointer_enter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_pointer_enter(struct wlr_seat *wlr_seat, struct wlr_surface *surface, double sx, double sy)
     * }
     */
    public static void wlr_seat_pointer_enter(MemorySegment wlr_seat, MemorySegment surface, double sx, double sy) {
        var mh$ = wlr_seat_pointer_enter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_pointer_enter", wlr_seat, surface, sx, sy);
            }
            mh$.invokeExact(wlr_seat, surface, sx, sy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_pointer_clear_focus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_pointer_clear_focus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_clear_focus(struct wlr_seat *wlr_seat)
     * }
     */
    public static FunctionDescriptor wlr_seat_pointer_clear_focus$descriptor() {
        return wlr_seat_pointer_clear_focus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_clear_focus(struct wlr_seat *wlr_seat)
     * }
     */
    public static MethodHandle wlr_seat_pointer_clear_focus$handle() {
        return wlr_seat_pointer_clear_focus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_clear_focus(struct wlr_seat *wlr_seat)
     * }
     */
    public static MemorySegment wlr_seat_pointer_clear_focus$address() {
        return wlr_seat_pointer_clear_focus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_pointer_clear_focus(struct wlr_seat *wlr_seat)
     * }
     */
    public static void wlr_seat_pointer_clear_focus(MemorySegment wlr_seat) {
        var mh$ = wlr_seat_pointer_clear_focus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_pointer_clear_focus", wlr_seat);
            }
            mh$.invokeExact(wlr_seat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_pointer_send_motion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_pointer_send_motion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_send_motion(struct wlr_seat *wlr_seat, uint32_t time_msec, double sx, double sy)
     * }
     */
    public static FunctionDescriptor wlr_seat_pointer_send_motion$descriptor() {
        return wlr_seat_pointer_send_motion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_send_motion(struct wlr_seat *wlr_seat, uint32_t time_msec, double sx, double sy)
     * }
     */
    public static MethodHandle wlr_seat_pointer_send_motion$handle() {
        return wlr_seat_pointer_send_motion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_send_motion(struct wlr_seat *wlr_seat, uint32_t time_msec, double sx, double sy)
     * }
     */
    public static MemorySegment wlr_seat_pointer_send_motion$address() {
        return wlr_seat_pointer_send_motion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_pointer_send_motion(struct wlr_seat *wlr_seat, uint32_t time_msec, double sx, double sy)
     * }
     */
    public static void wlr_seat_pointer_send_motion(MemorySegment wlr_seat, int time_msec, double sx, double sy) {
        var mh$ = wlr_seat_pointer_send_motion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_pointer_send_motion", wlr_seat, time_msec, sx, sy);
            }
            mh$.invokeExact(wlr_seat, time_msec, sx, sy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_pointer_send_button {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_pointer_send_button");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t wlr_seat_pointer_send_button(struct wlr_seat *wlr_seat, uint32_t time_msec, uint32_t button, enum wlr_button_state state)
     * }
     */
    public static FunctionDescriptor wlr_seat_pointer_send_button$descriptor() {
        return wlr_seat_pointer_send_button.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t wlr_seat_pointer_send_button(struct wlr_seat *wlr_seat, uint32_t time_msec, uint32_t button, enum wlr_button_state state)
     * }
     */
    public static MethodHandle wlr_seat_pointer_send_button$handle() {
        return wlr_seat_pointer_send_button.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t wlr_seat_pointer_send_button(struct wlr_seat *wlr_seat, uint32_t time_msec, uint32_t button, enum wlr_button_state state)
     * }
     */
    public static MemorySegment wlr_seat_pointer_send_button$address() {
        return wlr_seat_pointer_send_button.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t wlr_seat_pointer_send_button(struct wlr_seat *wlr_seat, uint32_t time_msec, uint32_t button, enum wlr_button_state state)
     * }
     */
    public static int wlr_seat_pointer_send_button(MemorySegment wlr_seat, int time_msec, int button, int state) {
        var mh$ = wlr_seat_pointer_send_button.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_pointer_send_button", wlr_seat, time_msec, button, state);
            }
            return (int)mh$.invokeExact(wlr_seat, time_msec, button, state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_pointer_send_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_DOUBLE,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_pointer_send_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_send_axis(struct wlr_seat *wlr_seat, uint32_t time_msec, enum wlr_axis_orientation orientation, double value, int32_t value_discrete, enum wlr_axis_source source)
     * }
     */
    public static FunctionDescriptor wlr_seat_pointer_send_axis$descriptor() {
        return wlr_seat_pointer_send_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_send_axis(struct wlr_seat *wlr_seat, uint32_t time_msec, enum wlr_axis_orientation orientation, double value, int32_t value_discrete, enum wlr_axis_source source)
     * }
     */
    public static MethodHandle wlr_seat_pointer_send_axis$handle() {
        return wlr_seat_pointer_send_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_send_axis(struct wlr_seat *wlr_seat, uint32_t time_msec, enum wlr_axis_orientation orientation, double value, int32_t value_discrete, enum wlr_axis_source source)
     * }
     */
    public static MemorySegment wlr_seat_pointer_send_axis$address() {
        return wlr_seat_pointer_send_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_pointer_send_axis(struct wlr_seat *wlr_seat, uint32_t time_msec, enum wlr_axis_orientation orientation, double value, int32_t value_discrete, enum wlr_axis_source source)
     * }
     */
    public static void wlr_seat_pointer_send_axis(MemorySegment wlr_seat, int time_msec, int orientation, double value, int value_discrete, int source) {
        var mh$ = wlr_seat_pointer_send_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_pointer_send_axis", wlr_seat, time_msec, orientation, value, value_discrete, source);
            }
            mh$.invokeExact(wlr_seat, time_msec, orientation, value, value_discrete, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_pointer_send_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_pointer_send_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_send_frame(struct wlr_seat *wlr_seat)
     * }
     */
    public static FunctionDescriptor wlr_seat_pointer_send_frame$descriptor() {
        return wlr_seat_pointer_send_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_send_frame(struct wlr_seat *wlr_seat)
     * }
     */
    public static MethodHandle wlr_seat_pointer_send_frame$handle() {
        return wlr_seat_pointer_send_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_send_frame(struct wlr_seat *wlr_seat)
     * }
     */
    public static MemorySegment wlr_seat_pointer_send_frame$address() {
        return wlr_seat_pointer_send_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_pointer_send_frame(struct wlr_seat *wlr_seat)
     * }
     */
    public static void wlr_seat_pointer_send_frame(MemorySegment wlr_seat) {
        var mh$ = wlr_seat_pointer_send_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_pointer_send_frame", wlr_seat);
            }
            mh$.invokeExact(wlr_seat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_pointer_notify_enter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_pointer_notify_enter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_notify_enter(struct wlr_seat *wlr_seat, struct wlr_surface *surface, double sx, double sy)
     * }
     */
    public static FunctionDescriptor wlr_seat_pointer_notify_enter$descriptor() {
        return wlr_seat_pointer_notify_enter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_notify_enter(struct wlr_seat *wlr_seat, struct wlr_surface *surface, double sx, double sy)
     * }
     */
    public static MethodHandle wlr_seat_pointer_notify_enter$handle() {
        return wlr_seat_pointer_notify_enter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_notify_enter(struct wlr_seat *wlr_seat, struct wlr_surface *surface, double sx, double sy)
     * }
     */
    public static MemorySegment wlr_seat_pointer_notify_enter$address() {
        return wlr_seat_pointer_notify_enter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_pointer_notify_enter(struct wlr_seat *wlr_seat, struct wlr_surface *surface, double sx, double sy)
     * }
     */
    public static void wlr_seat_pointer_notify_enter(MemorySegment wlr_seat, MemorySegment surface, double sx, double sy) {
        var mh$ = wlr_seat_pointer_notify_enter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_pointer_notify_enter", wlr_seat, surface, sx, sy);
            }
            mh$.invokeExact(wlr_seat, surface, sx, sy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_pointer_notify_clear_focus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_pointer_notify_clear_focus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_notify_clear_focus(struct wlr_seat *wlr_seat)
     * }
     */
    public static FunctionDescriptor wlr_seat_pointer_notify_clear_focus$descriptor() {
        return wlr_seat_pointer_notify_clear_focus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_notify_clear_focus(struct wlr_seat *wlr_seat)
     * }
     */
    public static MethodHandle wlr_seat_pointer_notify_clear_focus$handle() {
        return wlr_seat_pointer_notify_clear_focus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_notify_clear_focus(struct wlr_seat *wlr_seat)
     * }
     */
    public static MemorySegment wlr_seat_pointer_notify_clear_focus$address() {
        return wlr_seat_pointer_notify_clear_focus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_pointer_notify_clear_focus(struct wlr_seat *wlr_seat)
     * }
     */
    public static void wlr_seat_pointer_notify_clear_focus(MemorySegment wlr_seat) {
        var mh$ = wlr_seat_pointer_notify_clear_focus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_pointer_notify_clear_focus", wlr_seat);
            }
            mh$.invokeExact(wlr_seat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_pointer_warp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_pointer_warp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_warp(struct wlr_seat *wlr_seat, double sx, double sy)
     * }
     */
    public static FunctionDescriptor wlr_seat_pointer_warp$descriptor() {
        return wlr_seat_pointer_warp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_warp(struct wlr_seat *wlr_seat, double sx, double sy)
     * }
     */
    public static MethodHandle wlr_seat_pointer_warp$handle() {
        return wlr_seat_pointer_warp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_warp(struct wlr_seat *wlr_seat, double sx, double sy)
     * }
     */
    public static MemorySegment wlr_seat_pointer_warp$address() {
        return wlr_seat_pointer_warp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_pointer_warp(struct wlr_seat *wlr_seat, double sx, double sy)
     * }
     */
    public static void wlr_seat_pointer_warp(MemorySegment wlr_seat, double sx, double sy) {
        var mh$ = wlr_seat_pointer_warp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_pointer_warp", wlr_seat, sx, sy);
            }
            mh$.invokeExact(wlr_seat, sx, sy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_pointer_notify_motion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_pointer_notify_motion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_notify_motion(struct wlr_seat *wlr_seat, uint32_t time_msec, double sx, double sy)
     * }
     */
    public static FunctionDescriptor wlr_seat_pointer_notify_motion$descriptor() {
        return wlr_seat_pointer_notify_motion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_notify_motion(struct wlr_seat *wlr_seat, uint32_t time_msec, double sx, double sy)
     * }
     */
    public static MethodHandle wlr_seat_pointer_notify_motion$handle() {
        return wlr_seat_pointer_notify_motion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_notify_motion(struct wlr_seat *wlr_seat, uint32_t time_msec, double sx, double sy)
     * }
     */
    public static MemorySegment wlr_seat_pointer_notify_motion$address() {
        return wlr_seat_pointer_notify_motion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_pointer_notify_motion(struct wlr_seat *wlr_seat, uint32_t time_msec, double sx, double sy)
     * }
     */
    public static void wlr_seat_pointer_notify_motion(MemorySegment wlr_seat, int time_msec, double sx, double sy) {
        var mh$ = wlr_seat_pointer_notify_motion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_pointer_notify_motion", wlr_seat, time_msec, sx, sy);
            }
            mh$.invokeExact(wlr_seat, time_msec, sx, sy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_pointer_notify_button {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_pointer_notify_button");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t wlr_seat_pointer_notify_button(struct wlr_seat *wlr_seat, uint32_t time_msec, uint32_t button, enum wlr_button_state state)
     * }
     */
    public static FunctionDescriptor wlr_seat_pointer_notify_button$descriptor() {
        return wlr_seat_pointer_notify_button.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t wlr_seat_pointer_notify_button(struct wlr_seat *wlr_seat, uint32_t time_msec, uint32_t button, enum wlr_button_state state)
     * }
     */
    public static MethodHandle wlr_seat_pointer_notify_button$handle() {
        return wlr_seat_pointer_notify_button.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t wlr_seat_pointer_notify_button(struct wlr_seat *wlr_seat, uint32_t time_msec, uint32_t button, enum wlr_button_state state)
     * }
     */
    public static MemorySegment wlr_seat_pointer_notify_button$address() {
        return wlr_seat_pointer_notify_button.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t wlr_seat_pointer_notify_button(struct wlr_seat *wlr_seat, uint32_t time_msec, uint32_t button, enum wlr_button_state state)
     * }
     */
    public static int wlr_seat_pointer_notify_button(MemorySegment wlr_seat, int time_msec, int button, int state) {
        var mh$ = wlr_seat_pointer_notify_button.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_pointer_notify_button", wlr_seat, time_msec, button, state);
            }
            return (int)mh$.invokeExact(wlr_seat, time_msec, button, state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_pointer_notify_axis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_DOUBLE,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_pointer_notify_axis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_notify_axis(struct wlr_seat *wlr_seat, uint32_t time_msec, enum wlr_axis_orientation orientation, double value, int32_t value_discrete, enum wlr_axis_source source)
     * }
     */
    public static FunctionDescriptor wlr_seat_pointer_notify_axis$descriptor() {
        return wlr_seat_pointer_notify_axis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_notify_axis(struct wlr_seat *wlr_seat, uint32_t time_msec, enum wlr_axis_orientation orientation, double value, int32_t value_discrete, enum wlr_axis_source source)
     * }
     */
    public static MethodHandle wlr_seat_pointer_notify_axis$handle() {
        return wlr_seat_pointer_notify_axis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_notify_axis(struct wlr_seat *wlr_seat, uint32_t time_msec, enum wlr_axis_orientation orientation, double value, int32_t value_discrete, enum wlr_axis_source source)
     * }
     */
    public static MemorySegment wlr_seat_pointer_notify_axis$address() {
        return wlr_seat_pointer_notify_axis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_pointer_notify_axis(struct wlr_seat *wlr_seat, uint32_t time_msec, enum wlr_axis_orientation orientation, double value, int32_t value_discrete, enum wlr_axis_source source)
     * }
     */
    public static void wlr_seat_pointer_notify_axis(MemorySegment wlr_seat, int time_msec, int orientation, double value, int value_discrete, int source) {
        var mh$ = wlr_seat_pointer_notify_axis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_pointer_notify_axis", wlr_seat, time_msec, orientation, value, value_discrete, source);
            }
            mh$.invokeExact(wlr_seat, time_msec, orientation, value, value_discrete, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_pointer_notify_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_pointer_notify_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_notify_frame(struct wlr_seat *wlr_seat)
     * }
     */
    public static FunctionDescriptor wlr_seat_pointer_notify_frame$descriptor() {
        return wlr_seat_pointer_notify_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_notify_frame(struct wlr_seat *wlr_seat)
     * }
     */
    public static MethodHandle wlr_seat_pointer_notify_frame$handle() {
        return wlr_seat_pointer_notify_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_notify_frame(struct wlr_seat *wlr_seat)
     * }
     */
    public static MemorySegment wlr_seat_pointer_notify_frame$address() {
        return wlr_seat_pointer_notify_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_pointer_notify_frame(struct wlr_seat *wlr_seat)
     * }
     */
    public static void wlr_seat_pointer_notify_frame(MemorySegment wlr_seat) {
        var mh$ = wlr_seat_pointer_notify_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_pointer_notify_frame", wlr_seat);
            }
            mh$.invokeExact(wlr_seat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_pointer_start_grab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_pointer_start_grab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_start_grab(struct wlr_seat *wlr_seat, struct wlr_seat_pointer_grab *grab)
     * }
     */
    public static FunctionDescriptor wlr_seat_pointer_start_grab$descriptor() {
        return wlr_seat_pointer_start_grab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_start_grab(struct wlr_seat *wlr_seat, struct wlr_seat_pointer_grab *grab)
     * }
     */
    public static MethodHandle wlr_seat_pointer_start_grab$handle() {
        return wlr_seat_pointer_start_grab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_start_grab(struct wlr_seat *wlr_seat, struct wlr_seat_pointer_grab *grab)
     * }
     */
    public static MemorySegment wlr_seat_pointer_start_grab$address() {
        return wlr_seat_pointer_start_grab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_pointer_start_grab(struct wlr_seat *wlr_seat, struct wlr_seat_pointer_grab *grab)
     * }
     */
    public static void wlr_seat_pointer_start_grab(MemorySegment wlr_seat, MemorySegment grab) {
        var mh$ = wlr_seat_pointer_start_grab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_pointer_start_grab", wlr_seat, grab);
            }
            mh$.invokeExact(wlr_seat, grab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_pointer_end_grab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_pointer_end_grab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_end_grab(struct wlr_seat *wlr_seat)
     * }
     */
    public static FunctionDescriptor wlr_seat_pointer_end_grab$descriptor() {
        return wlr_seat_pointer_end_grab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_end_grab(struct wlr_seat *wlr_seat)
     * }
     */
    public static MethodHandle wlr_seat_pointer_end_grab$handle() {
        return wlr_seat_pointer_end_grab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_pointer_end_grab(struct wlr_seat *wlr_seat)
     * }
     */
    public static MemorySegment wlr_seat_pointer_end_grab$address() {
        return wlr_seat_pointer_end_grab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_pointer_end_grab(struct wlr_seat *wlr_seat)
     * }
     */
    public static void wlr_seat_pointer_end_grab(MemorySegment wlr_seat) {
        var mh$ = wlr_seat_pointer_end_grab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_pointer_end_grab", wlr_seat);
            }
            mh$.invokeExact(wlr_seat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_pointer_has_grab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_pointer_has_grab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_seat_pointer_has_grab(struct wlr_seat *seat)
     * }
     */
    public static FunctionDescriptor wlr_seat_pointer_has_grab$descriptor() {
        return wlr_seat_pointer_has_grab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_seat_pointer_has_grab(struct wlr_seat *seat)
     * }
     */
    public static MethodHandle wlr_seat_pointer_has_grab$handle() {
        return wlr_seat_pointer_has_grab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_seat_pointer_has_grab(struct wlr_seat *seat)
     * }
     */
    public static MemorySegment wlr_seat_pointer_has_grab$address() {
        return wlr_seat_pointer_has_grab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_seat_pointer_has_grab(struct wlr_seat *seat)
     * }
     */
    public static boolean wlr_seat_pointer_has_grab(MemorySegment seat) {
        var mh$ = wlr_seat_pointer_has_grab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_pointer_has_grab", seat);
            }
            return (boolean)mh$.invokeExact(seat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_set_keyboard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_set_keyboard");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_set_keyboard(struct wlr_seat *seat, struct wlr_keyboard *keyboard)
     * }
     */
    public static FunctionDescriptor wlr_seat_set_keyboard$descriptor() {
        return wlr_seat_set_keyboard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_set_keyboard(struct wlr_seat *seat, struct wlr_keyboard *keyboard)
     * }
     */
    public static MethodHandle wlr_seat_set_keyboard$handle() {
        return wlr_seat_set_keyboard.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_set_keyboard(struct wlr_seat *seat, struct wlr_keyboard *keyboard)
     * }
     */
    public static MemorySegment wlr_seat_set_keyboard$address() {
        return wlr_seat_set_keyboard.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_set_keyboard(struct wlr_seat *seat, struct wlr_keyboard *keyboard)
     * }
     */
    public static void wlr_seat_set_keyboard(MemorySegment seat, MemorySegment keyboard) {
        var mh$ = wlr_seat_set_keyboard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_set_keyboard", seat, keyboard);
            }
            mh$.invokeExact(seat, keyboard);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_get_keyboard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_get_keyboard");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_keyboard *wlr_seat_get_keyboard(struct wlr_seat *seat)
     * }
     */
    public static FunctionDescriptor wlr_seat_get_keyboard$descriptor() {
        return wlr_seat_get_keyboard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_keyboard *wlr_seat_get_keyboard(struct wlr_seat *seat)
     * }
     */
    public static MethodHandle wlr_seat_get_keyboard$handle() {
        return wlr_seat_get_keyboard.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_keyboard *wlr_seat_get_keyboard(struct wlr_seat *seat)
     * }
     */
    public static MemorySegment wlr_seat_get_keyboard$address() {
        return wlr_seat_get_keyboard.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_keyboard *wlr_seat_get_keyboard(struct wlr_seat *seat)
     * }
     */
    public static MemorySegment wlr_seat_get_keyboard(MemorySegment seat) {
        var mh$ = wlr_seat_get_keyboard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_get_keyboard", seat);
            }
            return (MemorySegment)mh$.invokeExact(seat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_keyboard_send_key {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_keyboard_send_key");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_send_key(struct wlr_seat *seat, uint32_t time_msec, uint32_t key, uint32_t state)
     * }
     */
    public static FunctionDescriptor wlr_seat_keyboard_send_key$descriptor() {
        return wlr_seat_keyboard_send_key.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_send_key(struct wlr_seat *seat, uint32_t time_msec, uint32_t key, uint32_t state)
     * }
     */
    public static MethodHandle wlr_seat_keyboard_send_key$handle() {
        return wlr_seat_keyboard_send_key.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_send_key(struct wlr_seat *seat, uint32_t time_msec, uint32_t key, uint32_t state)
     * }
     */
    public static MemorySegment wlr_seat_keyboard_send_key$address() {
        return wlr_seat_keyboard_send_key.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_keyboard_send_key(struct wlr_seat *seat, uint32_t time_msec, uint32_t key, uint32_t state)
     * }
     */
    public static void wlr_seat_keyboard_send_key(MemorySegment seat, int time_msec, int key, int state) {
        var mh$ = wlr_seat_keyboard_send_key.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_keyboard_send_key", seat, time_msec, key, state);
            }
            mh$.invokeExact(seat, time_msec, key, state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_keyboard_send_modifiers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_keyboard_send_modifiers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_send_modifiers(struct wlr_seat *seat, const struct wlr_keyboard_modifiers *modifiers)
     * }
     */
    public static FunctionDescriptor wlr_seat_keyboard_send_modifiers$descriptor() {
        return wlr_seat_keyboard_send_modifiers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_send_modifiers(struct wlr_seat *seat, const struct wlr_keyboard_modifiers *modifiers)
     * }
     */
    public static MethodHandle wlr_seat_keyboard_send_modifiers$handle() {
        return wlr_seat_keyboard_send_modifiers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_send_modifiers(struct wlr_seat *seat, const struct wlr_keyboard_modifiers *modifiers)
     * }
     */
    public static MemorySegment wlr_seat_keyboard_send_modifiers$address() {
        return wlr_seat_keyboard_send_modifiers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_keyboard_send_modifiers(struct wlr_seat *seat, const struct wlr_keyboard_modifiers *modifiers)
     * }
     */
    public static void wlr_seat_keyboard_send_modifiers(MemorySegment seat, MemorySegment modifiers) {
        var mh$ = wlr_seat_keyboard_send_modifiers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_keyboard_send_modifiers", seat, modifiers);
            }
            mh$.invokeExact(seat, modifiers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_keyboard_enter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_LONG,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_keyboard_enter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_enter(struct wlr_seat *seat, struct wlr_surface *surface, const uint32_t keycodes[], size_t num_keycodes, const struct wlr_keyboard_modifiers *modifiers)
     * }
     */
    public static FunctionDescriptor wlr_seat_keyboard_enter$descriptor() {
        return wlr_seat_keyboard_enter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_enter(struct wlr_seat *seat, struct wlr_surface *surface, const uint32_t keycodes[], size_t num_keycodes, const struct wlr_keyboard_modifiers *modifiers)
     * }
     */
    public static MethodHandle wlr_seat_keyboard_enter$handle() {
        return wlr_seat_keyboard_enter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_enter(struct wlr_seat *seat, struct wlr_surface *surface, const uint32_t keycodes[], size_t num_keycodes, const struct wlr_keyboard_modifiers *modifiers)
     * }
     */
    public static MemorySegment wlr_seat_keyboard_enter$address() {
        return wlr_seat_keyboard_enter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_keyboard_enter(struct wlr_seat *seat, struct wlr_surface *surface, const uint32_t keycodes[], size_t num_keycodes, const struct wlr_keyboard_modifiers *modifiers)
     * }
     */
    public static void wlr_seat_keyboard_enter(MemorySegment seat, MemorySegment surface, MemorySegment keycodes, long num_keycodes, MemorySegment modifiers) {
        var mh$ = wlr_seat_keyboard_enter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_keyboard_enter", seat, surface, keycodes, num_keycodes, modifiers);
            }
            mh$.invokeExact(seat, surface, keycodes, num_keycodes, modifiers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_keyboard_clear_focus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_keyboard_clear_focus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_clear_focus(struct wlr_seat *wlr_seat)
     * }
     */
    public static FunctionDescriptor wlr_seat_keyboard_clear_focus$descriptor() {
        return wlr_seat_keyboard_clear_focus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_clear_focus(struct wlr_seat *wlr_seat)
     * }
     */
    public static MethodHandle wlr_seat_keyboard_clear_focus$handle() {
        return wlr_seat_keyboard_clear_focus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_clear_focus(struct wlr_seat *wlr_seat)
     * }
     */
    public static MemorySegment wlr_seat_keyboard_clear_focus$address() {
        return wlr_seat_keyboard_clear_focus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_keyboard_clear_focus(struct wlr_seat *wlr_seat)
     * }
     */
    public static void wlr_seat_keyboard_clear_focus(MemorySegment wlr_seat) {
        var mh$ = wlr_seat_keyboard_clear_focus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_keyboard_clear_focus", wlr_seat);
            }
            mh$.invokeExact(wlr_seat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_keyboard_notify_key {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_keyboard_notify_key");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_notify_key(struct wlr_seat *seat, uint32_t time_msec, uint32_t key, uint32_t state)
     * }
     */
    public static FunctionDescriptor wlr_seat_keyboard_notify_key$descriptor() {
        return wlr_seat_keyboard_notify_key.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_notify_key(struct wlr_seat *seat, uint32_t time_msec, uint32_t key, uint32_t state)
     * }
     */
    public static MethodHandle wlr_seat_keyboard_notify_key$handle() {
        return wlr_seat_keyboard_notify_key.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_notify_key(struct wlr_seat *seat, uint32_t time_msec, uint32_t key, uint32_t state)
     * }
     */
    public static MemorySegment wlr_seat_keyboard_notify_key$address() {
        return wlr_seat_keyboard_notify_key.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_keyboard_notify_key(struct wlr_seat *seat, uint32_t time_msec, uint32_t key, uint32_t state)
     * }
     */
    public static void wlr_seat_keyboard_notify_key(MemorySegment seat, int time_msec, int key, int state) {
        var mh$ = wlr_seat_keyboard_notify_key.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_keyboard_notify_key", seat, time_msec, key, state);
            }
            mh$.invokeExact(seat, time_msec, key, state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_keyboard_notify_modifiers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_keyboard_notify_modifiers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_notify_modifiers(struct wlr_seat *seat, const struct wlr_keyboard_modifiers *modifiers)
     * }
     */
    public static FunctionDescriptor wlr_seat_keyboard_notify_modifiers$descriptor() {
        return wlr_seat_keyboard_notify_modifiers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_notify_modifiers(struct wlr_seat *seat, const struct wlr_keyboard_modifiers *modifiers)
     * }
     */
    public static MethodHandle wlr_seat_keyboard_notify_modifiers$handle() {
        return wlr_seat_keyboard_notify_modifiers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_notify_modifiers(struct wlr_seat *seat, const struct wlr_keyboard_modifiers *modifiers)
     * }
     */
    public static MemorySegment wlr_seat_keyboard_notify_modifiers$address() {
        return wlr_seat_keyboard_notify_modifiers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_keyboard_notify_modifiers(struct wlr_seat *seat, const struct wlr_keyboard_modifiers *modifiers)
     * }
     */
    public static void wlr_seat_keyboard_notify_modifiers(MemorySegment seat, MemorySegment modifiers) {
        var mh$ = wlr_seat_keyboard_notify_modifiers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_keyboard_notify_modifiers", seat, modifiers);
            }
            mh$.invokeExact(seat, modifiers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_keyboard_notify_enter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_LONG,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_keyboard_notify_enter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_notify_enter(struct wlr_seat *seat, struct wlr_surface *surface, const uint32_t keycodes[], size_t num_keycodes, const struct wlr_keyboard_modifiers *modifiers)
     * }
     */
    public static FunctionDescriptor wlr_seat_keyboard_notify_enter$descriptor() {
        return wlr_seat_keyboard_notify_enter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_notify_enter(struct wlr_seat *seat, struct wlr_surface *surface, const uint32_t keycodes[], size_t num_keycodes, const struct wlr_keyboard_modifiers *modifiers)
     * }
     */
    public static MethodHandle wlr_seat_keyboard_notify_enter$handle() {
        return wlr_seat_keyboard_notify_enter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_notify_enter(struct wlr_seat *seat, struct wlr_surface *surface, const uint32_t keycodes[], size_t num_keycodes, const struct wlr_keyboard_modifiers *modifiers)
     * }
     */
    public static MemorySegment wlr_seat_keyboard_notify_enter$address() {
        return wlr_seat_keyboard_notify_enter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_keyboard_notify_enter(struct wlr_seat *seat, struct wlr_surface *surface, const uint32_t keycodes[], size_t num_keycodes, const struct wlr_keyboard_modifiers *modifiers)
     * }
     */
    public static void wlr_seat_keyboard_notify_enter(MemorySegment seat, MemorySegment surface, MemorySegment keycodes, long num_keycodes, MemorySegment modifiers) {
        var mh$ = wlr_seat_keyboard_notify_enter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_keyboard_notify_enter", seat, surface, keycodes, num_keycodes, modifiers);
            }
            mh$.invokeExact(seat, surface, keycodes, num_keycodes, modifiers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_keyboard_notify_clear_focus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_keyboard_notify_clear_focus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_notify_clear_focus(struct wlr_seat *wlr_seat)
     * }
     */
    public static FunctionDescriptor wlr_seat_keyboard_notify_clear_focus$descriptor() {
        return wlr_seat_keyboard_notify_clear_focus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_notify_clear_focus(struct wlr_seat *wlr_seat)
     * }
     */
    public static MethodHandle wlr_seat_keyboard_notify_clear_focus$handle() {
        return wlr_seat_keyboard_notify_clear_focus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_notify_clear_focus(struct wlr_seat *wlr_seat)
     * }
     */
    public static MemorySegment wlr_seat_keyboard_notify_clear_focus$address() {
        return wlr_seat_keyboard_notify_clear_focus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_keyboard_notify_clear_focus(struct wlr_seat *wlr_seat)
     * }
     */
    public static void wlr_seat_keyboard_notify_clear_focus(MemorySegment wlr_seat) {
        var mh$ = wlr_seat_keyboard_notify_clear_focus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_keyboard_notify_clear_focus", wlr_seat);
            }
            mh$.invokeExact(wlr_seat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_keyboard_start_grab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_keyboard_start_grab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_start_grab(struct wlr_seat *wlr_seat, struct wlr_seat_keyboard_grab *grab)
     * }
     */
    public static FunctionDescriptor wlr_seat_keyboard_start_grab$descriptor() {
        return wlr_seat_keyboard_start_grab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_start_grab(struct wlr_seat *wlr_seat, struct wlr_seat_keyboard_grab *grab)
     * }
     */
    public static MethodHandle wlr_seat_keyboard_start_grab$handle() {
        return wlr_seat_keyboard_start_grab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_start_grab(struct wlr_seat *wlr_seat, struct wlr_seat_keyboard_grab *grab)
     * }
     */
    public static MemorySegment wlr_seat_keyboard_start_grab$address() {
        return wlr_seat_keyboard_start_grab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_keyboard_start_grab(struct wlr_seat *wlr_seat, struct wlr_seat_keyboard_grab *grab)
     * }
     */
    public static void wlr_seat_keyboard_start_grab(MemorySegment wlr_seat, MemorySegment grab) {
        var mh$ = wlr_seat_keyboard_start_grab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_keyboard_start_grab", wlr_seat, grab);
            }
            mh$.invokeExact(wlr_seat, grab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_keyboard_end_grab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_keyboard_end_grab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_end_grab(struct wlr_seat *wlr_seat)
     * }
     */
    public static FunctionDescriptor wlr_seat_keyboard_end_grab$descriptor() {
        return wlr_seat_keyboard_end_grab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_end_grab(struct wlr_seat *wlr_seat)
     * }
     */
    public static MethodHandle wlr_seat_keyboard_end_grab$handle() {
        return wlr_seat_keyboard_end_grab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_keyboard_end_grab(struct wlr_seat *wlr_seat)
     * }
     */
    public static MemorySegment wlr_seat_keyboard_end_grab$address() {
        return wlr_seat_keyboard_end_grab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_keyboard_end_grab(struct wlr_seat *wlr_seat)
     * }
     */
    public static void wlr_seat_keyboard_end_grab(MemorySegment wlr_seat) {
        var mh$ = wlr_seat_keyboard_end_grab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_keyboard_end_grab", wlr_seat);
            }
            mh$.invokeExact(wlr_seat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_keyboard_has_grab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_keyboard_has_grab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_seat_keyboard_has_grab(struct wlr_seat *seat)
     * }
     */
    public static FunctionDescriptor wlr_seat_keyboard_has_grab$descriptor() {
        return wlr_seat_keyboard_has_grab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_seat_keyboard_has_grab(struct wlr_seat *seat)
     * }
     */
    public static MethodHandle wlr_seat_keyboard_has_grab$handle() {
        return wlr_seat_keyboard_has_grab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_seat_keyboard_has_grab(struct wlr_seat *seat)
     * }
     */
    public static MemorySegment wlr_seat_keyboard_has_grab$address() {
        return wlr_seat_keyboard_has_grab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_seat_keyboard_has_grab(struct wlr_seat *seat)
     * }
     */
    public static boolean wlr_seat_keyboard_has_grab(MemorySegment seat) {
        var mh$ = wlr_seat_keyboard_has_grab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_keyboard_has_grab", seat);
            }
            return (boolean)mh$.invokeExact(seat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_touch_get_point {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_touch_get_point");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_touch_point *wlr_seat_touch_get_point(struct wlr_seat *seat, int32_t touch_id)
     * }
     */
    public static FunctionDescriptor wlr_seat_touch_get_point$descriptor() {
        return wlr_seat_touch_get_point.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_touch_point *wlr_seat_touch_get_point(struct wlr_seat *seat, int32_t touch_id)
     * }
     */
    public static MethodHandle wlr_seat_touch_get_point$handle() {
        return wlr_seat_touch_get_point.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_touch_point *wlr_seat_touch_get_point(struct wlr_seat *seat, int32_t touch_id)
     * }
     */
    public static MemorySegment wlr_seat_touch_get_point$address() {
        return wlr_seat_touch_get_point.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_touch_point *wlr_seat_touch_get_point(struct wlr_seat *seat, int32_t touch_id)
     * }
     */
    public static MemorySegment wlr_seat_touch_get_point(MemorySegment seat, int touch_id) {
        var mh$ = wlr_seat_touch_get_point.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_touch_get_point", seat, touch_id);
            }
            return (MemorySegment)mh$.invokeExact(seat, touch_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_touch_point_focus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_touch_point_focus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_touch_point_focus(struct wlr_seat *seat, struct wlr_surface *surface, uint32_t time_msec, int32_t touch_id, double sx, double sy)
     * }
     */
    public static FunctionDescriptor wlr_seat_touch_point_focus$descriptor() {
        return wlr_seat_touch_point_focus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_touch_point_focus(struct wlr_seat *seat, struct wlr_surface *surface, uint32_t time_msec, int32_t touch_id, double sx, double sy)
     * }
     */
    public static MethodHandle wlr_seat_touch_point_focus$handle() {
        return wlr_seat_touch_point_focus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_touch_point_focus(struct wlr_seat *seat, struct wlr_surface *surface, uint32_t time_msec, int32_t touch_id, double sx, double sy)
     * }
     */
    public static MemorySegment wlr_seat_touch_point_focus$address() {
        return wlr_seat_touch_point_focus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_touch_point_focus(struct wlr_seat *seat, struct wlr_surface *surface, uint32_t time_msec, int32_t touch_id, double sx, double sy)
     * }
     */
    public static void wlr_seat_touch_point_focus(MemorySegment seat, MemorySegment surface, int time_msec, int touch_id, double sx, double sy) {
        var mh$ = wlr_seat_touch_point_focus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_touch_point_focus", seat, surface, time_msec, touch_id, sx, sy);
            }
            mh$.invokeExact(seat, surface, time_msec, touch_id, sx, sy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_touch_point_clear_focus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_touch_point_clear_focus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_touch_point_clear_focus(struct wlr_seat *seat, uint32_t time_msec, int32_t touch_id)
     * }
     */
    public static FunctionDescriptor wlr_seat_touch_point_clear_focus$descriptor() {
        return wlr_seat_touch_point_clear_focus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_touch_point_clear_focus(struct wlr_seat *seat, uint32_t time_msec, int32_t touch_id)
     * }
     */
    public static MethodHandle wlr_seat_touch_point_clear_focus$handle() {
        return wlr_seat_touch_point_clear_focus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_touch_point_clear_focus(struct wlr_seat *seat, uint32_t time_msec, int32_t touch_id)
     * }
     */
    public static MemorySegment wlr_seat_touch_point_clear_focus$address() {
        return wlr_seat_touch_point_clear_focus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_touch_point_clear_focus(struct wlr_seat *seat, uint32_t time_msec, int32_t touch_id)
     * }
     */
    public static void wlr_seat_touch_point_clear_focus(MemorySegment seat, int time_msec, int touch_id) {
        var mh$ = wlr_seat_touch_point_clear_focus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_touch_point_clear_focus", seat, time_msec, touch_id);
            }
            mh$.invokeExact(seat, time_msec, touch_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_touch_send_down {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_touch_send_down");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t wlr_seat_touch_send_down(struct wlr_seat *seat, struct wlr_surface *surface, uint32_t time_msec, int32_t touch_id, double sx, double sy)
     * }
     */
    public static FunctionDescriptor wlr_seat_touch_send_down$descriptor() {
        return wlr_seat_touch_send_down.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t wlr_seat_touch_send_down(struct wlr_seat *seat, struct wlr_surface *surface, uint32_t time_msec, int32_t touch_id, double sx, double sy)
     * }
     */
    public static MethodHandle wlr_seat_touch_send_down$handle() {
        return wlr_seat_touch_send_down.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t wlr_seat_touch_send_down(struct wlr_seat *seat, struct wlr_surface *surface, uint32_t time_msec, int32_t touch_id, double sx, double sy)
     * }
     */
    public static MemorySegment wlr_seat_touch_send_down$address() {
        return wlr_seat_touch_send_down.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t wlr_seat_touch_send_down(struct wlr_seat *seat, struct wlr_surface *surface, uint32_t time_msec, int32_t touch_id, double sx, double sy)
     * }
     */
    public static int wlr_seat_touch_send_down(MemorySegment seat, MemorySegment surface, int time_msec, int touch_id, double sx, double sy) {
        var mh$ = wlr_seat_touch_send_down.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_touch_send_down", seat, surface, time_msec, touch_id, sx, sy);
            }
            return (int)mh$.invokeExact(seat, surface, time_msec, touch_id, sx, sy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_touch_send_up {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_touch_send_up");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_touch_send_up(struct wlr_seat *seat, uint32_t time_msec, int32_t touch_id)
     * }
     */
    public static FunctionDescriptor wlr_seat_touch_send_up$descriptor() {
        return wlr_seat_touch_send_up.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_touch_send_up(struct wlr_seat *seat, uint32_t time_msec, int32_t touch_id)
     * }
     */
    public static MethodHandle wlr_seat_touch_send_up$handle() {
        return wlr_seat_touch_send_up.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_touch_send_up(struct wlr_seat *seat, uint32_t time_msec, int32_t touch_id)
     * }
     */
    public static MemorySegment wlr_seat_touch_send_up$address() {
        return wlr_seat_touch_send_up.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_touch_send_up(struct wlr_seat *seat, uint32_t time_msec, int32_t touch_id)
     * }
     */
    public static void wlr_seat_touch_send_up(MemorySegment seat, int time_msec, int touch_id) {
        var mh$ = wlr_seat_touch_send_up.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_touch_send_up", seat, time_msec, touch_id);
            }
            mh$.invokeExact(seat, time_msec, touch_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_touch_send_motion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_touch_send_motion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_touch_send_motion(struct wlr_seat *seat, uint32_t time_msec, int32_t touch_id, double sx, double sy)
     * }
     */
    public static FunctionDescriptor wlr_seat_touch_send_motion$descriptor() {
        return wlr_seat_touch_send_motion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_touch_send_motion(struct wlr_seat *seat, uint32_t time_msec, int32_t touch_id, double sx, double sy)
     * }
     */
    public static MethodHandle wlr_seat_touch_send_motion$handle() {
        return wlr_seat_touch_send_motion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_touch_send_motion(struct wlr_seat *seat, uint32_t time_msec, int32_t touch_id, double sx, double sy)
     * }
     */
    public static MemorySegment wlr_seat_touch_send_motion$address() {
        return wlr_seat_touch_send_motion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_touch_send_motion(struct wlr_seat *seat, uint32_t time_msec, int32_t touch_id, double sx, double sy)
     * }
     */
    public static void wlr_seat_touch_send_motion(MemorySegment seat, int time_msec, int touch_id, double sx, double sy) {
        var mh$ = wlr_seat_touch_send_motion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_touch_send_motion", seat, time_msec, touch_id, sx, sy);
            }
            mh$.invokeExact(seat, time_msec, touch_id, sx, sy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_touch_send_cancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_touch_send_cancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_touch_send_cancel(struct wlr_seat *seat, struct wlr_surface *surface)
     * }
     */
    public static FunctionDescriptor wlr_seat_touch_send_cancel$descriptor() {
        return wlr_seat_touch_send_cancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_touch_send_cancel(struct wlr_seat *seat, struct wlr_surface *surface)
     * }
     */
    public static MethodHandle wlr_seat_touch_send_cancel$handle() {
        return wlr_seat_touch_send_cancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_touch_send_cancel(struct wlr_seat *seat, struct wlr_surface *surface)
     * }
     */
    public static MemorySegment wlr_seat_touch_send_cancel$address() {
        return wlr_seat_touch_send_cancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_touch_send_cancel(struct wlr_seat *seat, struct wlr_surface *surface)
     * }
     */
    public static void wlr_seat_touch_send_cancel(MemorySegment seat, MemorySegment surface) {
        var mh$ = wlr_seat_touch_send_cancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_touch_send_cancel", seat, surface);
            }
            mh$.invokeExact(seat, surface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_touch_send_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_touch_send_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_touch_send_frame(struct wlr_seat *seat)
     * }
     */
    public static FunctionDescriptor wlr_seat_touch_send_frame$descriptor() {
        return wlr_seat_touch_send_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_touch_send_frame(struct wlr_seat *seat)
     * }
     */
    public static MethodHandle wlr_seat_touch_send_frame$handle() {
        return wlr_seat_touch_send_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_touch_send_frame(struct wlr_seat *seat)
     * }
     */
    public static MemorySegment wlr_seat_touch_send_frame$address() {
        return wlr_seat_touch_send_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_touch_send_frame(struct wlr_seat *seat)
     * }
     */
    public static void wlr_seat_touch_send_frame(MemorySegment seat) {
        var mh$ = wlr_seat_touch_send_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_touch_send_frame", seat);
            }
            mh$.invokeExact(seat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_touch_notify_down {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_touch_notify_down");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t wlr_seat_touch_notify_down(struct wlr_seat *seat, struct wlr_surface *surface, uint32_t time_msec, int32_t touch_id, double sx, double sy)
     * }
     */
    public static FunctionDescriptor wlr_seat_touch_notify_down$descriptor() {
        return wlr_seat_touch_notify_down.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t wlr_seat_touch_notify_down(struct wlr_seat *seat, struct wlr_surface *surface, uint32_t time_msec, int32_t touch_id, double sx, double sy)
     * }
     */
    public static MethodHandle wlr_seat_touch_notify_down$handle() {
        return wlr_seat_touch_notify_down.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t wlr_seat_touch_notify_down(struct wlr_seat *seat, struct wlr_surface *surface, uint32_t time_msec, int32_t touch_id, double sx, double sy)
     * }
     */
    public static MemorySegment wlr_seat_touch_notify_down$address() {
        return wlr_seat_touch_notify_down.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t wlr_seat_touch_notify_down(struct wlr_seat *seat, struct wlr_surface *surface, uint32_t time_msec, int32_t touch_id, double sx, double sy)
     * }
     */
    public static int wlr_seat_touch_notify_down(MemorySegment seat, MemorySegment surface, int time_msec, int touch_id, double sx, double sy) {
        var mh$ = wlr_seat_touch_notify_down.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_touch_notify_down", seat, surface, time_msec, touch_id, sx, sy);
            }
            return (int)mh$.invokeExact(seat, surface, time_msec, touch_id, sx, sy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_touch_notify_up {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_touch_notify_up");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_touch_notify_up(struct wlr_seat *seat, uint32_t time_msec, int32_t touch_id)
     * }
     */
    public static FunctionDescriptor wlr_seat_touch_notify_up$descriptor() {
        return wlr_seat_touch_notify_up.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_touch_notify_up(struct wlr_seat *seat, uint32_t time_msec, int32_t touch_id)
     * }
     */
    public static MethodHandle wlr_seat_touch_notify_up$handle() {
        return wlr_seat_touch_notify_up.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_touch_notify_up(struct wlr_seat *seat, uint32_t time_msec, int32_t touch_id)
     * }
     */
    public static MemorySegment wlr_seat_touch_notify_up$address() {
        return wlr_seat_touch_notify_up.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_touch_notify_up(struct wlr_seat *seat, uint32_t time_msec, int32_t touch_id)
     * }
     */
    public static void wlr_seat_touch_notify_up(MemorySegment seat, int time_msec, int touch_id) {
        var mh$ = wlr_seat_touch_notify_up.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_touch_notify_up", seat, time_msec, touch_id);
            }
            mh$.invokeExact(seat, time_msec, touch_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_touch_notify_motion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_touch_notify_motion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_touch_notify_motion(struct wlr_seat *seat, uint32_t time_msec, int32_t touch_id, double sx, double sy)
     * }
     */
    public static FunctionDescriptor wlr_seat_touch_notify_motion$descriptor() {
        return wlr_seat_touch_notify_motion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_touch_notify_motion(struct wlr_seat *seat, uint32_t time_msec, int32_t touch_id, double sx, double sy)
     * }
     */
    public static MethodHandle wlr_seat_touch_notify_motion$handle() {
        return wlr_seat_touch_notify_motion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_touch_notify_motion(struct wlr_seat *seat, uint32_t time_msec, int32_t touch_id, double sx, double sy)
     * }
     */
    public static MemorySegment wlr_seat_touch_notify_motion$address() {
        return wlr_seat_touch_notify_motion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_touch_notify_motion(struct wlr_seat *seat, uint32_t time_msec, int32_t touch_id, double sx, double sy)
     * }
     */
    public static void wlr_seat_touch_notify_motion(MemorySegment seat, int time_msec, int touch_id, double sx, double sy) {
        var mh$ = wlr_seat_touch_notify_motion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_touch_notify_motion", seat, time_msec, touch_id, sx, sy);
            }
            mh$.invokeExact(seat, time_msec, touch_id, sx, sy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_touch_notify_cancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_touch_notify_cancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_touch_notify_cancel(struct wlr_seat *seat, struct wlr_surface *surface)
     * }
     */
    public static FunctionDescriptor wlr_seat_touch_notify_cancel$descriptor() {
        return wlr_seat_touch_notify_cancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_touch_notify_cancel(struct wlr_seat *seat, struct wlr_surface *surface)
     * }
     */
    public static MethodHandle wlr_seat_touch_notify_cancel$handle() {
        return wlr_seat_touch_notify_cancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_touch_notify_cancel(struct wlr_seat *seat, struct wlr_surface *surface)
     * }
     */
    public static MemorySegment wlr_seat_touch_notify_cancel$address() {
        return wlr_seat_touch_notify_cancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_touch_notify_cancel(struct wlr_seat *seat, struct wlr_surface *surface)
     * }
     */
    public static void wlr_seat_touch_notify_cancel(MemorySegment seat, MemorySegment surface) {
        var mh$ = wlr_seat_touch_notify_cancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_touch_notify_cancel", seat, surface);
            }
            mh$.invokeExact(seat, surface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_touch_notify_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_touch_notify_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_touch_notify_frame(struct wlr_seat *seat)
     * }
     */
    public static FunctionDescriptor wlr_seat_touch_notify_frame$descriptor() {
        return wlr_seat_touch_notify_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_touch_notify_frame(struct wlr_seat *seat)
     * }
     */
    public static MethodHandle wlr_seat_touch_notify_frame$handle() {
        return wlr_seat_touch_notify_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_touch_notify_frame(struct wlr_seat *seat)
     * }
     */
    public static MemorySegment wlr_seat_touch_notify_frame$address() {
        return wlr_seat_touch_notify_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_touch_notify_frame(struct wlr_seat *seat)
     * }
     */
    public static void wlr_seat_touch_notify_frame(MemorySegment seat) {
        var mh$ = wlr_seat_touch_notify_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_touch_notify_frame", seat);
            }
            mh$.invokeExact(seat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_touch_num_points {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_touch_num_points");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wlr_seat_touch_num_points(struct wlr_seat *seat)
     * }
     */
    public static FunctionDescriptor wlr_seat_touch_num_points$descriptor() {
        return wlr_seat_touch_num_points.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wlr_seat_touch_num_points(struct wlr_seat *seat)
     * }
     */
    public static MethodHandle wlr_seat_touch_num_points$handle() {
        return wlr_seat_touch_num_points.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wlr_seat_touch_num_points(struct wlr_seat *seat)
     * }
     */
    public static MemorySegment wlr_seat_touch_num_points$address() {
        return wlr_seat_touch_num_points.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wlr_seat_touch_num_points(struct wlr_seat *seat)
     * }
     */
    public static int wlr_seat_touch_num_points(MemorySegment seat) {
        var mh$ = wlr_seat_touch_num_points.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_touch_num_points", seat);
            }
            return (int)mh$.invokeExact(seat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_touch_start_grab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_touch_start_grab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_touch_start_grab(struct wlr_seat *wlr_seat, struct wlr_seat_touch_grab *grab)
     * }
     */
    public static FunctionDescriptor wlr_seat_touch_start_grab$descriptor() {
        return wlr_seat_touch_start_grab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_touch_start_grab(struct wlr_seat *wlr_seat, struct wlr_seat_touch_grab *grab)
     * }
     */
    public static MethodHandle wlr_seat_touch_start_grab$handle() {
        return wlr_seat_touch_start_grab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_touch_start_grab(struct wlr_seat *wlr_seat, struct wlr_seat_touch_grab *grab)
     * }
     */
    public static MemorySegment wlr_seat_touch_start_grab$address() {
        return wlr_seat_touch_start_grab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_touch_start_grab(struct wlr_seat *wlr_seat, struct wlr_seat_touch_grab *grab)
     * }
     */
    public static void wlr_seat_touch_start_grab(MemorySegment wlr_seat, MemorySegment grab) {
        var mh$ = wlr_seat_touch_start_grab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_touch_start_grab", wlr_seat, grab);
            }
            mh$.invokeExact(wlr_seat, grab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_touch_end_grab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_touch_end_grab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_touch_end_grab(struct wlr_seat *wlr_seat)
     * }
     */
    public static FunctionDescriptor wlr_seat_touch_end_grab$descriptor() {
        return wlr_seat_touch_end_grab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_touch_end_grab(struct wlr_seat *wlr_seat)
     * }
     */
    public static MethodHandle wlr_seat_touch_end_grab$handle() {
        return wlr_seat_touch_end_grab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_touch_end_grab(struct wlr_seat *wlr_seat)
     * }
     */
    public static MemorySegment wlr_seat_touch_end_grab$address() {
        return wlr_seat_touch_end_grab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_touch_end_grab(struct wlr_seat *wlr_seat)
     * }
     */
    public static void wlr_seat_touch_end_grab(MemorySegment wlr_seat) {
        var mh$ = wlr_seat_touch_end_grab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_touch_end_grab", wlr_seat);
            }
            mh$.invokeExact(wlr_seat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_touch_has_grab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_touch_has_grab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_seat_touch_has_grab(struct wlr_seat *seat)
     * }
     */
    public static FunctionDescriptor wlr_seat_touch_has_grab$descriptor() {
        return wlr_seat_touch_has_grab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_seat_touch_has_grab(struct wlr_seat *seat)
     * }
     */
    public static MethodHandle wlr_seat_touch_has_grab$handle() {
        return wlr_seat_touch_has_grab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_seat_touch_has_grab(struct wlr_seat *seat)
     * }
     */
    public static MemorySegment wlr_seat_touch_has_grab$address() {
        return wlr_seat_touch_has_grab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_seat_touch_has_grab(struct wlr_seat *seat)
     * }
     */
    public static boolean wlr_seat_touch_has_grab(MemorySegment seat) {
        var mh$ = wlr_seat_touch_has_grab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_touch_has_grab", seat);
            }
            return (boolean)mh$.invokeExact(seat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_validate_pointer_grab_serial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_validate_pointer_grab_serial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_seat_validate_pointer_grab_serial(struct wlr_seat *seat, struct wlr_surface *origin, uint32_t serial)
     * }
     */
    public static FunctionDescriptor wlr_seat_validate_pointer_grab_serial$descriptor() {
        return wlr_seat_validate_pointer_grab_serial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_seat_validate_pointer_grab_serial(struct wlr_seat *seat, struct wlr_surface *origin, uint32_t serial)
     * }
     */
    public static MethodHandle wlr_seat_validate_pointer_grab_serial$handle() {
        return wlr_seat_validate_pointer_grab_serial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_seat_validate_pointer_grab_serial(struct wlr_seat *seat, struct wlr_surface *origin, uint32_t serial)
     * }
     */
    public static MemorySegment wlr_seat_validate_pointer_grab_serial$address() {
        return wlr_seat_validate_pointer_grab_serial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_seat_validate_pointer_grab_serial(struct wlr_seat *seat, struct wlr_surface *origin, uint32_t serial)
     * }
     */
    public static boolean wlr_seat_validate_pointer_grab_serial(MemorySegment seat, MemorySegment origin, int serial) {
        var mh$ = wlr_seat_validate_pointer_grab_serial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_validate_pointer_grab_serial", seat, origin, serial);
            }
            return (boolean)mh$.invokeExact(seat, origin, serial);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_validate_touch_grab_serial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_validate_touch_grab_serial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_seat_validate_touch_grab_serial(struct wlr_seat *seat, struct wlr_surface *origin, uint32_t serial, struct wlr_touch_point **point_ptr)
     * }
     */
    public static FunctionDescriptor wlr_seat_validate_touch_grab_serial$descriptor() {
        return wlr_seat_validate_touch_grab_serial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_seat_validate_touch_grab_serial(struct wlr_seat *seat, struct wlr_surface *origin, uint32_t serial, struct wlr_touch_point **point_ptr)
     * }
     */
    public static MethodHandle wlr_seat_validate_touch_grab_serial$handle() {
        return wlr_seat_validate_touch_grab_serial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_seat_validate_touch_grab_serial(struct wlr_seat *seat, struct wlr_surface *origin, uint32_t serial, struct wlr_touch_point **point_ptr)
     * }
     */
    public static MemorySegment wlr_seat_validate_touch_grab_serial$address() {
        return wlr_seat_validate_touch_grab_serial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_seat_validate_touch_grab_serial(struct wlr_seat *seat, struct wlr_surface *origin, uint32_t serial, struct wlr_touch_point **point_ptr)
     * }
     */
    public static boolean wlr_seat_validate_touch_grab_serial(MemorySegment seat, MemorySegment origin, int serial, MemorySegment point_ptr) {
        var mh$ = wlr_seat_validate_touch_grab_serial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_validate_touch_grab_serial", seat, origin, serial, point_ptr);
            }
            return (boolean)mh$.invokeExact(seat, origin, serial, point_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_client_next_serial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_client_next_serial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t wlr_seat_client_next_serial(struct wlr_seat_client *client)
     * }
     */
    public static FunctionDescriptor wlr_seat_client_next_serial$descriptor() {
        return wlr_seat_client_next_serial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t wlr_seat_client_next_serial(struct wlr_seat_client *client)
     * }
     */
    public static MethodHandle wlr_seat_client_next_serial$handle() {
        return wlr_seat_client_next_serial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t wlr_seat_client_next_serial(struct wlr_seat_client *client)
     * }
     */
    public static MemorySegment wlr_seat_client_next_serial$address() {
        return wlr_seat_client_next_serial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t wlr_seat_client_next_serial(struct wlr_seat_client *client)
     * }
     */
    public static int wlr_seat_client_next_serial(MemorySegment client) {
        var mh$ = wlr_seat_client_next_serial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_client_next_serial", client);
            }
            return (int)mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_client_validate_event_serial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_client_validate_event_serial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_seat_client_validate_event_serial(struct wlr_seat_client *client, uint32_t serial)
     * }
     */
    public static FunctionDescriptor wlr_seat_client_validate_event_serial$descriptor() {
        return wlr_seat_client_validate_event_serial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_seat_client_validate_event_serial(struct wlr_seat_client *client, uint32_t serial)
     * }
     */
    public static MethodHandle wlr_seat_client_validate_event_serial$handle() {
        return wlr_seat_client_validate_event_serial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_seat_client_validate_event_serial(struct wlr_seat_client *client, uint32_t serial)
     * }
     */
    public static MemorySegment wlr_seat_client_validate_event_serial$address() {
        return wlr_seat_client_validate_event_serial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_seat_client_validate_event_serial(struct wlr_seat_client *client, uint32_t serial)
     * }
     */
    public static boolean wlr_seat_client_validate_event_serial(MemorySegment client, int serial) {
        var mh$ = wlr_seat_client_validate_event_serial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_client_validate_event_serial", client, serial);
            }
            return (boolean)mh$.invokeExact(client, serial);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_client_from_resource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_client_from_resource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_seat_client *wlr_seat_client_from_resource(struct wl_resource *resource)
     * }
     */
    public static FunctionDescriptor wlr_seat_client_from_resource$descriptor() {
        return wlr_seat_client_from_resource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_seat_client *wlr_seat_client_from_resource(struct wl_resource *resource)
     * }
     */
    public static MethodHandle wlr_seat_client_from_resource$handle() {
        return wlr_seat_client_from_resource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_seat_client *wlr_seat_client_from_resource(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wlr_seat_client_from_resource$address() {
        return wlr_seat_client_from_resource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_seat_client *wlr_seat_client_from_resource(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wlr_seat_client_from_resource(MemorySegment resource) {
        var mh$ = wlr_seat_client_from_resource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_client_from_resource", resource);
            }
            return (MemorySegment)mh$.invokeExact(resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_client_from_pointer_resource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_client_from_pointer_resource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_seat_client *wlr_seat_client_from_pointer_resource(struct wl_resource *resource)
     * }
     */
    public static FunctionDescriptor wlr_seat_client_from_pointer_resource$descriptor() {
        return wlr_seat_client_from_pointer_resource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_seat_client *wlr_seat_client_from_pointer_resource(struct wl_resource *resource)
     * }
     */
    public static MethodHandle wlr_seat_client_from_pointer_resource$handle() {
        return wlr_seat_client_from_pointer_resource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_seat_client *wlr_seat_client_from_pointer_resource(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wlr_seat_client_from_pointer_resource$address() {
        return wlr_seat_client_from_pointer_resource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_seat_client *wlr_seat_client_from_pointer_resource(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wlr_seat_client_from_pointer_resource(MemorySegment resource) {
        var mh$ = wlr_seat_client_from_pointer_resource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_client_from_pointer_resource", resource);
            }
            return (MemorySegment)mh$.invokeExact(resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_surface_accepts_touch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_surface_accepts_touch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_surface_accepts_touch(struct wlr_seat *wlr_seat, struct wlr_surface *surface)
     * }
     */
    public static FunctionDescriptor wlr_surface_accepts_touch$descriptor() {
        return wlr_surface_accepts_touch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_surface_accepts_touch(struct wlr_seat *wlr_seat, struct wlr_surface *surface)
     * }
     */
    public static MethodHandle wlr_surface_accepts_touch$handle() {
        return wlr_surface_accepts_touch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_surface_accepts_touch(struct wlr_seat *wlr_seat, struct wlr_surface *surface)
     * }
     */
    public static MemorySegment wlr_surface_accepts_touch$address() {
        return wlr_surface_accepts_touch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_surface_accepts_touch(struct wlr_seat *wlr_seat, struct wlr_surface *surface)
     * }
     */
    public static boolean wlr_surface_accepts_touch(MemorySegment wlr_seat, MemorySegment surface) {
        var mh$ = wlr_surface_accepts_touch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_surface_accepts_touch", wlr_seat, surface);
            }
            return (boolean)mh$.invokeExact(wlr_seat, surface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int WLR_DATA_OFFER_SELECTION = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wlr_data_offer_type.WLR_DATA_OFFER_SELECTION = 0
     * }
     */
    public static int WLR_DATA_OFFER_SELECTION() {
        return WLR_DATA_OFFER_SELECTION;
    }
    private static final int WLR_DATA_OFFER_DRAG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_data_offer_type.WLR_DATA_OFFER_DRAG = 1
     * }
     */
    public static int WLR_DATA_OFFER_DRAG() {
        return WLR_DATA_OFFER_DRAG;
    }
    private static final int WLR_DRAG_GRAB_KEYBOARD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wlr_drag_grab_type.WLR_DRAG_GRAB_KEYBOARD = 0
     * }
     */
    public static int WLR_DRAG_GRAB_KEYBOARD() {
        return WLR_DRAG_GRAB_KEYBOARD;
    }
    private static final int WLR_DRAG_GRAB_KEYBOARD_POINTER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_drag_grab_type.WLR_DRAG_GRAB_KEYBOARD_POINTER = 1
     * }
     */
    public static int WLR_DRAG_GRAB_KEYBOARD_POINTER() {
        return WLR_DRAG_GRAB_KEYBOARD_POINTER;
    }
    private static final int WLR_DRAG_GRAB_KEYBOARD_TOUCH = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wlr_drag_grab_type.WLR_DRAG_GRAB_KEYBOARD_TOUCH = 2
     * }
     */
    public static int WLR_DRAG_GRAB_KEYBOARD_TOUCH() {
        return WLR_DRAG_GRAB_KEYBOARD_TOUCH;
    }

    private static class wlr_data_device_manager_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_data_device_manager_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_data_device_manager *wlr_data_device_manager_create(struct wl_display *display)
     * }
     */
    public static FunctionDescriptor wlr_data_device_manager_create$descriptor() {
        return wlr_data_device_manager_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_data_device_manager *wlr_data_device_manager_create(struct wl_display *display)
     * }
     */
    public static MethodHandle wlr_data_device_manager_create$handle() {
        return wlr_data_device_manager_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_data_device_manager *wlr_data_device_manager_create(struct wl_display *display)
     * }
     */
    public static MemorySegment wlr_data_device_manager_create$address() {
        return wlr_data_device_manager_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_data_device_manager *wlr_data_device_manager_create(struct wl_display *display)
     * }
     */
    public static MemorySegment wlr_data_device_manager_create(MemorySegment display) {
        var mh$ = wlr_data_device_manager_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_data_device_manager_create", display);
            }
            return (MemorySegment)mh$.invokeExact(display);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_request_set_selection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_request_set_selection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_request_set_selection(struct wlr_seat *seat, struct wlr_seat_client *client, struct wlr_data_source *source, uint32_t serial)
     * }
     */
    public static FunctionDescriptor wlr_seat_request_set_selection$descriptor() {
        return wlr_seat_request_set_selection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_request_set_selection(struct wlr_seat *seat, struct wlr_seat_client *client, struct wlr_data_source *source, uint32_t serial)
     * }
     */
    public static MethodHandle wlr_seat_request_set_selection$handle() {
        return wlr_seat_request_set_selection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_request_set_selection(struct wlr_seat *seat, struct wlr_seat_client *client, struct wlr_data_source *source, uint32_t serial)
     * }
     */
    public static MemorySegment wlr_seat_request_set_selection$address() {
        return wlr_seat_request_set_selection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_request_set_selection(struct wlr_seat *seat, struct wlr_seat_client *client, struct wlr_data_source *source, uint32_t serial)
     * }
     */
    public static void wlr_seat_request_set_selection(MemorySegment seat, MemorySegment client, MemorySegment source, int serial) {
        var mh$ = wlr_seat_request_set_selection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_request_set_selection", seat, client, source, serial);
            }
            mh$.invokeExact(seat, client, source, serial);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_set_selection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_set_selection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_set_selection(struct wlr_seat *seat, struct wlr_data_source *source, uint32_t serial)
     * }
     */
    public static FunctionDescriptor wlr_seat_set_selection$descriptor() {
        return wlr_seat_set_selection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_set_selection(struct wlr_seat *seat, struct wlr_data_source *source, uint32_t serial)
     * }
     */
    public static MethodHandle wlr_seat_set_selection$handle() {
        return wlr_seat_set_selection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_set_selection(struct wlr_seat *seat, struct wlr_data_source *source, uint32_t serial)
     * }
     */
    public static MemorySegment wlr_seat_set_selection$address() {
        return wlr_seat_set_selection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_set_selection(struct wlr_seat *seat, struct wlr_data_source *source, uint32_t serial)
     * }
     */
    public static void wlr_seat_set_selection(MemorySegment seat, MemorySegment source, int serial) {
        var mh$ = wlr_seat_set_selection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_set_selection", seat, source, serial);
            }
            mh$.invokeExact(seat, source, serial);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_drag_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_drag_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_drag *wlr_drag_create(struct wlr_seat_client *seat_client, struct wlr_data_source *source, struct wlr_surface *icon_surface)
     * }
     */
    public static FunctionDescriptor wlr_drag_create$descriptor() {
        return wlr_drag_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_drag *wlr_drag_create(struct wlr_seat_client *seat_client, struct wlr_data_source *source, struct wlr_surface *icon_surface)
     * }
     */
    public static MethodHandle wlr_drag_create$handle() {
        return wlr_drag_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_drag *wlr_drag_create(struct wlr_seat_client *seat_client, struct wlr_data_source *source, struct wlr_surface *icon_surface)
     * }
     */
    public static MemorySegment wlr_drag_create$address() {
        return wlr_drag_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_drag *wlr_drag_create(struct wlr_seat_client *seat_client, struct wlr_data_source *source, struct wlr_surface *icon_surface)
     * }
     */
    public static MemorySegment wlr_drag_create(MemorySegment seat_client, MemorySegment source, MemorySegment icon_surface) {
        var mh$ = wlr_drag_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_drag_create", seat_client, source, icon_surface);
            }
            return (MemorySegment)mh$.invokeExact(seat_client, source, icon_surface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_request_start_drag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_request_start_drag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_request_start_drag(struct wlr_seat *seat, struct wlr_drag *drag, struct wlr_surface *origin, uint32_t serial)
     * }
     */
    public static FunctionDescriptor wlr_seat_request_start_drag$descriptor() {
        return wlr_seat_request_start_drag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_request_start_drag(struct wlr_seat *seat, struct wlr_drag *drag, struct wlr_surface *origin, uint32_t serial)
     * }
     */
    public static MethodHandle wlr_seat_request_start_drag$handle() {
        return wlr_seat_request_start_drag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_request_start_drag(struct wlr_seat *seat, struct wlr_drag *drag, struct wlr_surface *origin, uint32_t serial)
     * }
     */
    public static MemorySegment wlr_seat_request_start_drag$address() {
        return wlr_seat_request_start_drag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_request_start_drag(struct wlr_seat *seat, struct wlr_drag *drag, struct wlr_surface *origin, uint32_t serial)
     * }
     */
    public static void wlr_seat_request_start_drag(MemorySegment seat, MemorySegment drag, MemorySegment origin, int serial) {
        var mh$ = wlr_seat_request_start_drag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_request_start_drag", seat, drag, origin, serial);
            }
            mh$.invokeExact(seat, drag, origin, serial);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_start_drag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_start_drag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_start_drag(struct wlr_seat *seat, struct wlr_drag *drag, uint32_t serial)
     * }
     */
    public static FunctionDescriptor wlr_seat_start_drag$descriptor() {
        return wlr_seat_start_drag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_start_drag(struct wlr_seat *seat, struct wlr_drag *drag, uint32_t serial)
     * }
     */
    public static MethodHandle wlr_seat_start_drag$handle() {
        return wlr_seat_start_drag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_start_drag(struct wlr_seat *seat, struct wlr_drag *drag, uint32_t serial)
     * }
     */
    public static MemorySegment wlr_seat_start_drag$address() {
        return wlr_seat_start_drag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_start_drag(struct wlr_seat *seat, struct wlr_drag *drag, uint32_t serial)
     * }
     */
    public static void wlr_seat_start_drag(MemorySegment seat, MemorySegment drag, int serial) {
        var mh$ = wlr_seat_start_drag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_start_drag", seat, drag, serial);
            }
            mh$.invokeExact(seat, drag, serial);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_start_pointer_drag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_start_pointer_drag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_start_pointer_drag(struct wlr_seat *seat, struct wlr_drag *drag, uint32_t serial)
     * }
     */
    public static FunctionDescriptor wlr_seat_start_pointer_drag$descriptor() {
        return wlr_seat_start_pointer_drag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_start_pointer_drag(struct wlr_seat *seat, struct wlr_drag *drag, uint32_t serial)
     * }
     */
    public static MethodHandle wlr_seat_start_pointer_drag$handle() {
        return wlr_seat_start_pointer_drag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_start_pointer_drag(struct wlr_seat *seat, struct wlr_drag *drag, uint32_t serial)
     * }
     */
    public static MemorySegment wlr_seat_start_pointer_drag$address() {
        return wlr_seat_start_pointer_drag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_start_pointer_drag(struct wlr_seat *seat, struct wlr_drag *drag, uint32_t serial)
     * }
     */
    public static void wlr_seat_start_pointer_drag(MemorySegment seat, MemorySegment drag, int serial) {
        var mh$ = wlr_seat_start_pointer_drag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_start_pointer_drag", seat, drag, serial);
            }
            mh$.invokeExact(seat, drag, serial);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_seat_start_touch_drag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_seat_start_touch_drag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_seat_start_touch_drag(struct wlr_seat *seat, struct wlr_drag *drag, uint32_t serial, struct wlr_touch_point *point)
     * }
     */
    public static FunctionDescriptor wlr_seat_start_touch_drag$descriptor() {
        return wlr_seat_start_touch_drag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_seat_start_touch_drag(struct wlr_seat *seat, struct wlr_drag *drag, uint32_t serial, struct wlr_touch_point *point)
     * }
     */
    public static MethodHandle wlr_seat_start_touch_drag$handle() {
        return wlr_seat_start_touch_drag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_seat_start_touch_drag(struct wlr_seat *seat, struct wlr_drag *drag, uint32_t serial, struct wlr_touch_point *point)
     * }
     */
    public static MemorySegment wlr_seat_start_touch_drag$address() {
        return wlr_seat_start_touch_drag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_seat_start_touch_drag(struct wlr_seat *seat, struct wlr_drag *drag, uint32_t serial, struct wlr_touch_point *point)
     * }
     */
    public static void wlr_seat_start_touch_drag(MemorySegment seat, MemorySegment drag, int serial, MemorySegment point) {
        var mh$ = wlr_seat_start_touch_drag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_seat_start_touch_drag", seat, drag, serial, point);
            }
            mh$.invokeExact(seat, drag, serial, point);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_data_source_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_data_source_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_data_source_init(struct wlr_data_source *source, const struct wlr_data_source_impl *impl)
     * }
     */
    public static FunctionDescriptor wlr_data_source_init$descriptor() {
        return wlr_data_source_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_data_source_init(struct wlr_data_source *source, const struct wlr_data_source_impl *impl)
     * }
     */
    public static MethodHandle wlr_data_source_init$handle() {
        return wlr_data_source_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_data_source_init(struct wlr_data_source *source, const struct wlr_data_source_impl *impl)
     * }
     */
    public static MemorySegment wlr_data_source_init$address() {
        return wlr_data_source_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_data_source_init(struct wlr_data_source *source, const struct wlr_data_source_impl *impl)
     * }
     */
    public static void wlr_data_source_init(MemorySegment source, MemorySegment impl) {
        var mh$ = wlr_data_source_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_data_source_init", source, impl);
            }
            mh$.invokeExact(source, impl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_data_source_send {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_data_source_send");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_data_source_send(struct wlr_data_source *source, const char *mime_type, int32_t fd)
     * }
     */
    public static FunctionDescriptor wlr_data_source_send$descriptor() {
        return wlr_data_source_send.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_data_source_send(struct wlr_data_source *source, const char *mime_type, int32_t fd)
     * }
     */
    public static MethodHandle wlr_data_source_send$handle() {
        return wlr_data_source_send.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_data_source_send(struct wlr_data_source *source, const char *mime_type, int32_t fd)
     * }
     */
    public static MemorySegment wlr_data_source_send$address() {
        return wlr_data_source_send.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_data_source_send(struct wlr_data_source *source, const char *mime_type, int32_t fd)
     * }
     */
    public static void wlr_data_source_send(MemorySegment source, MemorySegment mime_type, int fd) {
        var mh$ = wlr_data_source_send.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_data_source_send", source, mime_type, fd);
            }
            mh$.invokeExact(source, mime_type, fd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_data_source_accept {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_data_source_accept");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_data_source_accept(struct wlr_data_source *source, uint32_t serial, const char *mime_type)
     * }
     */
    public static FunctionDescriptor wlr_data_source_accept$descriptor() {
        return wlr_data_source_accept.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_data_source_accept(struct wlr_data_source *source, uint32_t serial, const char *mime_type)
     * }
     */
    public static MethodHandle wlr_data_source_accept$handle() {
        return wlr_data_source_accept.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_data_source_accept(struct wlr_data_source *source, uint32_t serial, const char *mime_type)
     * }
     */
    public static MemorySegment wlr_data_source_accept$address() {
        return wlr_data_source_accept.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_data_source_accept(struct wlr_data_source *source, uint32_t serial, const char *mime_type)
     * }
     */
    public static void wlr_data_source_accept(MemorySegment source, int serial, MemorySegment mime_type) {
        var mh$ = wlr_data_source_accept.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_data_source_accept", source, serial, mime_type);
            }
            mh$.invokeExact(source, serial, mime_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_data_source_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_data_source_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_data_source_destroy(struct wlr_data_source *source)
     * }
     */
    public static FunctionDescriptor wlr_data_source_destroy$descriptor() {
        return wlr_data_source_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_data_source_destroy(struct wlr_data_source *source)
     * }
     */
    public static MethodHandle wlr_data_source_destroy$handle() {
        return wlr_data_source_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_data_source_destroy(struct wlr_data_source *source)
     * }
     */
    public static MemorySegment wlr_data_source_destroy$address() {
        return wlr_data_source_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_data_source_destroy(struct wlr_data_source *source)
     * }
     */
    public static void wlr_data_source_destroy(MemorySegment source) {
        var mh$ = wlr_data_source_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_data_source_destroy", source);
            }
            mh$.invokeExact(source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_data_source_dnd_drop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_data_source_dnd_drop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_data_source_dnd_drop(struct wlr_data_source *source)
     * }
     */
    public static FunctionDescriptor wlr_data_source_dnd_drop$descriptor() {
        return wlr_data_source_dnd_drop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_data_source_dnd_drop(struct wlr_data_source *source)
     * }
     */
    public static MethodHandle wlr_data_source_dnd_drop$handle() {
        return wlr_data_source_dnd_drop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_data_source_dnd_drop(struct wlr_data_source *source)
     * }
     */
    public static MemorySegment wlr_data_source_dnd_drop$address() {
        return wlr_data_source_dnd_drop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_data_source_dnd_drop(struct wlr_data_source *source)
     * }
     */
    public static void wlr_data_source_dnd_drop(MemorySegment source) {
        var mh$ = wlr_data_source_dnd_drop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_data_source_dnd_drop", source);
            }
            mh$.invokeExact(source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_data_source_dnd_finish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_data_source_dnd_finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_data_source_dnd_finish(struct wlr_data_source *source)
     * }
     */
    public static FunctionDescriptor wlr_data_source_dnd_finish$descriptor() {
        return wlr_data_source_dnd_finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_data_source_dnd_finish(struct wlr_data_source *source)
     * }
     */
    public static MethodHandle wlr_data_source_dnd_finish$handle() {
        return wlr_data_source_dnd_finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_data_source_dnd_finish(struct wlr_data_source *source)
     * }
     */
    public static MemorySegment wlr_data_source_dnd_finish$address() {
        return wlr_data_source_dnd_finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_data_source_dnd_finish(struct wlr_data_source *source)
     * }
     */
    public static void wlr_data_source_dnd_finish(MemorySegment source) {
        var mh$ = wlr_data_source_dnd_finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_data_source_dnd_finish", source);
            }
            mh$.invokeExact(source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_data_source_dnd_action {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_data_source_dnd_action");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_data_source_dnd_action(struct wlr_data_source *source, enum wl_data_device_manager_dnd_action action)
     * }
     */
    public static FunctionDescriptor wlr_data_source_dnd_action$descriptor() {
        return wlr_data_source_dnd_action.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_data_source_dnd_action(struct wlr_data_source *source, enum wl_data_device_manager_dnd_action action)
     * }
     */
    public static MethodHandle wlr_data_source_dnd_action$handle() {
        return wlr_data_source_dnd_action.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_data_source_dnd_action(struct wlr_data_source *source, enum wl_data_device_manager_dnd_action action)
     * }
     */
    public static MemorySegment wlr_data_source_dnd_action$address() {
        return wlr_data_source_dnd_action.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_data_source_dnd_action(struct wlr_data_source *source, enum wl_data_device_manager_dnd_action action)
     * }
     */
    public static void wlr_data_source_dnd_action(MemorySegment source, int action) {
        var mh$ = wlr_data_source_dnd_action.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_data_source_dnd_action", source, action);
            }
            mh$.invokeExact(source, action);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_damage_ring_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_damage_ring_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_damage_ring_init(struct wlr_damage_ring *ring)
     * }
     */
    public static FunctionDescriptor wlr_damage_ring_init$descriptor() {
        return wlr_damage_ring_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_damage_ring_init(struct wlr_damage_ring *ring)
     * }
     */
    public static MethodHandle wlr_damage_ring_init$handle() {
        return wlr_damage_ring_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_damage_ring_init(struct wlr_damage_ring *ring)
     * }
     */
    public static MemorySegment wlr_damage_ring_init$address() {
        return wlr_damage_ring_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_damage_ring_init(struct wlr_damage_ring *ring)
     * }
     */
    public static void wlr_damage_ring_init(MemorySegment ring) {
        var mh$ = wlr_damage_ring_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_damage_ring_init", ring);
            }
            mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_damage_ring_finish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_damage_ring_finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_damage_ring_finish(struct wlr_damage_ring *ring)
     * }
     */
    public static FunctionDescriptor wlr_damage_ring_finish$descriptor() {
        return wlr_damage_ring_finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_damage_ring_finish(struct wlr_damage_ring *ring)
     * }
     */
    public static MethodHandle wlr_damage_ring_finish$handle() {
        return wlr_damage_ring_finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_damage_ring_finish(struct wlr_damage_ring *ring)
     * }
     */
    public static MemorySegment wlr_damage_ring_finish$address() {
        return wlr_damage_ring_finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_damage_ring_finish(struct wlr_damage_ring *ring)
     * }
     */
    public static void wlr_damage_ring_finish(MemorySegment ring) {
        var mh$ = wlr_damage_ring_finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_damage_ring_finish", ring);
            }
            mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_damage_ring_set_bounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_damage_ring_set_bounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_damage_ring_set_bounds(struct wlr_damage_ring *ring, int32_t width, int32_t height)
     * }
     */
    public static FunctionDescriptor wlr_damage_ring_set_bounds$descriptor() {
        return wlr_damage_ring_set_bounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_damage_ring_set_bounds(struct wlr_damage_ring *ring, int32_t width, int32_t height)
     * }
     */
    public static MethodHandle wlr_damage_ring_set_bounds$handle() {
        return wlr_damage_ring_set_bounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_damage_ring_set_bounds(struct wlr_damage_ring *ring, int32_t width, int32_t height)
     * }
     */
    public static MemorySegment wlr_damage_ring_set_bounds$address() {
        return wlr_damage_ring_set_bounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_damage_ring_set_bounds(struct wlr_damage_ring *ring, int32_t width, int32_t height)
     * }
     */
    public static void wlr_damage_ring_set_bounds(MemorySegment ring, int width, int height) {
        var mh$ = wlr_damage_ring_set_bounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_damage_ring_set_bounds", ring, width, height);
            }
            mh$.invokeExact(ring, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_damage_ring_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_damage_ring_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_damage_ring_add(struct wlr_damage_ring *ring, const pixman_region32_t *damage)
     * }
     */
    public static FunctionDescriptor wlr_damage_ring_add$descriptor() {
        return wlr_damage_ring_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_damage_ring_add(struct wlr_damage_ring *ring, const pixman_region32_t *damage)
     * }
     */
    public static MethodHandle wlr_damage_ring_add$handle() {
        return wlr_damage_ring_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_damage_ring_add(struct wlr_damage_ring *ring, const pixman_region32_t *damage)
     * }
     */
    public static MemorySegment wlr_damage_ring_add$address() {
        return wlr_damage_ring_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_damage_ring_add(struct wlr_damage_ring *ring, const pixman_region32_t *damage)
     * }
     */
    public static boolean wlr_damage_ring_add(MemorySegment ring, MemorySegment damage) {
        var mh$ = wlr_damage_ring_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_damage_ring_add", ring, damage);
            }
            return (boolean)mh$.invokeExact(ring, damage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_damage_ring_add_box {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_damage_ring_add_box");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_damage_ring_add_box(struct wlr_damage_ring *ring, const struct wlr_box *box)
     * }
     */
    public static FunctionDescriptor wlr_damage_ring_add_box$descriptor() {
        return wlr_damage_ring_add_box.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_damage_ring_add_box(struct wlr_damage_ring *ring, const struct wlr_box *box)
     * }
     */
    public static MethodHandle wlr_damage_ring_add_box$handle() {
        return wlr_damage_ring_add_box.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_damage_ring_add_box(struct wlr_damage_ring *ring, const struct wlr_box *box)
     * }
     */
    public static MemorySegment wlr_damage_ring_add_box$address() {
        return wlr_damage_ring_add_box.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_damage_ring_add_box(struct wlr_damage_ring *ring, const struct wlr_box *box)
     * }
     */
    public static boolean wlr_damage_ring_add_box(MemorySegment ring, MemorySegment box) {
        var mh$ = wlr_damage_ring_add_box.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_damage_ring_add_box", ring, box);
            }
            return (boolean)mh$.invokeExact(ring, box);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_damage_ring_add_whole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_damage_ring_add_whole");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_damage_ring_add_whole(struct wlr_damage_ring *ring)
     * }
     */
    public static FunctionDescriptor wlr_damage_ring_add_whole$descriptor() {
        return wlr_damage_ring_add_whole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_damage_ring_add_whole(struct wlr_damage_ring *ring)
     * }
     */
    public static MethodHandle wlr_damage_ring_add_whole$handle() {
        return wlr_damage_ring_add_whole.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_damage_ring_add_whole(struct wlr_damage_ring *ring)
     * }
     */
    public static MemorySegment wlr_damage_ring_add_whole$address() {
        return wlr_damage_ring_add_whole.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_damage_ring_add_whole(struct wlr_damage_ring *ring)
     * }
     */
    public static void wlr_damage_ring_add_whole(MemorySegment ring) {
        var mh$ = wlr_damage_ring_add_whole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_damage_ring_add_whole", ring);
            }
            mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_damage_ring_rotate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_damage_ring_rotate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_damage_ring_rotate(struct wlr_damage_ring *ring)
     * }
     */
    public static FunctionDescriptor wlr_damage_ring_rotate$descriptor() {
        return wlr_damage_ring_rotate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_damage_ring_rotate(struct wlr_damage_ring *ring)
     * }
     */
    public static MethodHandle wlr_damage_ring_rotate$handle() {
        return wlr_damage_ring_rotate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_damage_ring_rotate(struct wlr_damage_ring *ring)
     * }
     */
    public static MemorySegment wlr_damage_ring_rotate$address() {
        return wlr_damage_ring_rotate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_damage_ring_rotate(struct wlr_damage_ring *ring)
     * }
     */
    public static void wlr_damage_ring_rotate(MemorySegment ring) {
        var mh$ = wlr_damage_ring_rotate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_damage_ring_rotate", ring);
            }
            mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_damage_ring_get_buffer_damage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_damage_ring_get_buffer_damage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_damage_ring_get_buffer_damage(struct wlr_damage_ring *ring, int buffer_age, pixman_region32_t *damage)
     * }
     */
    public static FunctionDescriptor wlr_damage_ring_get_buffer_damage$descriptor() {
        return wlr_damage_ring_get_buffer_damage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_damage_ring_get_buffer_damage(struct wlr_damage_ring *ring, int buffer_age, pixman_region32_t *damage)
     * }
     */
    public static MethodHandle wlr_damage_ring_get_buffer_damage$handle() {
        return wlr_damage_ring_get_buffer_damage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_damage_ring_get_buffer_damage(struct wlr_damage_ring *ring, int buffer_age, pixman_region32_t *damage)
     * }
     */
    public static MemorySegment wlr_damage_ring_get_buffer_damage$address() {
        return wlr_damage_ring_get_buffer_damage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_damage_ring_get_buffer_damage(struct wlr_damage_ring *ring, int buffer_age, pixman_region32_t *damage)
     * }
     */
    public static void wlr_damage_ring_get_buffer_damage(MemorySegment ring, int buffer_age, MemorySegment damage) {
        var mh$ = wlr_damage_ring_get_buffer_damage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_damage_ring_get_buffer_damage", ring, buffer_age, damage);
            }
            mh$.invokeExact(ring, buffer_age, damage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("stat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int stat(const char *restrict __file, struct stat *restrict __buf)
     * }
     */
    public static FunctionDescriptor stat$descriptor() {
        return stat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int stat(const char *restrict __file, struct stat *restrict __buf)
     * }
     */
    public static MethodHandle stat$handle() {
        return stat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int stat(const char *restrict __file, struct stat *restrict __buf)
     * }
     */
    public static MemorySegment stat$address() {
        return stat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int stat(const char *restrict __file, struct stat *restrict __buf)
     * }
     */
    public static int stat(MemorySegment __file, MemorySegment __buf) {
        var mh$ = stat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stat", __file, __buf);
            }
            return (int)mh$.invokeExact(__file, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fstat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("fstat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fstat(int __fd, struct stat *__buf)
     * }
     */
    public static FunctionDescriptor fstat$descriptor() {
        return fstat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fstat(int __fd, struct stat *__buf)
     * }
     */
    public static MethodHandle fstat$handle() {
        return fstat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fstat(int __fd, struct stat *__buf)
     * }
     */
    public static MemorySegment fstat$address() {
        return fstat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fstat(int __fd, struct stat *__buf)
     * }
     */
    public static int fstat(int __fd, MemorySegment __buf) {
        var mh$ = fstat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fstat", __fd, __buf);
            }
            return (int)mh$.invokeExact(__fd, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fstatat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("fstatat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fstatat(int __fd, const char *restrict __file, struct stat *restrict __buf, int __flag)
     * }
     */
    public static FunctionDescriptor fstatat$descriptor() {
        return fstatat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fstatat(int __fd, const char *restrict __file, struct stat *restrict __buf, int __flag)
     * }
     */
    public static MethodHandle fstatat$handle() {
        return fstatat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fstatat(int __fd, const char *restrict __file, struct stat *restrict __buf, int __flag)
     * }
     */
    public static MemorySegment fstatat$address() {
        return fstatat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fstatat(int __fd, const char *restrict __file, struct stat *restrict __buf, int __flag)
     * }
     */
    public static int fstatat(int __fd, MemorySegment __file, MemorySegment __buf, int __flag) {
        var mh$ = fstatat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fstatat", __fd, __file, __buf, __flag);
            }
            return (int)mh$.invokeExact(__fd, __file, __buf, __flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("lstat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lstat(const char *restrict __file, struct stat *restrict __buf)
     * }
     */
    public static FunctionDescriptor lstat$descriptor() {
        return lstat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lstat(const char *restrict __file, struct stat *restrict __buf)
     * }
     */
    public static MethodHandle lstat$handle() {
        return lstat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lstat(const char *restrict __file, struct stat *restrict __buf)
     * }
     */
    public static MemorySegment lstat$address() {
        return lstat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lstat(const char *restrict __file, struct stat *restrict __buf)
     * }
     */
    public static int lstat(MemorySegment __file, MemorySegment __buf) {
        var mh$ = lstat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstat", __file, __buf);
            }
            return (int)mh$.invokeExact(__file, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("chmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int chmod(const char *__file, __mode_t __mode)
     * }
     */
    public static FunctionDescriptor chmod$descriptor() {
        return chmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int chmod(const char *__file, __mode_t __mode)
     * }
     */
    public static MethodHandle chmod$handle() {
        return chmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int chmod(const char *__file, __mode_t __mode)
     * }
     */
    public static MemorySegment chmod$address() {
        return chmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int chmod(const char *__file, __mode_t __mode)
     * }
     */
    public static int chmod(MemorySegment __file, int __mode) {
        var mh$ = chmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chmod", __file, __mode);
            }
            return (int)mh$.invokeExact(__file, __mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lchmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("lchmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lchmod(const char *__file, __mode_t __mode)
     * }
     */
    public static FunctionDescriptor lchmod$descriptor() {
        return lchmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lchmod(const char *__file, __mode_t __mode)
     * }
     */
    public static MethodHandle lchmod$handle() {
        return lchmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lchmod(const char *__file, __mode_t __mode)
     * }
     */
    public static MemorySegment lchmod$address() {
        return lchmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lchmod(const char *__file, __mode_t __mode)
     * }
     */
    public static int lchmod(MemorySegment __file, int __mode) {
        var mh$ = lchmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lchmod", __file, __mode);
            }
            return (int)mh$.invokeExact(__file, __mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("fchmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fchmod(int __fd, __mode_t __mode)
     * }
     */
    public static FunctionDescriptor fchmod$descriptor() {
        return fchmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fchmod(int __fd, __mode_t __mode)
     * }
     */
    public static MethodHandle fchmod$handle() {
        return fchmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fchmod(int __fd, __mode_t __mode)
     * }
     */
    public static MemorySegment fchmod$address() {
        return fchmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fchmod(int __fd, __mode_t __mode)
     * }
     */
    public static int fchmod(int __fd, int __mode) {
        var mh$ = fchmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchmod", __fd, __mode);
            }
            return (int)mh$.invokeExact(__fd, __mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchmodat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("fchmodat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fchmodat(int __fd, const char *__file, __mode_t __mode, int __flag)
     * }
     */
    public static FunctionDescriptor fchmodat$descriptor() {
        return fchmodat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fchmodat(int __fd, const char *__file, __mode_t __mode, int __flag)
     * }
     */
    public static MethodHandle fchmodat$handle() {
        return fchmodat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fchmodat(int __fd, const char *__file, __mode_t __mode, int __flag)
     * }
     */
    public static MemorySegment fchmodat$address() {
        return fchmodat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fchmodat(int __fd, const char *__file, __mode_t __mode, int __flag)
     * }
     */
    public static int fchmodat(int __fd, MemorySegment __file, int __mode, int __flag) {
        var mh$ = fchmodat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchmodat", __fd, __file, __mode, __flag);
            }
            return (int)mh$.invokeExact(__fd, __file, __mode, __flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("umask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __mode_t umask(__mode_t __mask)
     * }
     */
    public static FunctionDescriptor umask$descriptor() {
        return umask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __mode_t umask(__mode_t __mask)
     * }
     */
    public static MethodHandle umask$handle() {
        return umask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __mode_t umask(__mode_t __mask)
     * }
     */
    public static MemorySegment umask$address() {
        return umask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __mode_t umask(__mode_t __mask)
     * }
     */
    public static int umask(int __mask) {
        var mh$ = umask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umask", __mask);
            }
            return (int)mh$.invokeExact(__mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("mkdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkdir(const char *__path, __mode_t __mode)
     * }
     */
    public static FunctionDescriptor mkdir$descriptor() {
        return mkdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkdir(const char *__path, __mode_t __mode)
     * }
     */
    public static MethodHandle mkdir$handle() {
        return mkdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkdir(const char *__path, __mode_t __mode)
     * }
     */
    public static MemorySegment mkdir$address() {
        return mkdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkdir(const char *__path, __mode_t __mode)
     * }
     */
    public static int mkdir(MemorySegment __path, int __mode) {
        var mh$ = mkdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdir", __path, __mode);
            }
            return (int)mh$.invokeExact(__path, __mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdirat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("mkdirat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkdirat(int __fd, const char *__path, __mode_t __mode)
     * }
     */
    public static FunctionDescriptor mkdirat$descriptor() {
        return mkdirat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkdirat(int __fd, const char *__path, __mode_t __mode)
     * }
     */
    public static MethodHandle mkdirat$handle() {
        return mkdirat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkdirat(int __fd, const char *__path, __mode_t __mode)
     * }
     */
    public static MemorySegment mkdirat$address() {
        return mkdirat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkdirat(int __fd, const char *__path, __mode_t __mode)
     * }
     */
    public static int mkdirat(int __fd, MemorySegment __path, int __mode) {
        var mh$ = mkdirat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdirat", __fd, __path, __mode);
            }
            return (int)mh$.invokeExact(__fd, __path, __mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mknod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_LONG
        );

        public static final MemorySegment ADDR = C.findOrThrow("mknod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mknod(const char *__path, __mode_t __mode, __dev_t __dev)
     * }
     */
    public static FunctionDescriptor mknod$descriptor() {
        return mknod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mknod(const char *__path, __mode_t __mode, __dev_t __dev)
     * }
     */
    public static MethodHandle mknod$handle() {
        return mknod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mknod(const char *__path, __mode_t __mode, __dev_t __dev)
     * }
     */
    public static MemorySegment mknod$address() {
        return mknod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mknod(const char *__path, __mode_t __mode, __dev_t __dev)
     * }
     */
    public static int mknod(MemorySegment __path, int __mode, long __dev) {
        var mh$ = mknod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mknod", __path, __mode, __dev);
            }
            return (int)mh$.invokeExact(__path, __mode, __dev);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mknodat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_INT,
            C.C_LONG
        );

        public static final MemorySegment ADDR = C.findOrThrow("mknodat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mknodat(int __fd, const char *__path, __mode_t __mode, __dev_t __dev)
     * }
     */
    public static FunctionDescriptor mknodat$descriptor() {
        return mknodat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mknodat(int __fd, const char *__path, __mode_t __mode, __dev_t __dev)
     * }
     */
    public static MethodHandle mknodat$handle() {
        return mknodat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mknodat(int __fd, const char *__path, __mode_t __mode, __dev_t __dev)
     * }
     */
    public static MemorySegment mknodat$address() {
        return mknodat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mknodat(int __fd, const char *__path, __mode_t __mode, __dev_t __dev)
     * }
     */
    public static int mknodat(int __fd, MemorySegment __path, int __mode, long __dev) {
        var mh$ = mknodat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mknodat", __fd, __path, __mode, __dev);
            }
            return (int)mh$.invokeExact(__fd, __path, __mode, __dev);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkfifo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("mkfifo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkfifo(const char *__path, __mode_t __mode)
     * }
     */
    public static FunctionDescriptor mkfifo$descriptor() {
        return mkfifo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkfifo(const char *__path, __mode_t __mode)
     * }
     */
    public static MethodHandle mkfifo$handle() {
        return mkfifo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkfifo(const char *__path, __mode_t __mode)
     * }
     */
    public static MemorySegment mkfifo$address() {
        return mkfifo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkfifo(const char *__path, __mode_t __mode)
     * }
     */
    public static int mkfifo(MemorySegment __path, int __mode) {
        var mh$ = mkfifo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkfifo", __path, __mode);
            }
            return (int)mh$.invokeExact(__path, __mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkfifoat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("mkfifoat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkfifoat(int __fd, const char *__path, __mode_t __mode)
     * }
     */
    public static FunctionDescriptor mkfifoat$descriptor() {
        return mkfifoat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkfifoat(int __fd, const char *__path, __mode_t __mode)
     * }
     */
    public static MethodHandle mkfifoat$handle() {
        return mkfifoat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkfifoat(int __fd, const char *__path, __mode_t __mode)
     * }
     */
    public static MemorySegment mkfifoat$address() {
        return mkfifoat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkfifoat(int __fd, const char *__path, __mode_t __mode)
     * }
     */
    public static int mkfifoat(int __fd, MemorySegment __path, int __mode) {
        var mh$ = mkfifoat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkfifoat", __fd, __path, __mode);
            }
            return (int)mh$.invokeExact(__fd, __path, __mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class utimensat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("utimensat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flags)
     * }
     */
    public static FunctionDescriptor utimensat$descriptor() {
        return utimensat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flags)
     * }
     */
    public static MethodHandle utimensat$handle() {
        return utimensat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flags)
     * }
     */
    public static MemorySegment utimensat$address() {
        return utimensat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flags)
     * }
     */
    public static int utimensat(int __fd, MemorySegment __path, MemorySegment __times, int __flags) {
        var mh$ = utimensat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("utimensat", __fd, __path, __times, __flags);
            }
            return (int)mh$.invokeExact(__fd, __path, __times, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class futimens {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("futimens");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static FunctionDescriptor futimens$descriptor() {
        return futimens.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static MethodHandle futimens$handle() {
        return futimens.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static MemorySegment futimens$address() {
        return futimens.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static int futimens(int __fd, MemorySegment __times) {
        var mh$ = futimens.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("futimens", __fd, __times);
            }
            return (int)mh$.invokeExact(__fd, __times);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_drm_format_finish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_drm_format_finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_drm_format_finish(struct wlr_drm_format *format)
     * }
     */
    public static FunctionDescriptor wlr_drm_format_finish$descriptor() {
        return wlr_drm_format_finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_drm_format_finish(struct wlr_drm_format *format)
     * }
     */
    public static MethodHandle wlr_drm_format_finish$handle() {
        return wlr_drm_format_finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_drm_format_finish(struct wlr_drm_format *format)
     * }
     */
    public static MemorySegment wlr_drm_format_finish$address() {
        return wlr_drm_format_finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_drm_format_finish(struct wlr_drm_format *format)
     * }
     */
    public static void wlr_drm_format_finish(MemorySegment format) {
        var mh$ = wlr_drm_format_finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_drm_format_finish", format);
            }
            mh$.invokeExact(format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_drm_format_set_finish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_drm_format_set_finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_drm_format_set_finish(struct wlr_drm_format_set *set)
     * }
     */
    public static FunctionDescriptor wlr_drm_format_set_finish$descriptor() {
        return wlr_drm_format_set_finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_drm_format_set_finish(struct wlr_drm_format_set *set)
     * }
     */
    public static MethodHandle wlr_drm_format_set_finish$handle() {
        return wlr_drm_format_set_finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_drm_format_set_finish(struct wlr_drm_format_set *set)
     * }
     */
    public static MemorySegment wlr_drm_format_set_finish$address() {
        return wlr_drm_format_set_finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_drm_format_set_finish(struct wlr_drm_format_set *set)
     * }
     */
    public static void wlr_drm_format_set_finish(MemorySegment set) {
        var mh$ = wlr_drm_format_set_finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_drm_format_set_finish", set);
            }
            mh$.invokeExact(set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_drm_format_set_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_drm_format_set_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const struct wlr_drm_format *wlr_drm_format_set_get(const struct wlr_drm_format_set *set, uint32_t format)
     * }
     */
    public static FunctionDescriptor wlr_drm_format_set_get$descriptor() {
        return wlr_drm_format_set_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const struct wlr_drm_format *wlr_drm_format_set_get(const struct wlr_drm_format_set *set, uint32_t format)
     * }
     */
    public static MethodHandle wlr_drm_format_set_get$handle() {
        return wlr_drm_format_set_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const struct wlr_drm_format *wlr_drm_format_set_get(const struct wlr_drm_format_set *set, uint32_t format)
     * }
     */
    public static MemorySegment wlr_drm_format_set_get$address() {
        return wlr_drm_format_set_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const struct wlr_drm_format *wlr_drm_format_set_get(const struct wlr_drm_format_set *set, uint32_t format)
     * }
     */
    public static MemorySegment wlr_drm_format_set_get(MemorySegment set, int format) {
        var mh$ = wlr_drm_format_set_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_drm_format_set_get", set, format);
            }
            return (MemorySegment)mh$.invokeExact(set, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_drm_format_set_has {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_INT,
            C.C_LONG
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_drm_format_set_has");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_drm_format_set_has(const struct wlr_drm_format_set *set, uint32_t format, uint64_t modifier)
     * }
     */
    public static FunctionDescriptor wlr_drm_format_set_has$descriptor() {
        return wlr_drm_format_set_has.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_drm_format_set_has(const struct wlr_drm_format_set *set, uint32_t format, uint64_t modifier)
     * }
     */
    public static MethodHandle wlr_drm_format_set_has$handle() {
        return wlr_drm_format_set_has.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_drm_format_set_has(const struct wlr_drm_format_set *set, uint32_t format, uint64_t modifier)
     * }
     */
    public static MemorySegment wlr_drm_format_set_has$address() {
        return wlr_drm_format_set_has.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_drm_format_set_has(const struct wlr_drm_format_set *set, uint32_t format, uint64_t modifier)
     * }
     */
    public static boolean wlr_drm_format_set_has(MemorySegment set, int format, long modifier) {
        var mh$ = wlr_drm_format_set_has.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_drm_format_set_has", set, format, modifier);
            }
            return (boolean)mh$.invokeExact(set, format, modifier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_drm_format_set_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_INT,
            C.C_LONG
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_drm_format_set_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_drm_format_set_add(struct wlr_drm_format_set *set, uint32_t format, uint64_t modifier)
     * }
     */
    public static FunctionDescriptor wlr_drm_format_set_add$descriptor() {
        return wlr_drm_format_set_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_drm_format_set_add(struct wlr_drm_format_set *set, uint32_t format, uint64_t modifier)
     * }
     */
    public static MethodHandle wlr_drm_format_set_add$handle() {
        return wlr_drm_format_set_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_drm_format_set_add(struct wlr_drm_format_set *set, uint32_t format, uint64_t modifier)
     * }
     */
    public static MemorySegment wlr_drm_format_set_add$address() {
        return wlr_drm_format_set_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_drm_format_set_add(struct wlr_drm_format_set *set, uint32_t format, uint64_t modifier)
     * }
     */
    public static boolean wlr_drm_format_set_add(MemorySegment set, int format, long modifier) {
        var mh$ = wlr_drm_format_set_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_drm_format_set_add", set, format, modifier);
            }
            return (boolean)mh$.invokeExact(set, format, modifier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_drm_format_set_intersect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_drm_format_set_intersect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_drm_format_set_intersect(struct wlr_drm_format_set *dst, const struct wlr_drm_format_set *a, const struct wlr_drm_format_set *b)
     * }
     */
    public static FunctionDescriptor wlr_drm_format_set_intersect$descriptor() {
        return wlr_drm_format_set_intersect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_drm_format_set_intersect(struct wlr_drm_format_set *dst, const struct wlr_drm_format_set *a, const struct wlr_drm_format_set *b)
     * }
     */
    public static MethodHandle wlr_drm_format_set_intersect$handle() {
        return wlr_drm_format_set_intersect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_drm_format_set_intersect(struct wlr_drm_format_set *dst, const struct wlr_drm_format_set *a, const struct wlr_drm_format_set *b)
     * }
     */
    public static MemorySegment wlr_drm_format_set_intersect$address() {
        return wlr_drm_format_set_intersect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_drm_format_set_intersect(struct wlr_drm_format_set *dst, const struct wlr_drm_format_set *a, const struct wlr_drm_format_set *b)
     * }
     */
    public static boolean wlr_drm_format_set_intersect(MemorySegment dst, MemorySegment a, MemorySegment b) {
        var mh$ = wlr_drm_format_set_intersect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_drm_format_set_intersect", dst, a, b);
            }
            return (boolean)mh$.invokeExact(dst, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_drm_format_set_union {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_drm_format_set_union");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_drm_format_set_union(struct wlr_drm_format_set *dst, const struct wlr_drm_format_set *a, const struct wlr_drm_format_set *b)
     * }
     */
    public static FunctionDescriptor wlr_drm_format_set_union$descriptor() {
        return wlr_drm_format_set_union.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_drm_format_set_union(struct wlr_drm_format_set *dst, const struct wlr_drm_format_set *a, const struct wlr_drm_format_set *b)
     * }
     */
    public static MethodHandle wlr_drm_format_set_union$handle() {
        return wlr_drm_format_set_union.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_drm_format_set_union(struct wlr_drm_format_set *dst, const struct wlr_drm_format_set *a, const struct wlr_drm_format_set *b)
     * }
     */
    public static MemorySegment wlr_drm_format_set_union$address() {
        return wlr_drm_format_set_union.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_drm_format_set_union(struct wlr_drm_format_set *dst, const struct wlr_drm_format_set *a, const struct wlr_drm_format_set *b)
     * }
     */
    public static boolean wlr_drm_format_set_union(MemorySegment dst, MemorySegment a, MemorySegment b) {
        var mh$ = wlr_drm_format_set_union.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_drm_format_set_union", dst, a, b);
            }
            return (boolean)mh$.invokeExact(dst, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_dmabuf_v1_buffer_try_from_buffer_resource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_dmabuf_v1_buffer_try_from_buffer_resource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_dmabuf_v1_buffer *wlr_dmabuf_v1_buffer_try_from_buffer_resource(struct wl_resource *buffer_resource)
     * }
     */
    public static FunctionDescriptor wlr_dmabuf_v1_buffer_try_from_buffer_resource$descriptor() {
        return wlr_dmabuf_v1_buffer_try_from_buffer_resource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_dmabuf_v1_buffer *wlr_dmabuf_v1_buffer_try_from_buffer_resource(struct wl_resource *buffer_resource)
     * }
     */
    public static MethodHandle wlr_dmabuf_v1_buffer_try_from_buffer_resource$handle() {
        return wlr_dmabuf_v1_buffer_try_from_buffer_resource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_dmabuf_v1_buffer *wlr_dmabuf_v1_buffer_try_from_buffer_resource(struct wl_resource *buffer_resource)
     * }
     */
    public static MemorySegment wlr_dmabuf_v1_buffer_try_from_buffer_resource$address() {
        return wlr_dmabuf_v1_buffer_try_from_buffer_resource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_dmabuf_v1_buffer *wlr_dmabuf_v1_buffer_try_from_buffer_resource(struct wl_resource *buffer_resource)
     * }
     */
    public static MemorySegment wlr_dmabuf_v1_buffer_try_from_buffer_resource(MemorySegment buffer_resource) {
        var mh$ = wlr_dmabuf_v1_buffer_try_from_buffer_resource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_dmabuf_v1_buffer_try_from_buffer_resource", buffer_resource);
            }
            return (MemorySegment)mh$.invokeExact(buffer_resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_linux_dmabuf_v1_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_linux_dmabuf_v1_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_linux_dmabuf_v1 *wlr_linux_dmabuf_v1_create(struct wl_display *display, uint32_t version, const struct wlr_linux_dmabuf_feedback_v1 *default_feedback)
     * }
     */
    public static FunctionDescriptor wlr_linux_dmabuf_v1_create$descriptor() {
        return wlr_linux_dmabuf_v1_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_linux_dmabuf_v1 *wlr_linux_dmabuf_v1_create(struct wl_display *display, uint32_t version, const struct wlr_linux_dmabuf_feedback_v1 *default_feedback)
     * }
     */
    public static MethodHandle wlr_linux_dmabuf_v1_create$handle() {
        return wlr_linux_dmabuf_v1_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_linux_dmabuf_v1 *wlr_linux_dmabuf_v1_create(struct wl_display *display, uint32_t version, const struct wlr_linux_dmabuf_feedback_v1 *default_feedback)
     * }
     */
    public static MemorySegment wlr_linux_dmabuf_v1_create$address() {
        return wlr_linux_dmabuf_v1_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_linux_dmabuf_v1 *wlr_linux_dmabuf_v1_create(struct wl_display *display, uint32_t version, const struct wlr_linux_dmabuf_feedback_v1 *default_feedback)
     * }
     */
    public static MemorySegment wlr_linux_dmabuf_v1_create(MemorySegment display, int version, MemorySegment default_feedback) {
        var mh$ = wlr_linux_dmabuf_v1_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_linux_dmabuf_v1_create", display, version, default_feedback);
            }
            return (MemorySegment)mh$.invokeExact(display, version, default_feedback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_linux_dmabuf_v1_create_with_renderer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_linux_dmabuf_v1_create_with_renderer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_linux_dmabuf_v1 *wlr_linux_dmabuf_v1_create_with_renderer(struct wl_display *display, uint32_t version, struct wlr_renderer *renderer)
     * }
     */
    public static FunctionDescriptor wlr_linux_dmabuf_v1_create_with_renderer$descriptor() {
        return wlr_linux_dmabuf_v1_create_with_renderer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_linux_dmabuf_v1 *wlr_linux_dmabuf_v1_create_with_renderer(struct wl_display *display, uint32_t version, struct wlr_renderer *renderer)
     * }
     */
    public static MethodHandle wlr_linux_dmabuf_v1_create_with_renderer$handle() {
        return wlr_linux_dmabuf_v1_create_with_renderer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_linux_dmabuf_v1 *wlr_linux_dmabuf_v1_create_with_renderer(struct wl_display *display, uint32_t version, struct wlr_renderer *renderer)
     * }
     */
    public static MemorySegment wlr_linux_dmabuf_v1_create_with_renderer$address() {
        return wlr_linux_dmabuf_v1_create_with_renderer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_linux_dmabuf_v1 *wlr_linux_dmabuf_v1_create_with_renderer(struct wl_display *display, uint32_t version, struct wlr_renderer *renderer)
     * }
     */
    public static MemorySegment wlr_linux_dmabuf_v1_create_with_renderer(MemorySegment display, int version, MemorySegment renderer) {
        var mh$ = wlr_linux_dmabuf_v1_create_with_renderer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_linux_dmabuf_v1_create_with_renderer", display, version, renderer);
            }
            return (MemorySegment)mh$.invokeExact(display, version, renderer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_linux_dmabuf_v1_set_surface_feedback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_linux_dmabuf_v1_set_surface_feedback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_linux_dmabuf_v1_set_surface_feedback(struct wlr_linux_dmabuf_v1 *linux_dmabuf, struct wlr_surface *surface, const struct wlr_linux_dmabuf_feedback_v1 *feedback)
     * }
     */
    public static FunctionDescriptor wlr_linux_dmabuf_v1_set_surface_feedback$descriptor() {
        return wlr_linux_dmabuf_v1_set_surface_feedback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_linux_dmabuf_v1_set_surface_feedback(struct wlr_linux_dmabuf_v1 *linux_dmabuf, struct wlr_surface *surface, const struct wlr_linux_dmabuf_feedback_v1 *feedback)
     * }
     */
    public static MethodHandle wlr_linux_dmabuf_v1_set_surface_feedback$handle() {
        return wlr_linux_dmabuf_v1_set_surface_feedback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_linux_dmabuf_v1_set_surface_feedback(struct wlr_linux_dmabuf_v1 *linux_dmabuf, struct wlr_surface *surface, const struct wlr_linux_dmabuf_feedback_v1 *feedback)
     * }
     */
    public static MemorySegment wlr_linux_dmabuf_v1_set_surface_feedback$address() {
        return wlr_linux_dmabuf_v1_set_surface_feedback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_linux_dmabuf_v1_set_surface_feedback(struct wlr_linux_dmabuf_v1 *linux_dmabuf, struct wlr_surface *surface, const struct wlr_linux_dmabuf_feedback_v1 *feedback)
     * }
     */
    public static boolean wlr_linux_dmabuf_v1_set_surface_feedback(MemorySegment linux_dmabuf, MemorySegment surface, MemorySegment feedback) {
        var mh$ = wlr_linux_dmabuf_v1_set_surface_feedback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_linux_dmabuf_v1_set_surface_feedback", linux_dmabuf, surface, feedback);
            }
            return (boolean)mh$.invokeExact(linux_dmabuf, surface, feedback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_linux_dmabuf_feedback_add_tranche {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_linux_dmabuf_feedback_add_tranche");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_linux_dmabuf_feedback_v1_tranche *wlr_linux_dmabuf_feedback_add_tranche(struct wlr_linux_dmabuf_feedback_v1 *feedback)
     * }
     */
    public static FunctionDescriptor wlr_linux_dmabuf_feedback_add_tranche$descriptor() {
        return wlr_linux_dmabuf_feedback_add_tranche.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_linux_dmabuf_feedback_v1_tranche *wlr_linux_dmabuf_feedback_add_tranche(struct wlr_linux_dmabuf_feedback_v1 *feedback)
     * }
     */
    public static MethodHandle wlr_linux_dmabuf_feedback_add_tranche$handle() {
        return wlr_linux_dmabuf_feedback_add_tranche.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_linux_dmabuf_feedback_v1_tranche *wlr_linux_dmabuf_feedback_add_tranche(struct wlr_linux_dmabuf_feedback_v1 *feedback)
     * }
     */
    public static MemorySegment wlr_linux_dmabuf_feedback_add_tranche$address() {
        return wlr_linux_dmabuf_feedback_add_tranche.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_linux_dmabuf_feedback_v1_tranche *wlr_linux_dmabuf_feedback_add_tranche(struct wlr_linux_dmabuf_feedback_v1 *feedback)
     * }
     */
    public static MemorySegment wlr_linux_dmabuf_feedback_add_tranche(MemorySegment feedback) {
        var mh$ = wlr_linux_dmabuf_feedback_add_tranche.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_linux_dmabuf_feedback_add_tranche", feedback);
            }
            return (MemorySegment)mh$.invokeExact(feedback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_linux_dmabuf_feedback_v1_finish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_linux_dmabuf_feedback_v1_finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_linux_dmabuf_feedback_v1_finish(struct wlr_linux_dmabuf_feedback_v1 *feedback)
     * }
     */
    public static FunctionDescriptor wlr_linux_dmabuf_feedback_v1_finish$descriptor() {
        return wlr_linux_dmabuf_feedback_v1_finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_linux_dmabuf_feedback_v1_finish(struct wlr_linux_dmabuf_feedback_v1 *feedback)
     * }
     */
    public static MethodHandle wlr_linux_dmabuf_feedback_v1_finish$handle() {
        return wlr_linux_dmabuf_feedback_v1_finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_linux_dmabuf_feedback_v1_finish(struct wlr_linux_dmabuf_feedback_v1 *feedback)
     * }
     */
    public static MemorySegment wlr_linux_dmabuf_feedback_v1_finish$address() {
        return wlr_linux_dmabuf_feedback_v1_finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_linux_dmabuf_feedback_v1_finish(struct wlr_linux_dmabuf_feedback_v1 *feedback)
     * }
     */
    public static void wlr_linux_dmabuf_feedback_v1_finish(MemorySegment feedback) {
        var mh$ = wlr_linux_dmabuf_feedback_v1_finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_linux_dmabuf_feedback_v1_finish", feedback);
            }
            mh$.invokeExact(feedback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_linux_dmabuf_feedback_v1_init_with_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_linux_dmabuf_feedback_v1_init_with_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_linux_dmabuf_feedback_v1_init_with_options(struct wlr_linux_dmabuf_feedback_v1 *feedback, const struct wlr_linux_dmabuf_feedback_v1_init_options *options)
     * }
     */
    public static FunctionDescriptor wlr_linux_dmabuf_feedback_v1_init_with_options$descriptor() {
        return wlr_linux_dmabuf_feedback_v1_init_with_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_linux_dmabuf_feedback_v1_init_with_options(struct wlr_linux_dmabuf_feedback_v1 *feedback, const struct wlr_linux_dmabuf_feedback_v1_init_options *options)
     * }
     */
    public static MethodHandle wlr_linux_dmabuf_feedback_v1_init_with_options$handle() {
        return wlr_linux_dmabuf_feedback_v1_init_with_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_linux_dmabuf_feedback_v1_init_with_options(struct wlr_linux_dmabuf_feedback_v1 *feedback, const struct wlr_linux_dmabuf_feedback_v1_init_options *options)
     * }
     */
    public static MemorySegment wlr_linux_dmabuf_feedback_v1_init_with_options$address() {
        return wlr_linux_dmabuf_feedback_v1_init_with_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_linux_dmabuf_feedback_v1_init_with_options(struct wlr_linux_dmabuf_feedback_v1 *feedback, const struct wlr_linux_dmabuf_feedback_v1_init_options *options)
     * }
     */
    public static boolean wlr_linux_dmabuf_feedback_v1_init_with_options(MemorySegment feedback, MemorySegment options) {
        var mh$ = wlr_linux_dmabuf_feedback_v1_init_with_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_linux_dmabuf_feedback_v1_init_with_options", feedback, options);
            }
            return (boolean)mh$.invokeExact(feedback, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int WLR_SCENE_NODE_TREE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wlr_scene_node_type.WLR_SCENE_NODE_TREE = 0
     * }
     */
    public static int WLR_SCENE_NODE_TREE() {
        return WLR_SCENE_NODE_TREE;
    }
    private static final int WLR_SCENE_NODE_RECT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_scene_node_type.WLR_SCENE_NODE_RECT = 1
     * }
     */
    public static int WLR_SCENE_NODE_RECT() {
        return WLR_SCENE_NODE_RECT;
    }
    private static final int WLR_SCENE_NODE_BUFFER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wlr_scene_node_type.WLR_SCENE_NODE_BUFFER = 2
     * }
     */
    public static int WLR_SCENE_NODE_BUFFER() {
        return WLR_SCENE_NODE_BUFFER;
    }
    private static final int WLR_SCENE_DEBUG_DAMAGE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wlr_scene_debug_damage_option.WLR_SCENE_DEBUG_DAMAGE_NONE = 0
     * }
     */
    public static int WLR_SCENE_DEBUG_DAMAGE_NONE() {
        return WLR_SCENE_DEBUG_DAMAGE_NONE;
    }
    private static final int WLR_SCENE_DEBUG_DAMAGE_RERENDER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_scene_debug_damage_option.WLR_SCENE_DEBUG_DAMAGE_RERENDER = 1
     * }
     */
    public static int WLR_SCENE_DEBUG_DAMAGE_RERENDER() {
        return WLR_SCENE_DEBUG_DAMAGE_RERENDER;
    }
    private static final int WLR_SCENE_DEBUG_DAMAGE_HIGHLIGHT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wlr_scene_debug_damage_option.WLR_SCENE_DEBUG_DAMAGE_HIGHLIGHT = 2
     * }
     */
    public static int WLR_SCENE_DEBUG_DAMAGE_HIGHLIGHT() {
        return WLR_SCENE_DEBUG_DAMAGE_HIGHLIGHT;
    }

    private static class wlr_scene_node_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_node_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_node_destroy(struct wlr_scene_node *node)
     * }
     */
    public static FunctionDescriptor wlr_scene_node_destroy$descriptor() {
        return wlr_scene_node_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_node_destroy(struct wlr_scene_node *node)
     * }
     */
    public static MethodHandle wlr_scene_node_destroy$handle() {
        return wlr_scene_node_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_node_destroy(struct wlr_scene_node *node)
     * }
     */
    public static MemorySegment wlr_scene_node_destroy$address() {
        return wlr_scene_node_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_node_destroy(struct wlr_scene_node *node)
     * }
     */
    public static void wlr_scene_node_destroy(MemorySegment node) {
        var mh$ = wlr_scene_node_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_node_destroy", node);
            }
            mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_node_set_enabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_BOOL
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_node_set_enabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_node_set_enabled(struct wlr_scene_node *node, bool enabled)
     * }
     */
    public static FunctionDescriptor wlr_scene_node_set_enabled$descriptor() {
        return wlr_scene_node_set_enabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_node_set_enabled(struct wlr_scene_node *node, bool enabled)
     * }
     */
    public static MethodHandle wlr_scene_node_set_enabled$handle() {
        return wlr_scene_node_set_enabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_node_set_enabled(struct wlr_scene_node *node, bool enabled)
     * }
     */
    public static MemorySegment wlr_scene_node_set_enabled$address() {
        return wlr_scene_node_set_enabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_node_set_enabled(struct wlr_scene_node *node, bool enabled)
     * }
     */
    public static void wlr_scene_node_set_enabled(MemorySegment node, boolean enabled) {
        var mh$ = wlr_scene_node_set_enabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_node_set_enabled", node, enabled);
            }
            mh$.invokeExact(node, enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_node_set_position {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_node_set_position");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_node_set_position(struct wlr_scene_node *node, int x, int y)
     * }
     */
    public static FunctionDescriptor wlr_scene_node_set_position$descriptor() {
        return wlr_scene_node_set_position.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_node_set_position(struct wlr_scene_node *node, int x, int y)
     * }
     */
    public static MethodHandle wlr_scene_node_set_position$handle() {
        return wlr_scene_node_set_position.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_node_set_position(struct wlr_scene_node *node, int x, int y)
     * }
     */
    public static MemorySegment wlr_scene_node_set_position$address() {
        return wlr_scene_node_set_position.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_node_set_position(struct wlr_scene_node *node, int x, int y)
     * }
     */
    public static void wlr_scene_node_set_position(MemorySegment node, int x, int y) {
        var mh$ = wlr_scene_node_set_position.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_node_set_position", node, x, y);
            }
            mh$.invokeExact(node, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_node_place_above {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_node_place_above");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_node_place_above(struct wlr_scene_node *node, struct wlr_scene_node *sibling)
     * }
     */
    public static FunctionDescriptor wlr_scene_node_place_above$descriptor() {
        return wlr_scene_node_place_above.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_node_place_above(struct wlr_scene_node *node, struct wlr_scene_node *sibling)
     * }
     */
    public static MethodHandle wlr_scene_node_place_above$handle() {
        return wlr_scene_node_place_above.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_node_place_above(struct wlr_scene_node *node, struct wlr_scene_node *sibling)
     * }
     */
    public static MemorySegment wlr_scene_node_place_above$address() {
        return wlr_scene_node_place_above.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_node_place_above(struct wlr_scene_node *node, struct wlr_scene_node *sibling)
     * }
     */
    public static void wlr_scene_node_place_above(MemorySegment node, MemorySegment sibling) {
        var mh$ = wlr_scene_node_place_above.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_node_place_above", node, sibling);
            }
            mh$.invokeExact(node, sibling);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_node_place_below {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_node_place_below");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_node_place_below(struct wlr_scene_node *node, struct wlr_scene_node *sibling)
     * }
     */
    public static FunctionDescriptor wlr_scene_node_place_below$descriptor() {
        return wlr_scene_node_place_below.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_node_place_below(struct wlr_scene_node *node, struct wlr_scene_node *sibling)
     * }
     */
    public static MethodHandle wlr_scene_node_place_below$handle() {
        return wlr_scene_node_place_below.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_node_place_below(struct wlr_scene_node *node, struct wlr_scene_node *sibling)
     * }
     */
    public static MemorySegment wlr_scene_node_place_below$address() {
        return wlr_scene_node_place_below.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_node_place_below(struct wlr_scene_node *node, struct wlr_scene_node *sibling)
     * }
     */
    public static void wlr_scene_node_place_below(MemorySegment node, MemorySegment sibling) {
        var mh$ = wlr_scene_node_place_below.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_node_place_below", node, sibling);
            }
            mh$.invokeExact(node, sibling);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_node_raise_to_top {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_node_raise_to_top");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_node_raise_to_top(struct wlr_scene_node *node)
     * }
     */
    public static FunctionDescriptor wlr_scene_node_raise_to_top$descriptor() {
        return wlr_scene_node_raise_to_top.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_node_raise_to_top(struct wlr_scene_node *node)
     * }
     */
    public static MethodHandle wlr_scene_node_raise_to_top$handle() {
        return wlr_scene_node_raise_to_top.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_node_raise_to_top(struct wlr_scene_node *node)
     * }
     */
    public static MemorySegment wlr_scene_node_raise_to_top$address() {
        return wlr_scene_node_raise_to_top.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_node_raise_to_top(struct wlr_scene_node *node)
     * }
     */
    public static void wlr_scene_node_raise_to_top(MemorySegment node) {
        var mh$ = wlr_scene_node_raise_to_top.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_node_raise_to_top", node);
            }
            mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_node_lower_to_bottom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_node_lower_to_bottom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_node_lower_to_bottom(struct wlr_scene_node *node)
     * }
     */
    public static FunctionDescriptor wlr_scene_node_lower_to_bottom$descriptor() {
        return wlr_scene_node_lower_to_bottom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_node_lower_to_bottom(struct wlr_scene_node *node)
     * }
     */
    public static MethodHandle wlr_scene_node_lower_to_bottom$handle() {
        return wlr_scene_node_lower_to_bottom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_node_lower_to_bottom(struct wlr_scene_node *node)
     * }
     */
    public static MemorySegment wlr_scene_node_lower_to_bottom$address() {
        return wlr_scene_node_lower_to_bottom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_node_lower_to_bottom(struct wlr_scene_node *node)
     * }
     */
    public static void wlr_scene_node_lower_to_bottom(MemorySegment node) {
        var mh$ = wlr_scene_node_lower_to_bottom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_node_lower_to_bottom", node);
            }
            mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_node_reparent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_node_reparent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_node_reparent(struct wlr_scene_node *node, struct wlr_scene_tree *new_parent)
     * }
     */
    public static FunctionDescriptor wlr_scene_node_reparent$descriptor() {
        return wlr_scene_node_reparent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_node_reparent(struct wlr_scene_node *node, struct wlr_scene_tree *new_parent)
     * }
     */
    public static MethodHandle wlr_scene_node_reparent$handle() {
        return wlr_scene_node_reparent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_node_reparent(struct wlr_scene_node *node, struct wlr_scene_tree *new_parent)
     * }
     */
    public static MemorySegment wlr_scene_node_reparent$address() {
        return wlr_scene_node_reparent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_node_reparent(struct wlr_scene_node *node, struct wlr_scene_tree *new_parent)
     * }
     */
    public static void wlr_scene_node_reparent(MemorySegment node, MemorySegment new_parent) {
        var mh$ = wlr_scene_node_reparent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_node_reparent", node, new_parent);
            }
            mh$.invokeExact(node, new_parent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_node_coords {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_node_coords");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_scene_node_coords(struct wlr_scene_node *node, int *lx, int *ly)
     * }
     */
    public static FunctionDescriptor wlr_scene_node_coords$descriptor() {
        return wlr_scene_node_coords.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_scene_node_coords(struct wlr_scene_node *node, int *lx, int *ly)
     * }
     */
    public static MethodHandle wlr_scene_node_coords$handle() {
        return wlr_scene_node_coords.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_scene_node_coords(struct wlr_scene_node *node, int *lx, int *ly)
     * }
     */
    public static MemorySegment wlr_scene_node_coords$address() {
        return wlr_scene_node_coords.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_scene_node_coords(struct wlr_scene_node *node, int *lx, int *ly)
     * }
     */
    public static boolean wlr_scene_node_coords(MemorySegment node, MemorySegment lx, MemorySegment ly) {
        var mh$ = wlr_scene_node_coords.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_node_coords", node, lx, ly);
            }
            return (boolean)mh$.invokeExact(node, lx, ly);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_node_for_each_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_node_for_each_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_node_for_each_buffer(struct wlr_scene_node *node, wlr_scene_buffer_iterator_func_t iterator, void *user_data)
     * }
     */
    public static FunctionDescriptor wlr_scene_node_for_each_buffer$descriptor() {
        return wlr_scene_node_for_each_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_node_for_each_buffer(struct wlr_scene_node *node, wlr_scene_buffer_iterator_func_t iterator, void *user_data)
     * }
     */
    public static MethodHandle wlr_scene_node_for_each_buffer$handle() {
        return wlr_scene_node_for_each_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_node_for_each_buffer(struct wlr_scene_node *node, wlr_scene_buffer_iterator_func_t iterator, void *user_data)
     * }
     */
    public static MemorySegment wlr_scene_node_for_each_buffer$address() {
        return wlr_scene_node_for_each_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_node_for_each_buffer(struct wlr_scene_node *node, wlr_scene_buffer_iterator_func_t iterator, void *user_data)
     * }
     */
    public static void wlr_scene_node_for_each_buffer(MemorySegment node, MemorySegment iterator, MemorySegment user_data) {
        var mh$ = wlr_scene_node_for_each_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_node_for_each_buffer", node, iterator, user_data);
            }
            mh$.invokeExact(node, iterator, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_node_at {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_node_at");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_scene_node *wlr_scene_node_at(struct wlr_scene_node *node, double lx, double ly, double *nx, double *ny)
     * }
     */
    public static FunctionDescriptor wlr_scene_node_at$descriptor() {
        return wlr_scene_node_at.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_scene_node *wlr_scene_node_at(struct wlr_scene_node *node, double lx, double ly, double *nx, double *ny)
     * }
     */
    public static MethodHandle wlr_scene_node_at$handle() {
        return wlr_scene_node_at.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_scene_node *wlr_scene_node_at(struct wlr_scene_node *node, double lx, double ly, double *nx, double *ny)
     * }
     */
    public static MemorySegment wlr_scene_node_at$address() {
        return wlr_scene_node_at.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_scene_node *wlr_scene_node_at(struct wlr_scene_node *node, double lx, double ly, double *nx, double *ny)
     * }
     */
    public static MemorySegment wlr_scene_node_at(MemorySegment node, double lx, double ly, MemorySegment nx, MemorySegment ny) {
        var mh$ = wlr_scene_node_at.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_node_at", node, lx, ly, nx, ny);
            }
            return (MemorySegment)mh$.invokeExact(node, lx, ly, nx, ny);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER    );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_scene *wlr_scene_create()
     * }
     */
    public static FunctionDescriptor wlr_scene_create$descriptor() {
        return wlr_scene_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_scene *wlr_scene_create()
     * }
     */
    public static MethodHandle wlr_scene_create$handle() {
        return wlr_scene_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_scene *wlr_scene_create()
     * }
     */
    public static MemorySegment wlr_scene_create$address() {
        return wlr_scene_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_scene *wlr_scene_create()
     * }
     */
    public static MemorySegment wlr_scene_create() {
        var mh$ = wlr_scene_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_create");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_set_presentation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_set_presentation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_set_presentation(struct wlr_scene *scene, struct wlr_presentation *presentation)
     * }
     */
    public static FunctionDescriptor wlr_scene_set_presentation$descriptor() {
        return wlr_scene_set_presentation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_set_presentation(struct wlr_scene *scene, struct wlr_presentation *presentation)
     * }
     */
    public static MethodHandle wlr_scene_set_presentation$handle() {
        return wlr_scene_set_presentation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_set_presentation(struct wlr_scene *scene, struct wlr_presentation *presentation)
     * }
     */
    public static MemorySegment wlr_scene_set_presentation$address() {
        return wlr_scene_set_presentation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_set_presentation(struct wlr_scene *scene, struct wlr_presentation *presentation)
     * }
     */
    public static void wlr_scene_set_presentation(MemorySegment scene, MemorySegment presentation) {
        var mh$ = wlr_scene_set_presentation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_set_presentation", scene, presentation);
            }
            mh$.invokeExact(scene, presentation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_set_linux_dmabuf_v1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_set_linux_dmabuf_v1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_set_linux_dmabuf_v1(struct wlr_scene *scene, struct wlr_linux_dmabuf_v1 *linux_dmabuf_v1)
     * }
     */
    public static FunctionDescriptor wlr_scene_set_linux_dmabuf_v1$descriptor() {
        return wlr_scene_set_linux_dmabuf_v1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_set_linux_dmabuf_v1(struct wlr_scene *scene, struct wlr_linux_dmabuf_v1 *linux_dmabuf_v1)
     * }
     */
    public static MethodHandle wlr_scene_set_linux_dmabuf_v1$handle() {
        return wlr_scene_set_linux_dmabuf_v1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_set_linux_dmabuf_v1(struct wlr_scene *scene, struct wlr_linux_dmabuf_v1 *linux_dmabuf_v1)
     * }
     */
    public static MemorySegment wlr_scene_set_linux_dmabuf_v1$address() {
        return wlr_scene_set_linux_dmabuf_v1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_set_linux_dmabuf_v1(struct wlr_scene *scene, struct wlr_linux_dmabuf_v1 *linux_dmabuf_v1)
     * }
     */
    public static void wlr_scene_set_linux_dmabuf_v1(MemorySegment scene, MemorySegment linux_dmabuf_v1) {
        var mh$ = wlr_scene_set_linux_dmabuf_v1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_set_linux_dmabuf_v1", scene, linux_dmabuf_v1);
            }
            mh$.invokeExact(scene, linux_dmabuf_v1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_tree_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_tree_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_scene_tree *wlr_scene_tree_create(struct wlr_scene_tree *parent)
     * }
     */
    public static FunctionDescriptor wlr_scene_tree_create$descriptor() {
        return wlr_scene_tree_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_scene_tree *wlr_scene_tree_create(struct wlr_scene_tree *parent)
     * }
     */
    public static MethodHandle wlr_scene_tree_create$handle() {
        return wlr_scene_tree_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_scene_tree *wlr_scene_tree_create(struct wlr_scene_tree *parent)
     * }
     */
    public static MemorySegment wlr_scene_tree_create$address() {
        return wlr_scene_tree_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_scene_tree *wlr_scene_tree_create(struct wlr_scene_tree *parent)
     * }
     */
    public static MemorySegment wlr_scene_tree_create(MemorySegment parent) {
        var mh$ = wlr_scene_tree_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_tree_create", parent);
            }
            return (MemorySegment)mh$.invokeExact(parent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_surface_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_surface_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_scene_surface *wlr_scene_surface_create(struct wlr_scene_tree *parent, struct wlr_surface *surface)
     * }
     */
    public static FunctionDescriptor wlr_scene_surface_create$descriptor() {
        return wlr_scene_surface_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_scene_surface *wlr_scene_surface_create(struct wlr_scene_tree *parent, struct wlr_surface *surface)
     * }
     */
    public static MethodHandle wlr_scene_surface_create$handle() {
        return wlr_scene_surface_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_scene_surface *wlr_scene_surface_create(struct wlr_scene_tree *parent, struct wlr_surface *surface)
     * }
     */
    public static MemorySegment wlr_scene_surface_create$address() {
        return wlr_scene_surface_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_scene_surface *wlr_scene_surface_create(struct wlr_scene_tree *parent, struct wlr_surface *surface)
     * }
     */
    public static MemorySegment wlr_scene_surface_create(MemorySegment parent, MemorySegment surface) {
        var mh$ = wlr_scene_surface_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_surface_create", parent, surface);
            }
            return (MemorySegment)mh$.invokeExact(parent, surface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_buffer_from_node {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_buffer_from_node");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_scene_buffer *wlr_scene_buffer_from_node(struct wlr_scene_node *node)
     * }
     */
    public static FunctionDescriptor wlr_scene_buffer_from_node$descriptor() {
        return wlr_scene_buffer_from_node.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_scene_buffer *wlr_scene_buffer_from_node(struct wlr_scene_node *node)
     * }
     */
    public static MethodHandle wlr_scene_buffer_from_node$handle() {
        return wlr_scene_buffer_from_node.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_scene_buffer *wlr_scene_buffer_from_node(struct wlr_scene_node *node)
     * }
     */
    public static MemorySegment wlr_scene_buffer_from_node$address() {
        return wlr_scene_buffer_from_node.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_scene_buffer *wlr_scene_buffer_from_node(struct wlr_scene_node *node)
     * }
     */
    public static MemorySegment wlr_scene_buffer_from_node(MemorySegment node) {
        var mh$ = wlr_scene_buffer_from_node.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_buffer_from_node", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_tree_from_node {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_tree_from_node");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_scene_tree *wlr_scene_tree_from_node(struct wlr_scene_node *node)
     * }
     */
    public static FunctionDescriptor wlr_scene_tree_from_node$descriptor() {
        return wlr_scene_tree_from_node.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_scene_tree *wlr_scene_tree_from_node(struct wlr_scene_node *node)
     * }
     */
    public static MethodHandle wlr_scene_tree_from_node$handle() {
        return wlr_scene_tree_from_node.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_scene_tree *wlr_scene_tree_from_node(struct wlr_scene_node *node)
     * }
     */
    public static MemorySegment wlr_scene_tree_from_node$address() {
        return wlr_scene_tree_from_node.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_scene_tree *wlr_scene_tree_from_node(struct wlr_scene_node *node)
     * }
     */
    public static MemorySegment wlr_scene_tree_from_node(MemorySegment node) {
        var mh$ = wlr_scene_tree_from_node.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_tree_from_node", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_rect_from_node {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_rect_from_node");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_scene_rect *wlr_scene_rect_from_node(struct wlr_scene_node *node)
     * }
     */
    public static FunctionDescriptor wlr_scene_rect_from_node$descriptor() {
        return wlr_scene_rect_from_node.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_scene_rect *wlr_scene_rect_from_node(struct wlr_scene_node *node)
     * }
     */
    public static MethodHandle wlr_scene_rect_from_node$handle() {
        return wlr_scene_rect_from_node.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_scene_rect *wlr_scene_rect_from_node(struct wlr_scene_node *node)
     * }
     */
    public static MemorySegment wlr_scene_rect_from_node$address() {
        return wlr_scene_rect_from_node.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_scene_rect *wlr_scene_rect_from_node(struct wlr_scene_node *node)
     * }
     */
    public static MemorySegment wlr_scene_rect_from_node(MemorySegment node) {
        var mh$ = wlr_scene_rect_from_node.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_rect_from_node", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_surface_try_from_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_surface_try_from_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_scene_surface *wlr_scene_surface_try_from_buffer(struct wlr_scene_buffer *scene_buffer)
     * }
     */
    public static FunctionDescriptor wlr_scene_surface_try_from_buffer$descriptor() {
        return wlr_scene_surface_try_from_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_scene_surface *wlr_scene_surface_try_from_buffer(struct wlr_scene_buffer *scene_buffer)
     * }
     */
    public static MethodHandle wlr_scene_surface_try_from_buffer$handle() {
        return wlr_scene_surface_try_from_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_scene_surface *wlr_scene_surface_try_from_buffer(struct wlr_scene_buffer *scene_buffer)
     * }
     */
    public static MemorySegment wlr_scene_surface_try_from_buffer$address() {
        return wlr_scene_surface_try_from_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_scene_surface *wlr_scene_surface_try_from_buffer(struct wlr_scene_buffer *scene_buffer)
     * }
     */
    public static MemorySegment wlr_scene_surface_try_from_buffer(MemorySegment scene_buffer) {
        var mh$ = wlr_scene_surface_try_from_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_surface_try_from_buffer", scene_buffer);
            }
            return (MemorySegment)mh$.invokeExact(scene_buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_rect_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_rect_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_scene_rect *wlr_scene_rect_create(struct wlr_scene_tree *parent, int width, int height, const float color[static 4])
     * }
     */
    public static FunctionDescriptor wlr_scene_rect_create$descriptor() {
        return wlr_scene_rect_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_scene_rect *wlr_scene_rect_create(struct wlr_scene_tree *parent, int width, int height, const float color[static 4])
     * }
     */
    public static MethodHandle wlr_scene_rect_create$handle() {
        return wlr_scene_rect_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_scene_rect *wlr_scene_rect_create(struct wlr_scene_tree *parent, int width, int height, const float color[static 4])
     * }
     */
    public static MemorySegment wlr_scene_rect_create$address() {
        return wlr_scene_rect_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_scene_rect *wlr_scene_rect_create(struct wlr_scene_tree *parent, int width, int height, const float color[static 4])
     * }
     */
    public static MemorySegment wlr_scene_rect_create(MemorySegment parent, int width, int height, MemorySegment color) {
        var mh$ = wlr_scene_rect_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_rect_create", parent, width, height, color);
            }
            return (MemorySegment)mh$.invokeExact(parent, width, height, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_rect_set_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_rect_set_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_rect_set_size(struct wlr_scene_rect *rect, int width, int height)
     * }
     */
    public static FunctionDescriptor wlr_scene_rect_set_size$descriptor() {
        return wlr_scene_rect_set_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_rect_set_size(struct wlr_scene_rect *rect, int width, int height)
     * }
     */
    public static MethodHandle wlr_scene_rect_set_size$handle() {
        return wlr_scene_rect_set_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_rect_set_size(struct wlr_scene_rect *rect, int width, int height)
     * }
     */
    public static MemorySegment wlr_scene_rect_set_size$address() {
        return wlr_scene_rect_set_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_rect_set_size(struct wlr_scene_rect *rect, int width, int height)
     * }
     */
    public static void wlr_scene_rect_set_size(MemorySegment rect, int width, int height) {
        var mh$ = wlr_scene_rect_set_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_rect_set_size", rect, width, height);
            }
            mh$.invokeExact(rect, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_rect_set_color {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_rect_set_color");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_rect_set_color(struct wlr_scene_rect *rect, const float color[static 4])
     * }
     */
    public static FunctionDescriptor wlr_scene_rect_set_color$descriptor() {
        return wlr_scene_rect_set_color.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_rect_set_color(struct wlr_scene_rect *rect, const float color[static 4])
     * }
     */
    public static MethodHandle wlr_scene_rect_set_color$handle() {
        return wlr_scene_rect_set_color.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_rect_set_color(struct wlr_scene_rect *rect, const float color[static 4])
     * }
     */
    public static MemorySegment wlr_scene_rect_set_color$address() {
        return wlr_scene_rect_set_color.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_rect_set_color(struct wlr_scene_rect *rect, const float color[static 4])
     * }
     */
    public static void wlr_scene_rect_set_color(MemorySegment rect, MemorySegment color) {
        var mh$ = wlr_scene_rect_set_color.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_rect_set_color", rect, color);
            }
            mh$.invokeExact(rect, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_buffer_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_buffer_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_scene_buffer *wlr_scene_buffer_create(struct wlr_scene_tree *parent, struct wlr_buffer *buffer)
     * }
     */
    public static FunctionDescriptor wlr_scene_buffer_create$descriptor() {
        return wlr_scene_buffer_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_scene_buffer *wlr_scene_buffer_create(struct wlr_scene_tree *parent, struct wlr_buffer *buffer)
     * }
     */
    public static MethodHandle wlr_scene_buffer_create$handle() {
        return wlr_scene_buffer_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_scene_buffer *wlr_scene_buffer_create(struct wlr_scene_tree *parent, struct wlr_buffer *buffer)
     * }
     */
    public static MemorySegment wlr_scene_buffer_create$address() {
        return wlr_scene_buffer_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_scene_buffer *wlr_scene_buffer_create(struct wlr_scene_tree *parent, struct wlr_buffer *buffer)
     * }
     */
    public static MemorySegment wlr_scene_buffer_create(MemorySegment parent, MemorySegment buffer) {
        var mh$ = wlr_scene_buffer_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_buffer_create", parent, buffer);
            }
            return (MemorySegment)mh$.invokeExact(parent, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_buffer_set_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_buffer_set_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_buffer(struct wlr_scene_buffer *scene_buffer, struct wlr_buffer *buffer)
     * }
     */
    public static FunctionDescriptor wlr_scene_buffer_set_buffer$descriptor() {
        return wlr_scene_buffer_set_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_buffer(struct wlr_scene_buffer *scene_buffer, struct wlr_buffer *buffer)
     * }
     */
    public static MethodHandle wlr_scene_buffer_set_buffer$handle() {
        return wlr_scene_buffer_set_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_buffer(struct wlr_scene_buffer *scene_buffer, struct wlr_buffer *buffer)
     * }
     */
    public static MemorySegment wlr_scene_buffer_set_buffer$address() {
        return wlr_scene_buffer_set_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_buffer(struct wlr_scene_buffer *scene_buffer, struct wlr_buffer *buffer)
     * }
     */
    public static void wlr_scene_buffer_set_buffer(MemorySegment scene_buffer, MemorySegment buffer) {
        var mh$ = wlr_scene_buffer_set_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_buffer_set_buffer", scene_buffer, buffer);
            }
            mh$.invokeExact(scene_buffer, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_buffer_set_buffer_with_damage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_buffer_set_buffer_with_damage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_buffer_with_damage(struct wlr_scene_buffer *scene_buffer, struct wlr_buffer *buffer, const pixman_region32_t *region)
     * }
     */
    public static FunctionDescriptor wlr_scene_buffer_set_buffer_with_damage$descriptor() {
        return wlr_scene_buffer_set_buffer_with_damage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_buffer_with_damage(struct wlr_scene_buffer *scene_buffer, struct wlr_buffer *buffer, const pixman_region32_t *region)
     * }
     */
    public static MethodHandle wlr_scene_buffer_set_buffer_with_damage$handle() {
        return wlr_scene_buffer_set_buffer_with_damage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_buffer_with_damage(struct wlr_scene_buffer *scene_buffer, struct wlr_buffer *buffer, const pixman_region32_t *region)
     * }
     */
    public static MemorySegment wlr_scene_buffer_set_buffer_with_damage$address() {
        return wlr_scene_buffer_set_buffer_with_damage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_buffer_with_damage(struct wlr_scene_buffer *scene_buffer, struct wlr_buffer *buffer, const pixman_region32_t *region)
     * }
     */
    public static void wlr_scene_buffer_set_buffer_with_damage(MemorySegment scene_buffer, MemorySegment buffer, MemorySegment region) {
        var mh$ = wlr_scene_buffer_set_buffer_with_damage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_buffer_set_buffer_with_damage", scene_buffer, buffer, region);
            }
            mh$.invokeExact(scene_buffer, buffer, region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_buffer_set_opaque_region {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_buffer_set_opaque_region");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_opaque_region(struct wlr_scene_buffer *scene_buffer, const pixman_region32_t *region)
     * }
     */
    public static FunctionDescriptor wlr_scene_buffer_set_opaque_region$descriptor() {
        return wlr_scene_buffer_set_opaque_region.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_opaque_region(struct wlr_scene_buffer *scene_buffer, const pixman_region32_t *region)
     * }
     */
    public static MethodHandle wlr_scene_buffer_set_opaque_region$handle() {
        return wlr_scene_buffer_set_opaque_region.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_opaque_region(struct wlr_scene_buffer *scene_buffer, const pixman_region32_t *region)
     * }
     */
    public static MemorySegment wlr_scene_buffer_set_opaque_region$address() {
        return wlr_scene_buffer_set_opaque_region.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_opaque_region(struct wlr_scene_buffer *scene_buffer, const pixman_region32_t *region)
     * }
     */
    public static void wlr_scene_buffer_set_opaque_region(MemorySegment scene_buffer, MemorySegment region) {
        var mh$ = wlr_scene_buffer_set_opaque_region.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_buffer_set_opaque_region", scene_buffer, region);
            }
            mh$.invokeExact(scene_buffer, region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_buffer_set_source_box {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_buffer_set_source_box");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_source_box(struct wlr_scene_buffer *scene_buffer, const struct wlr_fbox *box)
     * }
     */
    public static FunctionDescriptor wlr_scene_buffer_set_source_box$descriptor() {
        return wlr_scene_buffer_set_source_box.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_source_box(struct wlr_scene_buffer *scene_buffer, const struct wlr_fbox *box)
     * }
     */
    public static MethodHandle wlr_scene_buffer_set_source_box$handle() {
        return wlr_scene_buffer_set_source_box.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_source_box(struct wlr_scene_buffer *scene_buffer, const struct wlr_fbox *box)
     * }
     */
    public static MemorySegment wlr_scene_buffer_set_source_box$address() {
        return wlr_scene_buffer_set_source_box.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_source_box(struct wlr_scene_buffer *scene_buffer, const struct wlr_fbox *box)
     * }
     */
    public static void wlr_scene_buffer_set_source_box(MemorySegment scene_buffer, MemorySegment box) {
        var mh$ = wlr_scene_buffer_set_source_box.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_buffer_set_source_box", scene_buffer, box);
            }
            mh$.invokeExact(scene_buffer, box);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_buffer_set_dest_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_buffer_set_dest_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_dest_size(struct wlr_scene_buffer *scene_buffer, int width, int height)
     * }
     */
    public static FunctionDescriptor wlr_scene_buffer_set_dest_size$descriptor() {
        return wlr_scene_buffer_set_dest_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_dest_size(struct wlr_scene_buffer *scene_buffer, int width, int height)
     * }
     */
    public static MethodHandle wlr_scene_buffer_set_dest_size$handle() {
        return wlr_scene_buffer_set_dest_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_dest_size(struct wlr_scene_buffer *scene_buffer, int width, int height)
     * }
     */
    public static MemorySegment wlr_scene_buffer_set_dest_size$address() {
        return wlr_scene_buffer_set_dest_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_dest_size(struct wlr_scene_buffer *scene_buffer, int width, int height)
     * }
     */
    public static void wlr_scene_buffer_set_dest_size(MemorySegment scene_buffer, int width, int height) {
        var mh$ = wlr_scene_buffer_set_dest_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_buffer_set_dest_size", scene_buffer, width, height);
            }
            mh$.invokeExact(scene_buffer, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_buffer_set_transform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_buffer_set_transform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_transform(struct wlr_scene_buffer *scene_buffer, enum wl_output_transform transform)
     * }
     */
    public static FunctionDescriptor wlr_scene_buffer_set_transform$descriptor() {
        return wlr_scene_buffer_set_transform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_transform(struct wlr_scene_buffer *scene_buffer, enum wl_output_transform transform)
     * }
     */
    public static MethodHandle wlr_scene_buffer_set_transform$handle() {
        return wlr_scene_buffer_set_transform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_transform(struct wlr_scene_buffer *scene_buffer, enum wl_output_transform transform)
     * }
     */
    public static MemorySegment wlr_scene_buffer_set_transform$address() {
        return wlr_scene_buffer_set_transform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_transform(struct wlr_scene_buffer *scene_buffer, enum wl_output_transform transform)
     * }
     */
    public static void wlr_scene_buffer_set_transform(MemorySegment scene_buffer, int transform) {
        var mh$ = wlr_scene_buffer_set_transform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_buffer_set_transform", scene_buffer, transform);
            }
            mh$.invokeExact(scene_buffer, transform);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_buffer_set_opacity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_buffer_set_opacity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_opacity(struct wlr_scene_buffer *scene_buffer, float opacity)
     * }
     */
    public static FunctionDescriptor wlr_scene_buffer_set_opacity$descriptor() {
        return wlr_scene_buffer_set_opacity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_opacity(struct wlr_scene_buffer *scene_buffer, float opacity)
     * }
     */
    public static MethodHandle wlr_scene_buffer_set_opacity$handle() {
        return wlr_scene_buffer_set_opacity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_opacity(struct wlr_scene_buffer *scene_buffer, float opacity)
     * }
     */
    public static MemorySegment wlr_scene_buffer_set_opacity$address() {
        return wlr_scene_buffer_set_opacity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_opacity(struct wlr_scene_buffer *scene_buffer, float opacity)
     * }
     */
    public static void wlr_scene_buffer_set_opacity(MemorySegment scene_buffer, float opacity) {
        var mh$ = wlr_scene_buffer_set_opacity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_buffer_set_opacity", scene_buffer, opacity);
            }
            mh$.invokeExact(scene_buffer, opacity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_buffer_set_filter_mode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_buffer_set_filter_mode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_filter_mode(struct wlr_scene_buffer *scene_buffer, enum wlr_scale_filter_mode filter_mode)
     * }
     */
    public static FunctionDescriptor wlr_scene_buffer_set_filter_mode$descriptor() {
        return wlr_scene_buffer_set_filter_mode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_filter_mode(struct wlr_scene_buffer *scene_buffer, enum wlr_scale_filter_mode filter_mode)
     * }
     */
    public static MethodHandle wlr_scene_buffer_set_filter_mode$handle() {
        return wlr_scene_buffer_set_filter_mode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_filter_mode(struct wlr_scene_buffer *scene_buffer, enum wlr_scale_filter_mode filter_mode)
     * }
     */
    public static MemorySegment wlr_scene_buffer_set_filter_mode$address() {
        return wlr_scene_buffer_set_filter_mode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_buffer_set_filter_mode(struct wlr_scene_buffer *scene_buffer, enum wlr_scale_filter_mode filter_mode)
     * }
     */
    public static void wlr_scene_buffer_set_filter_mode(MemorySegment scene_buffer, int filter_mode) {
        var mh$ = wlr_scene_buffer_set_filter_mode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_buffer_set_filter_mode", scene_buffer, filter_mode);
            }
            mh$.invokeExact(scene_buffer, filter_mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_buffer_send_frame_done {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_buffer_send_frame_done");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_send_frame_done(struct wlr_scene_buffer *scene_buffer, struct timespec *now)
     * }
     */
    public static FunctionDescriptor wlr_scene_buffer_send_frame_done$descriptor() {
        return wlr_scene_buffer_send_frame_done.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_send_frame_done(struct wlr_scene_buffer *scene_buffer, struct timespec *now)
     * }
     */
    public static MethodHandle wlr_scene_buffer_send_frame_done$handle() {
        return wlr_scene_buffer_send_frame_done.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_buffer_send_frame_done(struct wlr_scene_buffer *scene_buffer, struct timespec *now)
     * }
     */
    public static MemorySegment wlr_scene_buffer_send_frame_done$address() {
        return wlr_scene_buffer_send_frame_done.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_buffer_send_frame_done(struct wlr_scene_buffer *scene_buffer, struct timespec *now)
     * }
     */
    public static void wlr_scene_buffer_send_frame_done(MemorySegment scene_buffer, MemorySegment now) {
        var mh$ = wlr_scene_buffer_send_frame_done.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_buffer_send_frame_done", scene_buffer, now);
            }
            mh$.invokeExact(scene_buffer, now);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_output_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_output_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_scene_output *wlr_scene_output_create(struct wlr_scene *scene, struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_scene_output_create$descriptor() {
        return wlr_scene_output_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_scene_output *wlr_scene_output_create(struct wlr_scene *scene, struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_scene_output_create$handle() {
        return wlr_scene_output_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_scene_output *wlr_scene_output_create(struct wlr_scene *scene, struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_scene_output_create$address() {
        return wlr_scene_output_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_scene_output *wlr_scene_output_create(struct wlr_scene *scene, struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_scene_output_create(MemorySegment scene, MemorySegment output) {
        var mh$ = wlr_scene_output_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_output_create", scene, output);
            }
            return (MemorySegment)mh$.invokeExact(scene, output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_output_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_output_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_output_destroy(struct wlr_scene_output *scene_output)
     * }
     */
    public static FunctionDescriptor wlr_scene_output_destroy$descriptor() {
        return wlr_scene_output_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_output_destroy(struct wlr_scene_output *scene_output)
     * }
     */
    public static MethodHandle wlr_scene_output_destroy$handle() {
        return wlr_scene_output_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_output_destroy(struct wlr_scene_output *scene_output)
     * }
     */
    public static MemorySegment wlr_scene_output_destroy$address() {
        return wlr_scene_output_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_output_destroy(struct wlr_scene_output *scene_output)
     * }
     */
    public static void wlr_scene_output_destroy(MemorySegment scene_output) {
        var mh$ = wlr_scene_output_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_output_destroy", scene_output);
            }
            mh$.invokeExact(scene_output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_output_set_position {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_output_set_position");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_output_set_position(struct wlr_scene_output *scene_output, int lx, int ly)
     * }
     */
    public static FunctionDescriptor wlr_scene_output_set_position$descriptor() {
        return wlr_scene_output_set_position.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_output_set_position(struct wlr_scene_output *scene_output, int lx, int ly)
     * }
     */
    public static MethodHandle wlr_scene_output_set_position$handle() {
        return wlr_scene_output_set_position.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_output_set_position(struct wlr_scene_output *scene_output, int lx, int ly)
     * }
     */
    public static MemorySegment wlr_scene_output_set_position$address() {
        return wlr_scene_output_set_position.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_output_set_position(struct wlr_scene_output *scene_output, int lx, int ly)
     * }
     */
    public static void wlr_scene_output_set_position(MemorySegment scene_output, int lx, int ly) {
        var mh$ = wlr_scene_output_set_position.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_output_set_position", scene_output, lx, ly);
            }
            mh$.invokeExact(scene_output, lx, ly);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_output_commit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_output_commit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_scene_output_commit(struct wlr_scene_output *scene_output, const struct wlr_scene_output_state_options *options)
     * }
     */
    public static FunctionDescriptor wlr_scene_output_commit$descriptor() {
        return wlr_scene_output_commit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_scene_output_commit(struct wlr_scene_output *scene_output, const struct wlr_scene_output_state_options *options)
     * }
     */
    public static MethodHandle wlr_scene_output_commit$handle() {
        return wlr_scene_output_commit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_scene_output_commit(struct wlr_scene_output *scene_output, const struct wlr_scene_output_state_options *options)
     * }
     */
    public static MemorySegment wlr_scene_output_commit$address() {
        return wlr_scene_output_commit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_scene_output_commit(struct wlr_scene_output *scene_output, const struct wlr_scene_output_state_options *options)
     * }
     */
    public static boolean wlr_scene_output_commit(MemorySegment scene_output, MemorySegment options) {
        var mh$ = wlr_scene_output_commit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_output_commit", scene_output, options);
            }
            return (boolean)mh$.invokeExact(scene_output, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_output_build_state {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_output_build_state");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_scene_output_build_state(struct wlr_scene_output *scene_output, struct wlr_output_state *state, const struct wlr_scene_output_state_options *options)
     * }
     */
    public static FunctionDescriptor wlr_scene_output_build_state$descriptor() {
        return wlr_scene_output_build_state.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_scene_output_build_state(struct wlr_scene_output *scene_output, struct wlr_output_state *state, const struct wlr_scene_output_state_options *options)
     * }
     */
    public static MethodHandle wlr_scene_output_build_state$handle() {
        return wlr_scene_output_build_state.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_scene_output_build_state(struct wlr_scene_output *scene_output, struct wlr_output_state *state, const struct wlr_scene_output_state_options *options)
     * }
     */
    public static MemorySegment wlr_scene_output_build_state$address() {
        return wlr_scene_output_build_state.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_scene_output_build_state(struct wlr_scene_output *scene_output, struct wlr_output_state *state, const struct wlr_scene_output_state_options *options)
     * }
     */
    public static boolean wlr_scene_output_build_state(MemorySegment scene_output, MemorySegment state, MemorySegment options) {
        var mh$ = wlr_scene_output_build_state.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_output_build_state", scene_output, state, options);
            }
            return (boolean)mh$.invokeExact(scene_output, state, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_timer_get_duration_ns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_timer_get_duration_ns");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t wlr_scene_timer_get_duration_ns(struct wlr_scene_timer *timer)
     * }
     */
    public static FunctionDescriptor wlr_scene_timer_get_duration_ns$descriptor() {
        return wlr_scene_timer_get_duration_ns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t wlr_scene_timer_get_duration_ns(struct wlr_scene_timer *timer)
     * }
     */
    public static MethodHandle wlr_scene_timer_get_duration_ns$handle() {
        return wlr_scene_timer_get_duration_ns.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t wlr_scene_timer_get_duration_ns(struct wlr_scene_timer *timer)
     * }
     */
    public static MemorySegment wlr_scene_timer_get_duration_ns$address() {
        return wlr_scene_timer_get_duration_ns.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t wlr_scene_timer_get_duration_ns(struct wlr_scene_timer *timer)
     * }
     */
    public static long wlr_scene_timer_get_duration_ns(MemorySegment timer) {
        var mh$ = wlr_scene_timer_get_duration_ns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_timer_get_duration_ns", timer);
            }
            return (long)mh$.invokeExact(timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_timer_finish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_timer_finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_timer_finish(struct wlr_scene_timer *timer)
     * }
     */
    public static FunctionDescriptor wlr_scene_timer_finish$descriptor() {
        return wlr_scene_timer_finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_timer_finish(struct wlr_scene_timer *timer)
     * }
     */
    public static MethodHandle wlr_scene_timer_finish$handle() {
        return wlr_scene_timer_finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_timer_finish(struct wlr_scene_timer *timer)
     * }
     */
    public static MemorySegment wlr_scene_timer_finish$address() {
        return wlr_scene_timer_finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_timer_finish(struct wlr_scene_timer *timer)
     * }
     */
    public static void wlr_scene_timer_finish(MemorySegment timer) {
        var mh$ = wlr_scene_timer_finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_timer_finish", timer);
            }
            mh$.invokeExact(timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_output_send_frame_done {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_output_send_frame_done");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_output_send_frame_done(struct wlr_scene_output *scene_output, struct timespec *now)
     * }
     */
    public static FunctionDescriptor wlr_scene_output_send_frame_done$descriptor() {
        return wlr_scene_output_send_frame_done.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_output_send_frame_done(struct wlr_scene_output *scene_output, struct timespec *now)
     * }
     */
    public static MethodHandle wlr_scene_output_send_frame_done$handle() {
        return wlr_scene_output_send_frame_done.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_output_send_frame_done(struct wlr_scene_output *scene_output, struct timespec *now)
     * }
     */
    public static MemorySegment wlr_scene_output_send_frame_done$address() {
        return wlr_scene_output_send_frame_done.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_output_send_frame_done(struct wlr_scene_output *scene_output, struct timespec *now)
     * }
     */
    public static void wlr_scene_output_send_frame_done(MemorySegment scene_output, MemorySegment now) {
        var mh$ = wlr_scene_output_send_frame_done.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_output_send_frame_done", scene_output, now);
            }
            mh$.invokeExact(scene_output, now);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_output_for_each_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_output_for_each_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_output_for_each_buffer(struct wlr_scene_output *scene_output, wlr_scene_buffer_iterator_func_t iterator, void *user_data)
     * }
     */
    public static FunctionDescriptor wlr_scene_output_for_each_buffer$descriptor() {
        return wlr_scene_output_for_each_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_output_for_each_buffer(struct wlr_scene_output *scene_output, wlr_scene_buffer_iterator_func_t iterator, void *user_data)
     * }
     */
    public static MethodHandle wlr_scene_output_for_each_buffer$handle() {
        return wlr_scene_output_for_each_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_output_for_each_buffer(struct wlr_scene_output *scene_output, wlr_scene_buffer_iterator_func_t iterator, void *user_data)
     * }
     */
    public static MemorySegment wlr_scene_output_for_each_buffer$address() {
        return wlr_scene_output_for_each_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_output_for_each_buffer(struct wlr_scene_output *scene_output, wlr_scene_buffer_iterator_func_t iterator, void *user_data)
     * }
     */
    public static void wlr_scene_output_for_each_buffer(MemorySegment scene_output, MemorySegment iterator, MemorySegment user_data) {
        var mh$ = wlr_scene_output_for_each_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_output_for_each_buffer", scene_output, iterator, user_data);
            }
            mh$.invokeExact(scene_output, iterator, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_get_scene_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_get_scene_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_scene_output *wlr_scene_get_scene_output(struct wlr_scene *scene, struct wlr_output *output)
     * }
     */
    public static FunctionDescriptor wlr_scene_get_scene_output$descriptor() {
        return wlr_scene_get_scene_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_scene_output *wlr_scene_get_scene_output(struct wlr_scene *scene, struct wlr_output *output)
     * }
     */
    public static MethodHandle wlr_scene_get_scene_output$handle() {
        return wlr_scene_get_scene_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_scene_output *wlr_scene_get_scene_output(struct wlr_scene *scene, struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_scene_get_scene_output$address() {
        return wlr_scene_get_scene_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_scene_output *wlr_scene_get_scene_output(struct wlr_scene *scene, struct wlr_output *output)
     * }
     */
    public static MemorySegment wlr_scene_get_scene_output(MemorySegment scene, MemorySegment output) {
        var mh$ = wlr_scene_get_scene_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_get_scene_output", scene, output);
            }
            return (MemorySegment)mh$.invokeExact(scene, output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_attach_output_layout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_attach_output_layout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_scene_output_layout *wlr_scene_attach_output_layout(struct wlr_scene *scene, struct wlr_output_layout *output_layout)
     * }
     */
    public static FunctionDescriptor wlr_scene_attach_output_layout$descriptor() {
        return wlr_scene_attach_output_layout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_scene_output_layout *wlr_scene_attach_output_layout(struct wlr_scene *scene, struct wlr_output_layout *output_layout)
     * }
     */
    public static MethodHandle wlr_scene_attach_output_layout$handle() {
        return wlr_scene_attach_output_layout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_scene_output_layout *wlr_scene_attach_output_layout(struct wlr_scene *scene, struct wlr_output_layout *output_layout)
     * }
     */
    public static MemorySegment wlr_scene_attach_output_layout$address() {
        return wlr_scene_attach_output_layout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_scene_output_layout *wlr_scene_attach_output_layout(struct wlr_scene *scene, struct wlr_output_layout *output_layout)
     * }
     */
    public static MemorySegment wlr_scene_attach_output_layout(MemorySegment scene, MemorySegment output_layout) {
        var mh$ = wlr_scene_attach_output_layout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_attach_output_layout", scene, output_layout);
            }
            return (MemorySegment)mh$.invokeExact(scene, output_layout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_output_layout_add_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_output_layout_add_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_output_layout_add_output(struct wlr_scene_output_layout *sol, struct wlr_output_layout_output *lo, struct wlr_scene_output *so)
     * }
     */
    public static FunctionDescriptor wlr_scene_output_layout_add_output$descriptor() {
        return wlr_scene_output_layout_add_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_output_layout_add_output(struct wlr_scene_output_layout *sol, struct wlr_output_layout_output *lo, struct wlr_scene_output *so)
     * }
     */
    public static MethodHandle wlr_scene_output_layout_add_output$handle() {
        return wlr_scene_output_layout_add_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_output_layout_add_output(struct wlr_scene_output_layout *sol, struct wlr_output_layout_output *lo, struct wlr_scene_output *so)
     * }
     */
    public static MemorySegment wlr_scene_output_layout_add_output$address() {
        return wlr_scene_output_layout_add_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_output_layout_add_output(struct wlr_scene_output_layout *sol, struct wlr_output_layout_output *lo, struct wlr_scene_output *so)
     * }
     */
    public static void wlr_scene_output_layout_add_output(MemorySegment sol, MemorySegment lo, MemorySegment so) {
        var mh$ = wlr_scene_output_layout_add_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_output_layout_add_output", sol, lo, so);
            }
            mh$.invokeExact(sol, lo, so);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_subsurface_tree_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_subsurface_tree_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_scene_tree *wlr_scene_subsurface_tree_create(struct wlr_scene_tree *parent, struct wlr_surface *surface)
     * }
     */
    public static FunctionDescriptor wlr_scene_subsurface_tree_create$descriptor() {
        return wlr_scene_subsurface_tree_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_scene_tree *wlr_scene_subsurface_tree_create(struct wlr_scene_tree *parent, struct wlr_surface *surface)
     * }
     */
    public static MethodHandle wlr_scene_subsurface_tree_create$handle() {
        return wlr_scene_subsurface_tree_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_scene_tree *wlr_scene_subsurface_tree_create(struct wlr_scene_tree *parent, struct wlr_surface *surface)
     * }
     */
    public static MemorySegment wlr_scene_subsurface_tree_create$address() {
        return wlr_scene_subsurface_tree_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_scene_tree *wlr_scene_subsurface_tree_create(struct wlr_scene_tree *parent, struct wlr_surface *surface)
     * }
     */
    public static MemorySegment wlr_scene_subsurface_tree_create(MemorySegment parent, MemorySegment surface) {
        var mh$ = wlr_scene_subsurface_tree_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_subsurface_tree_create", parent, surface);
            }
            return (MemorySegment)mh$.invokeExact(parent, surface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_subsurface_tree_set_clip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_subsurface_tree_set_clip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_subsurface_tree_set_clip(struct wlr_scene_node *node, struct wlr_box *clip)
     * }
     */
    public static FunctionDescriptor wlr_scene_subsurface_tree_set_clip$descriptor() {
        return wlr_scene_subsurface_tree_set_clip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_subsurface_tree_set_clip(struct wlr_scene_node *node, struct wlr_box *clip)
     * }
     */
    public static MethodHandle wlr_scene_subsurface_tree_set_clip$handle() {
        return wlr_scene_subsurface_tree_set_clip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_subsurface_tree_set_clip(struct wlr_scene_node *node, struct wlr_box *clip)
     * }
     */
    public static MemorySegment wlr_scene_subsurface_tree_set_clip$address() {
        return wlr_scene_subsurface_tree_set_clip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_subsurface_tree_set_clip(struct wlr_scene_node *node, struct wlr_box *clip)
     * }
     */
    public static void wlr_scene_subsurface_tree_set_clip(MemorySegment node, MemorySegment clip) {
        var mh$ = wlr_scene_subsurface_tree_set_clip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_subsurface_tree_set_clip", node, clip);
            }
            mh$.invokeExact(node, clip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_xdg_surface_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_xdg_surface_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_scene_tree *wlr_scene_xdg_surface_create(struct wlr_scene_tree *parent, struct wlr_xdg_surface *xdg_surface)
     * }
     */
    public static FunctionDescriptor wlr_scene_xdg_surface_create$descriptor() {
        return wlr_scene_xdg_surface_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_scene_tree *wlr_scene_xdg_surface_create(struct wlr_scene_tree *parent, struct wlr_xdg_surface *xdg_surface)
     * }
     */
    public static MethodHandle wlr_scene_xdg_surface_create$handle() {
        return wlr_scene_xdg_surface_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_scene_tree *wlr_scene_xdg_surface_create(struct wlr_scene_tree *parent, struct wlr_xdg_surface *xdg_surface)
     * }
     */
    public static MemorySegment wlr_scene_xdg_surface_create$address() {
        return wlr_scene_xdg_surface_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_scene_tree *wlr_scene_xdg_surface_create(struct wlr_scene_tree *parent, struct wlr_xdg_surface *xdg_surface)
     * }
     */
    public static MemorySegment wlr_scene_xdg_surface_create(MemorySegment parent, MemorySegment xdg_surface) {
        var mh$ = wlr_scene_xdg_surface_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_xdg_surface_create", parent, xdg_surface);
            }
            return (MemorySegment)mh$.invokeExact(parent, xdg_surface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_layer_surface_v1_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_layer_surface_v1_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_scene_layer_surface_v1 *wlr_scene_layer_surface_v1_create(struct wlr_scene_tree *parent, struct wlr_layer_surface_v1 *layer_surface)
     * }
     */
    public static FunctionDescriptor wlr_scene_layer_surface_v1_create$descriptor() {
        return wlr_scene_layer_surface_v1_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_scene_layer_surface_v1 *wlr_scene_layer_surface_v1_create(struct wlr_scene_tree *parent, struct wlr_layer_surface_v1 *layer_surface)
     * }
     */
    public static MethodHandle wlr_scene_layer_surface_v1_create$handle() {
        return wlr_scene_layer_surface_v1_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_scene_layer_surface_v1 *wlr_scene_layer_surface_v1_create(struct wlr_scene_tree *parent, struct wlr_layer_surface_v1 *layer_surface)
     * }
     */
    public static MemorySegment wlr_scene_layer_surface_v1_create$address() {
        return wlr_scene_layer_surface_v1_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_scene_layer_surface_v1 *wlr_scene_layer_surface_v1_create(struct wlr_scene_tree *parent, struct wlr_layer_surface_v1 *layer_surface)
     * }
     */
    public static MemorySegment wlr_scene_layer_surface_v1_create(MemorySegment parent, MemorySegment layer_surface) {
        var mh$ = wlr_scene_layer_surface_v1_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_layer_surface_v1_create", parent, layer_surface);
            }
            return (MemorySegment)mh$.invokeExact(parent, layer_surface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_layer_surface_v1_configure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_layer_surface_v1_configure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_scene_layer_surface_v1_configure(struct wlr_scene_layer_surface_v1 *scene_layer_surface, const struct wlr_box *full_area, struct wlr_box *usable_area)
     * }
     */
    public static FunctionDescriptor wlr_scene_layer_surface_v1_configure$descriptor() {
        return wlr_scene_layer_surface_v1_configure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_scene_layer_surface_v1_configure(struct wlr_scene_layer_surface_v1 *scene_layer_surface, const struct wlr_box *full_area, struct wlr_box *usable_area)
     * }
     */
    public static MethodHandle wlr_scene_layer_surface_v1_configure$handle() {
        return wlr_scene_layer_surface_v1_configure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_scene_layer_surface_v1_configure(struct wlr_scene_layer_surface_v1 *scene_layer_surface, const struct wlr_box *full_area, struct wlr_box *usable_area)
     * }
     */
    public static MemorySegment wlr_scene_layer_surface_v1_configure$address() {
        return wlr_scene_layer_surface_v1_configure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_scene_layer_surface_v1_configure(struct wlr_scene_layer_surface_v1 *scene_layer_surface, const struct wlr_box *full_area, struct wlr_box *usable_area)
     * }
     */
    public static void wlr_scene_layer_surface_v1_configure(MemorySegment scene_layer_surface, MemorySegment full_area, MemorySegment usable_area) {
        var mh$ = wlr_scene_layer_surface_v1_configure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_layer_surface_v1_configure", scene_layer_surface, full_area, usable_area);
            }
            mh$.invokeExact(scene_layer_surface, full_area, usable_area);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_scene_drag_icon_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_scene_drag_icon_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_scene_tree *wlr_scene_drag_icon_create(struct wlr_scene_tree *parent, struct wlr_drag_icon *drag_icon)
     * }
     */
    public static FunctionDescriptor wlr_scene_drag_icon_create$descriptor() {
        return wlr_scene_drag_icon_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_scene_tree *wlr_scene_drag_icon_create(struct wlr_scene_tree *parent, struct wlr_drag_icon *drag_icon)
     * }
     */
    public static MethodHandle wlr_scene_drag_icon_create$handle() {
        return wlr_scene_drag_icon_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_scene_tree *wlr_scene_drag_icon_create(struct wlr_scene_tree *parent, struct wlr_drag_icon *drag_icon)
     * }
     */
    public static MemorySegment wlr_scene_drag_icon_create$address() {
        return wlr_scene_drag_icon_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_scene_tree *wlr_scene_drag_icon_create(struct wlr_scene_tree *parent, struct wlr_drag_icon *drag_icon)
     * }
     */
    public static MemorySegment wlr_scene_drag_icon_create(MemorySegment parent, MemorySegment drag_icon) {
        var mh$ = wlr_scene_drag_icon_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_scene_drag_icon_create", parent, drag_icon);
            }
            return (MemorySegment)mh$.invokeExact(parent, drag_icon);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_subsurface_try_from_wlr_surface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_subsurface_try_from_wlr_surface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_subsurface *wlr_subsurface_try_from_wlr_surface(struct wlr_surface *surface)
     * }
     */
    public static FunctionDescriptor wlr_subsurface_try_from_wlr_surface$descriptor() {
        return wlr_subsurface_try_from_wlr_surface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_subsurface *wlr_subsurface_try_from_wlr_surface(struct wlr_surface *surface)
     * }
     */
    public static MethodHandle wlr_subsurface_try_from_wlr_surface$handle() {
        return wlr_subsurface_try_from_wlr_surface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_subsurface *wlr_subsurface_try_from_wlr_surface(struct wlr_surface *surface)
     * }
     */
    public static MemorySegment wlr_subsurface_try_from_wlr_surface$address() {
        return wlr_subsurface_try_from_wlr_surface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_subsurface *wlr_subsurface_try_from_wlr_surface(struct wlr_surface *surface)
     * }
     */
    public static MemorySegment wlr_subsurface_try_from_wlr_surface(MemorySegment surface) {
        var mh$ = wlr_subsurface_try_from_wlr_surface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_subsurface_try_from_wlr_surface", surface);
            }
            return (MemorySegment)mh$.invokeExact(surface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_subcompositor_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_subcompositor_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_subcompositor *wlr_subcompositor_create(struct wl_display *display)
     * }
     */
    public static FunctionDescriptor wlr_subcompositor_create$descriptor() {
        return wlr_subcompositor_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_subcompositor *wlr_subcompositor_create(struct wl_display *display)
     * }
     */
    public static MethodHandle wlr_subcompositor_create$handle() {
        return wlr_subcompositor_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_subcompositor *wlr_subcompositor_create(struct wl_display *display)
     * }
     */
    public static MemorySegment wlr_subcompositor_create$address() {
        return wlr_subcompositor_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_subcompositor *wlr_subcompositor_create(struct wl_display *display)
     * }
     */
    public static MemorySegment wlr_subcompositor_create(MemorySegment display) {
        var mh$ = wlr_subcompositor_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_subcompositor_create", display);
            }
            return (MemorySegment)mh$.invokeExact(display);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int WLR_EDGE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wlr_edges.WLR_EDGE_NONE = 0
     * }
     */
    public static int WLR_EDGE_NONE() {
        return WLR_EDGE_NONE;
    }
    private static final int WLR_EDGE_TOP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_edges.WLR_EDGE_TOP = 1
     * }
     */
    public static int WLR_EDGE_TOP() {
        return WLR_EDGE_TOP;
    }
    private static final int WLR_EDGE_BOTTOM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wlr_edges.WLR_EDGE_BOTTOM = 2
     * }
     */
    public static int WLR_EDGE_BOTTOM() {
        return WLR_EDGE_BOTTOM;
    }
    private static final int WLR_EDGE_LEFT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum wlr_edges.WLR_EDGE_LEFT = 4
     * }
     */
    public static int WLR_EDGE_LEFT() {
        return WLR_EDGE_LEFT;
    }
    private static final int WLR_EDGE_RIGHT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum wlr_edges.WLR_EDGE_RIGHT = 8
     * }
     */
    public static int WLR_EDGE_RIGHT() {
        return WLR_EDGE_RIGHT;
    }

    private static class wlr_xcursor_theme_load {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_xcursor_theme_load");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_xcursor_theme *wlr_xcursor_theme_load(const char *name, int size)
     * }
     */
    public static FunctionDescriptor wlr_xcursor_theme_load$descriptor() {
        return wlr_xcursor_theme_load.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_xcursor_theme *wlr_xcursor_theme_load(const char *name, int size)
     * }
     */
    public static MethodHandle wlr_xcursor_theme_load$handle() {
        return wlr_xcursor_theme_load.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_xcursor_theme *wlr_xcursor_theme_load(const char *name, int size)
     * }
     */
    public static MemorySegment wlr_xcursor_theme_load$address() {
        return wlr_xcursor_theme_load.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_xcursor_theme *wlr_xcursor_theme_load(const char *name, int size)
     * }
     */
    public static MemorySegment wlr_xcursor_theme_load(MemorySegment name, int size) {
        var mh$ = wlr_xcursor_theme_load.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_xcursor_theme_load", name, size);
            }
            return (MemorySegment)mh$.invokeExact(name, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_xcursor_theme_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_xcursor_theme_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_xcursor_theme_destroy(struct wlr_xcursor_theme *theme)
     * }
     */
    public static FunctionDescriptor wlr_xcursor_theme_destroy$descriptor() {
        return wlr_xcursor_theme_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_xcursor_theme_destroy(struct wlr_xcursor_theme *theme)
     * }
     */
    public static MethodHandle wlr_xcursor_theme_destroy$handle() {
        return wlr_xcursor_theme_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_xcursor_theme_destroy(struct wlr_xcursor_theme *theme)
     * }
     */
    public static MemorySegment wlr_xcursor_theme_destroy$address() {
        return wlr_xcursor_theme_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_xcursor_theme_destroy(struct wlr_xcursor_theme *theme)
     * }
     */
    public static void wlr_xcursor_theme_destroy(MemorySegment theme) {
        var mh$ = wlr_xcursor_theme_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_xcursor_theme_destroy", theme);
            }
            mh$.invokeExact(theme);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_xcursor_theme_get_cursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_xcursor_theme_get_cursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_xcursor *wlr_xcursor_theme_get_cursor(struct wlr_xcursor_theme *theme, const char *name)
     * }
     */
    public static FunctionDescriptor wlr_xcursor_theme_get_cursor$descriptor() {
        return wlr_xcursor_theme_get_cursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_xcursor *wlr_xcursor_theme_get_cursor(struct wlr_xcursor_theme *theme, const char *name)
     * }
     */
    public static MethodHandle wlr_xcursor_theme_get_cursor$handle() {
        return wlr_xcursor_theme_get_cursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_xcursor *wlr_xcursor_theme_get_cursor(struct wlr_xcursor_theme *theme, const char *name)
     * }
     */
    public static MemorySegment wlr_xcursor_theme_get_cursor$address() {
        return wlr_xcursor_theme_get_cursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_xcursor *wlr_xcursor_theme_get_cursor(struct wlr_xcursor_theme *theme, const char *name)
     * }
     */
    public static MemorySegment wlr_xcursor_theme_get_cursor(MemorySegment theme, MemorySegment name) {
        var mh$ = wlr_xcursor_theme_get_cursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_xcursor_theme_get_cursor", theme, name);
            }
            return (MemorySegment)mh$.invokeExact(theme, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_xcursor_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_xcursor_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wlr_xcursor_frame(struct wlr_xcursor *cursor, uint32_t time)
     * }
     */
    public static FunctionDescriptor wlr_xcursor_frame$descriptor() {
        return wlr_xcursor_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wlr_xcursor_frame(struct wlr_xcursor *cursor, uint32_t time)
     * }
     */
    public static MethodHandle wlr_xcursor_frame$handle() {
        return wlr_xcursor_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wlr_xcursor_frame(struct wlr_xcursor *cursor, uint32_t time)
     * }
     */
    public static MemorySegment wlr_xcursor_frame$address() {
        return wlr_xcursor_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wlr_xcursor_frame(struct wlr_xcursor *cursor, uint32_t time)
     * }
     */
    public static int wlr_xcursor_frame(MemorySegment cursor, int time) {
        var mh$ = wlr_xcursor_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_xcursor_frame", cursor, time);
            }
            return (int)mh$.invokeExact(cursor, time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_xcursor_get_resize_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_xcursor_get_resize_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *wlr_xcursor_get_resize_name(enum wlr_edges edges)
     * }
     */
    public static FunctionDescriptor wlr_xcursor_get_resize_name$descriptor() {
        return wlr_xcursor_get_resize_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *wlr_xcursor_get_resize_name(enum wlr_edges edges)
     * }
     */
    public static MethodHandle wlr_xcursor_get_resize_name$handle() {
        return wlr_xcursor_get_resize_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *wlr_xcursor_get_resize_name(enum wlr_edges edges)
     * }
     */
    public static MemorySegment wlr_xcursor_get_resize_name$address() {
        return wlr_xcursor_get_resize_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *wlr_xcursor_get_resize_name(enum wlr_edges edges)
     * }
     */
    public static MemorySegment wlr_xcursor_get_resize_name(int edges) {
        var mh$ = wlr_xcursor_get_resize_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_xcursor_get_resize_name", edges);
            }
            return (MemorySegment)mh$.invokeExact(edges);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_xcursor_manager_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_xcursor_manager_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_xcursor_manager *wlr_xcursor_manager_create(const char *name, uint32_t size)
     * }
     */
    public static FunctionDescriptor wlr_xcursor_manager_create$descriptor() {
        return wlr_xcursor_manager_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_xcursor_manager *wlr_xcursor_manager_create(const char *name, uint32_t size)
     * }
     */
    public static MethodHandle wlr_xcursor_manager_create$handle() {
        return wlr_xcursor_manager_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_xcursor_manager *wlr_xcursor_manager_create(const char *name, uint32_t size)
     * }
     */
    public static MemorySegment wlr_xcursor_manager_create$address() {
        return wlr_xcursor_manager_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_xcursor_manager *wlr_xcursor_manager_create(const char *name, uint32_t size)
     * }
     */
    public static MemorySegment wlr_xcursor_manager_create(MemorySegment name, int size) {
        var mh$ = wlr_xcursor_manager_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_xcursor_manager_create", name, size);
            }
            return (MemorySegment)mh$.invokeExact(name, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_xcursor_manager_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_xcursor_manager_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wlr_xcursor_manager_destroy(struct wlr_xcursor_manager *manager)
     * }
     */
    public static FunctionDescriptor wlr_xcursor_manager_destroy$descriptor() {
        return wlr_xcursor_manager_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wlr_xcursor_manager_destroy(struct wlr_xcursor_manager *manager)
     * }
     */
    public static MethodHandle wlr_xcursor_manager_destroy$handle() {
        return wlr_xcursor_manager_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wlr_xcursor_manager_destroy(struct wlr_xcursor_manager *manager)
     * }
     */
    public static MemorySegment wlr_xcursor_manager_destroy$address() {
        return wlr_xcursor_manager_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wlr_xcursor_manager_destroy(struct wlr_xcursor_manager *manager)
     * }
     */
    public static void wlr_xcursor_manager_destroy(MemorySegment manager) {
        var mh$ = wlr_xcursor_manager_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_xcursor_manager_destroy", manager);
            }
            mh$.invokeExact(manager);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_xcursor_manager_load {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_BOOL,
            C.C_POINTER,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_xcursor_manager_load");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool wlr_xcursor_manager_load(struct wlr_xcursor_manager *manager, float scale)
     * }
     */
    public static FunctionDescriptor wlr_xcursor_manager_load$descriptor() {
        return wlr_xcursor_manager_load.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool wlr_xcursor_manager_load(struct wlr_xcursor_manager *manager, float scale)
     * }
     */
    public static MethodHandle wlr_xcursor_manager_load$handle() {
        return wlr_xcursor_manager_load.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool wlr_xcursor_manager_load(struct wlr_xcursor_manager *manager, float scale)
     * }
     */
    public static MemorySegment wlr_xcursor_manager_load$address() {
        return wlr_xcursor_manager_load.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool wlr_xcursor_manager_load(struct wlr_xcursor_manager *manager, float scale)
     * }
     */
    public static boolean wlr_xcursor_manager_load(MemorySegment manager, float scale) {
        var mh$ = wlr_xcursor_manager_load.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_xcursor_manager_load", manager, scale);
            }
            return (boolean)mh$.invokeExact(manager, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_xcursor_manager_get_xcursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_xcursor_manager_get_xcursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_xcursor *wlr_xcursor_manager_get_xcursor(struct wlr_xcursor_manager *manager, const char *name, float scale)
     * }
     */
    public static FunctionDescriptor wlr_xcursor_manager_get_xcursor$descriptor() {
        return wlr_xcursor_manager_get_xcursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_xcursor *wlr_xcursor_manager_get_xcursor(struct wlr_xcursor_manager *manager, const char *name, float scale)
     * }
     */
    public static MethodHandle wlr_xcursor_manager_get_xcursor$handle() {
        return wlr_xcursor_manager_get_xcursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_xcursor *wlr_xcursor_manager_get_xcursor(struct wlr_xcursor_manager *manager, const char *name, float scale)
     * }
     */
    public static MemorySegment wlr_xcursor_manager_get_xcursor$address() {
        return wlr_xcursor_manager_get_xcursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_xcursor *wlr_xcursor_manager_get_xcursor(struct wlr_xcursor_manager *manager, const char *name, float scale)
     * }
     */
    public static MemorySegment wlr_xcursor_manager_get_xcursor(MemorySegment manager, MemorySegment name, float scale) {
        var mh$ = wlr_xcursor_manager_get_xcursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_xcursor_manager_get_xcursor", manager, name, scale);
            }
            return (MemorySegment)mh$.invokeExact(manager, name, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int WLR_XDG_POPUP_CONFIGURE_REPOSITION_TOKEN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_xdg_popup_configure_field.WLR_XDG_POPUP_CONFIGURE_REPOSITION_TOKEN = 1
     * }
     */
    public static int WLR_XDG_POPUP_CONFIGURE_REPOSITION_TOKEN() {
        return WLR_XDG_POPUP_CONFIGURE_REPOSITION_TOKEN;
    }
    private static final int WLR_XDG_SURFACE_ROLE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wlr_xdg_surface_role.WLR_XDG_SURFACE_ROLE_NONE = 0
     * }
     */
    public static int WLR_XDG_SURFACE_ROLE_NONE() {
        return WLR_XDG_SURFACE_ROLE_NONE;
    }
    private static final int WLR_XDG_SURFACE_ROLE_TOPLEVEL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_xdg_surface_role.WLR_XDG_SURFACE_ROLE_TOPLEVEL = 1
     * }
     */
    public static int WLR_XDG_SURFACE_ROLE_TOPLEVEL() {
        return WLR_XDG_SURFACE_ROLE_TOPLEVEL;
    }
    private static final int WLR_XDG_SURFACE_ROLE_POPUP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wlr_xdg_surface_role.WLR_XDG_SURFACE_ROLE_POPUP = 2
     * }
     */
    public static int WLR_XDG_SURFACE_ROLE_POPUP() {
        return WLR_XDG_SURFACE_ROLE_POPUP;
    }
    private static final int WLR_XDG_TOPLEVEL_WM_CAPABILITIES_WINDOW_MENU = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_xdg_toplevel_wm_capabilities.WLR_XDG_TOPLEVEL_WM_CAPABILITIES_WINDOW_MENU = 1
     * }
     */
    public static int WLR_XDG_TOPLEVEL_WM_CAPABILITIES_WINDOW_MENU() {
        return WLR_XDG_TOPLEVEL_WM_CAPABILITIES_WINDOW_MENU;
    }
    private static final int WLR_XDG_TOPLEVEL_WM_CAPABILITIES_MAXIMIZE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wlr_xdg_toplevel_wm_capabilities.WLR_XDG_TOPLEVEL_WM_CAPABILITIES_MAXIMIZE = 2
     * }
     */
    public static int WLR_XDG_TOPLEVEL_WM_CAPABILITIES_MAXIMIZE() {
        return WLR_XDG_TOPLEVEL_WM_CAPABILITIES_MAXIMIZE;
    }
    private static final int WLR_XDG_TOPLEVEL_WM_CAPABILITIES_FULLSCREEN = (int)4L;
    /**
     * {@snippet lang=c :
     * enum wlr_xdg_toplevel_wm_capabilities.WLR_XDG_TOPLEVEL_WM_CAPABILITIES_FULLSCREEN = 4
     * }
     */
    public static int WLR_XDG_TOPLEVEL_WM_CAPABILITIES_FULLSCREEN() {
        return WLR_XDG_TOPLEVEL_WM_CAPABILITIES_FULLSCREEN;
    }
    private static final int WLR_XDG_TOPLEVEL_WM_CAPABILITIES_MINIMIZE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum wlr_xdg_toplevel_wm_capabilities.WLR_XDG_TOPLEVEL_WM_CAPABILITIES_MINIMIZE = 8
     * }
     */
    public static int WLR_XDG_TOPLEVEL_WM_CAPABILITIES_MINIMIZE() {
        return WLR_XDG_TOPLEVEL_WM_CAPABILITIES_MINIMIZE;
    }
    private static final int WLR_XDG_TOPLEVEL_CONFIGURE_BOUNDS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wlr_xdg_toplevel_configure_field.WLR_XDG_TOPLEVEL_CONFIGURE_BOUNDS = 1
     * }
     */
    public static int WLR_XDG_TOPLEVEL_CONFIGURE_BOUNDS() {
        return WLR_XDG_TOPLEVEL_CONFIGURE_BOUNDS;
    }
    private static final int WLR_XDG_TOPLEVEL_CONFIGURE_WM_CAPABILITIES = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wlr_xdg_toplevel_configure_field.WLR_XDG_TOPLEVEL_CONFIGURE_WM_CAPABILITIES = 2
     * }
     */
    public static int WLR_XDG_TOPLEVEL_CONFIGURE_WM_CAPABILITIES() {
        return WLR_XDG_TOPLEVEL_CONFIGURE_WM_CAPABILITIES;
    }

    private static class wlr_xdg_shell_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_xdg_shell_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_xdg_shell *wlr_xdg_shell_create(struct wl_display *display, uint32_t version)
     * }
     */
    public static FunctionDescriptor wlr_xdg_shell_create$descriptor() {
        return wlr_xdg_shell_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_xdg_shell *wlr_xdg_shell_create(struct wl_display *display, uint32_t version)
     * }
     */
    public static MethodHandle wlr_xdg_shell_create$handle() {
        return wlr_xdg_shell_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_xdg_shell *wlr_xdg_shell_create(struct wl_display *display, uint32_t version)
     * }
     */
    public static MemorySegment wlr_xdg_shell_create$address() {
        return wlr_xdg_shell_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_xdg_shell *wlr_xdg_shell_create(struct wl_display *display, uint32_t version)
     * }
     */
    public static MemorySegment wlr_xdg_shell_create(MemorySegment display, int version) {
        var mh$ = wlr_xdg_shell_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_xdg_shell_create", display, version);
            }
            return (MemorySegment)mh$.invokeExact(display, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_xdg_surface_from_resource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_xdg_surface_from_resource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_xdg_surface *wlr_xdg_surface_from_resource(struct wl_resource *resource)
     * }
     */
    public static FunctionDescriptor wlr_xdg_surface_from_resource$descriptor() {
        return wlr_xdg_surface_from_resource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_xdg_surface *wlr_xdg_surface_from_resource(struct wl_resource *resource)
     * }
     */
    public static MethodHandle wlr_xdg_surface_from_resource$handle() {
        return wlr_xdg_surface_from_resource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_xdg_surface *wlr_xdg_surface_from_resource(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wlr_xdg_surface_from_resource$address() {
        return wlr_xdg_surface_from_resource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_xdg_surface *wlr_xdg_surface_from_resource(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wlr_xdg_surface_from_resource(MemorySegment resource) {
        var mh$ = wlr_xdg_surface_from_resource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_xdg_surface_from_resource", resource);
            }
            return (MemorySegment)mh$.invokeExact(resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_xdg_popup_from_resource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_xdg_popup_from_resource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_xdg_popup *wlr_xdg_popup_from_resource(struct wl_resource *resource)
     * }
     */
    public static FunctionDescriptor wlr_xdg_popup_from_resource$descriptor() {
        return wlr_xdg_popup_from_resource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_xdg_popup *wlr_xdg_popup_from_resource(struct wl_resource *resource)
     * }
     */
    public static MethodHandle wlr_xdg_popup_from_resource$handle() {
        return wlr_xdg_popup_from_resource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_xdg_popup *wlr_xdg_popup_from_resource(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wlr_xdg_popup_from_resource$address() {
        return wlr_xdg_popup_from_resource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_xdg_popup *wlr_xdg_popup_from_resource(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wlr_xdg_popup_from_resource(MemorySegment resource) {
        var mh$ = wlr_xdg_popup_from_resource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_xdg_popup_from_resource", resource);
            }
            return (MemorySegment)mh$.invokeExact(resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_xdg_toplevel_from_resource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_xdg_toplevel_from_resource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_xdg_toplevel *wlr_xdg_toplevel_from_resource(struct wl_resource *resource)
     * }
     */
    public static FunctionDescriptor wlr_xdg_toplevel_from_resource$descriptor() {
        return wlr_xdg_toplevel_from_resource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_xdg_toplevel *wlr_xdg_toplevel_from_resource(struct wl_resource *resource)
     * }
     */
    public static MethodHandle wlr_xdg_toplevel_from_resource$handle() {
        return wlr_xdg_toplevel_from_resource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_xdg_toplevel *wlr_xdg_toplevel_from_resource(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wlr_xdg_toplevel_from_resource$address() {
        return wlr_xdg_toplevel_from_resource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_xdg_toplevel *wlr_xdg_toplevel_from_resource(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wlr_xdg_toplevel_from_resource(MemorySegment resource) {
        var mh$ = wlr_xdg_toplevel_from_resource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_xdg_toplevel_from_resource", resource);
            }
            return (MemorySegment)mh$.invokeExact(resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wlr_xdg_positioner_from_resource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wlr_xdg_positioner_from_resource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wlr_xdg_positioner *wlr_xdg_positioner_from_resource(struct wl_resource *resource)
     * }
     */
    public static FunctionDescriptor wlr_xdg_positioner_from_resource$descriptor() {
        return wlr_xdg_positioner_from_resource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wlr_xdg_positioner *wlr_xdg_positioner_from_resource(struct wl_resource *resource)
     * }
     */
    public static MethodHandle wlr_xdg_positioner_from_resource$handle() {
        return wlr_xdg_positioner_from_resource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wlr_xdg_positioner *wlr_xdg_positioner_from_resource(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wlr_xdg_positioner_from_resource$address() {
        return wlr_xdg_positioner_from_resource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wlr_xdg_positioner *wlr_xdg_positioner_from_resource(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wlr_xdg_positioner_from_resource(MemorySegment resource) {
        var mh$ = wlr_xdg_positioner_from_resource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wlr_xdg_positioner_from_resource", resource);
            }
            return (MemorySegment)mh$.invokeExact(resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

