// Generated by jextract

package dev.jt.tinywl_clj.gen;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class C_2 extends C_3 {

    C_2() {
        // Should not be called directly
    }
    private static final int XKB_KEY_mute_diaeresis = (int)268435627L;
    /**
     * {@snippet lang=c :
     * #define XKB_KEY_mute_diaeresis 268435627
     * }
     */
    public static int XKB_KEY_mute_diaeresis() {
        return XKB_KEY_mute_diaeresis;
    }
    private static final int XKB_KEY_mute_asciitilde = (int)268435628L;
    /**
     * {@snippet lang=c :
     * #define XKB_KEY_mute_asciitilde 268435628
     * }
     */
    public static int XKB_KEY_mute_asciitilde() {
        return XKB_KEY_mute_asciitilde;
    }
    private static final int XKB_KEY_lira = (int)268435631L;
    /**
     * {@snippet lang=c :
     * #define XKB_KEY_lira 268435631
     * }
     */
    public static int XKB_KEY_lira() {
        return XKB_KEY_lira;
    }
    private static final int XKB_KEY_guilder = (int)268435646L;
    /**
     * {@snippet lang=c :
     * #define XKB_KEY_guilder 268435646
     * }
     */
    public static int XKB_KEY_guilder() {
        return XKB_KEY_guilder;
    }
    private static final int XKB_KEY_IO = (int)268435694L;
    /**
     * {@snippet lang=c :
     * #define XKB_KEY_IO 268435694
     * }
     */
    public static int XKB_KEY_IO() {
        return XKB_KEY_IO;
    }
    private static final int XKB_KEY_longminus = (int)268435702L;
    /**
     * {@snippet lang=c :
     * #define XKB_KEY_longminus 268435702
     * }
     */
    public static int XKB_KEY_longminus() {
        return XKB_KEY_longminus;
    }
    private static final int XKB_KEY_block = (int)268435708L;
    /**
     * {@snippet lang=c :
     * #define XKB_KEY_block 268435708
     * }
     */
    public static int XKB_KEY_block() {
        return XKB_KEY_block;
    }
    private static final int XKB_KEYSYM_MAX = (int)536870911L;
    /**
     * {@snippet lang=c :
     * #define XKB_KEYSYM_MAX 536870911
     * }
     */
    public static int XKB_KEYSYM_MAX() {
        return XKB_KEYSYM_MAX;
    }
    private static final int WLR_LED_COUNT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define WLR_LED_COUNT 3
     * }
     */
    public static int WLR_LED_COUNT() {
        return WLR_LED_COUNT;
    }
    private static final int WLR_MODIFIER_COUNT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define WLR_MODIFIER_COUNT 8
     * }
     */
    public static int WLR_MODIFIER_COUNT() {
        return WLR_MODIFIER_COUNT;
    }
    private static final int WLR_KEYBOARD_KEYS_CAP = (int)32L;
    /**
     * {@snippet lang=c :
     * #define WLR_KEYBOARD_KEYS_CAP 32
     * }
     */
    public static int WLR_KEYBOARD_KEYS_CAP() {
        return WLR_KEYBOARD_KEYS_CAP;
    }
    private static final int WLR_POINTER_AXIS_DISCRETE_STEP = (int)120L;
    /**
     * {@snippet lang=c :
     * #define WLR_POINTER_AXIS_DISCRETE_STEP 120
     * }
     */
    public static int WLR_POINTER_AXIS_DISCRETE_STEP() {
        return WLR_POINTER_AXIS_DISCRETE_STEP;
    }
    private static final int WLR_SERIAL_RINGSET_SIZE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define WLR_SERIAL_RINGSET_SIZE 128
     * }
     */
    public static int WLR_SERIAL_RINGSET_SIZE() {
        return WLR_SERIAL_RINGSET_SIZE;
    }
    private static final int WLR_POINTER_BUTTONS_CAP = (int)16L;
    /**
     * {@snippet lang=c :
     * #define WLR_POINTER_BUTTONS_CAP 16
     * }
     */
    public static int WLR_POINTER_BUTTONS_CAP() {
        return WLR_POINTER_BUTTONS_CAP;
    }
    private static final int WLR_DAMAGE_RING_PREVIOUS_LEN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WLR_DAMAGE_RING_PREVIOUS_LEN 2
     * }
     */
    public static int WLR_DAMAGE_RING_PREVIOUS_LEN() {
        return WLR_DAMAGE_RING_PREVIOUS_LEN;
    }
    private static final int _SYS_STAT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_STAT_H 1
     * }
     */
    public static int _SYS_STAT_H() {
        return _SYS_STAT_H;
    }
    private static final int _BITS_STAT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STAT_H 1
     * }
     */
    public static int _BITS_STAT_H() {
        return _BITS_STAT_H;
    }
    private static final int _BITS_STRUCT_STAT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STRUCT_STAT_H 1
     * }
     */
    public static int _BITS_STRUCT_STAT_H() {
        return _BITS_STRUCT_STAT_H;
    }
    private static final int __S_IFMT = (int)61440L;
    /**
     * {@snippet lang=c :
     * #define __S_IFMT 61440
     * }
     */
    public static int __S_IFMT() {
        return __S_IFMT;
    }
    private static final int __S_IFDIR = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define __S_IFDIR 16384
     * }
     */
    public static int __S_IFDIR() {
        return __S_IFDIR;
    }
    private static final int __S_IFCHR = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define __S_IFCHR 8192
     * }
     */
    public static int __S_IFCHR() {
        return __S_IFCHR;
    }
    private static final int __S_IFBLK = (int)24576L;
    /**
     * {@snippet lang=c :
     * #define __S_IFBLK 24576
     * }
     */
    public static int __S_IFBLK() {
        return __S_IFBLK;
    }
    private static final int __S_IFREG = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define __S_IFREG 32768
     * }
     */
    public static int __S_IFREG() {
        return __S_IFREG;
    }
    private static final int __S_IFIFO = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define __S_IFIFO 4096
     * }
     */
    public static int __S_IFIFO() {
        return __S_IFIFO;
    }
    private static final int __S_IFLNK = (int)40960L;
    /**
     * {@snippet lang=c :
     * #define __S_IFLNK 40960
     * }
     */
    public static int __S_IFLNK() {
        return __S_IFLNK;
    }
    private static final int __S_IFSOCK = (int)49152L;
    /**
     * {@snippet lang=c :
     * #define __S_IFSOCK 49152
     * }
     */
    public static int __S_IFSOCK() {
        return __S_IFSOCK;
    }
    private static final int __S_ISUID = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define __S_ISUID 2048
     * }
     */
    public static int __S_ISUID() {
        return __S_ISUID;
    }
    private static final int __S_ISGID = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __S_ISGID 1024
     * }
     */
    public static int __S_ISGID() {
        return __S_ISGID;
    }
    private static final int __S_ISVTX = (int)512L;
    /**
     * {@snippet lang=c :
     * #define __S_ISVTX 512
     * }
     */
    public static int __S_ISVTX() {
        return __S_ISVTX;
    }
    private static final int __S_IREAD = (int)256L;
    /**
     * {@snippet lang=c :
     * #define __S_IREAD 256
     * }
     */
    public static int __S_IREAD() {
        return __S_IREAD;
    }
    private static final int __S_IWRITE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define __S_IWRITE 128
     * }
     */
    public static int __S_IWRITE() {
        return __S_IWRITE;
    }
    private static final int __S_IEXEC = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __S_IEXEC 64
     * }
     */
    public static int __S_IEXEC() {
        return __S_IEXEC;
    }
    private static final int S_BLKSIZE = (int)512L;
    /**
     * {@snippet lang=c :
     * #define S_BLKSIZE 512
     * }
     */
    public static int S_BLKSIZE() {
        return S_BLKSIZE;
    }
    private static final int _STRING_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRING_H 1
     * }
     */
    public static int _STRING_H() {
        return _STRING_H;
    }
    private static final int _STRINGS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRINGS_H 1
     * }
     */
    public static int _STRINGS_H() {
        return _STRINGS_H;
    }
    private static final int _ERRNO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ERRNO_H 1
     * }
     */
    public static int _ERRNO_H() {
        return _ERRNO_H;
    }
    private static final int _BITS_ERRNO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ERRNO_H 1
     * }
     */
    public static int _BITS_ERRNO_H() {
        return _BITS_ERRNO_H;
    }
    private static final int EPERM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EPERM 1
     * }
     */
    public static int EPERM() {
        return EPERM;
    }
    private static final int ENOENT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ENOENT 2
     * }
     */
    public static int ENOENT() {
        return ENOENT;
    }
    private static final int ESRCH = (int)3L;
    /**
     * {@snippet lang=c :
     * #define ESRCH 3
     * }
     */
    public static int ESRCH() {
        return ESRCH;
    }
    private static final int EINTR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EINTR 4
     * }
     */
    public static int EINTR() {
        return EINTR;
    }
    private static final int EIO = (int)5L;
    /**
     * {@snippet lang=c :
     * #define EIO 5
     * }
     */
    public static int EIO() {
        return EIO;
    }
    private static final int ENXIO = (int)6L;
    /**
     * {@snippet lang=c :
     * #define ENXIO 6
     * }
     */
    public static int ENXIO() {
        return ENXIO;
    }
    private static final int E2BIG = (int)7L;
    /**
     * {@snippet lang=c :
     * #define E2BIG 7
     * }
     */
    public static int E2BIG() {
        return E2BIG;
    }
    private static final int ENOEXEC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ENOEXEC 8
     * }
     */
    public static int ENOEXEC() {
        return ENOEXEC;
    }
    private static final int EBADF = (int)9L;
    /**
     * {@snippet lang=c :
     * #define EBADF 9
     * }
     */
    public static int EBADF() {
        return EBADF;
    }
    private static final int ECHILD = (int)10L;
    /**
     * {@snippet lang=c :
     * #define ECHILD 10
     * }
     */
    public static int ECHILD() {
        return ECHILD;
    }
    private static final int EAGAIN = (int)11L;
    /**
     * {@snippet lang=c :
     * #define EAGAIN 11
     * }
     */
    public static int EAGAIN() {
        return EAGAIN;
    }
    private static final int ENOMEM = (int)12L;
    /**
     * {@snippet lang=c :
     * #define ENOMEM 12
     * }
     */
    public static int ENOMEM() {
        return ENOMEM;
    }
    private static final int EACCES = (int)13L;
    /**
     * {@snippet lang=c :
     * #define EACCES 13
     * }
     */
    public static int EACCES() {
        return EACCES;
    }
    private static final int EFAULT = (int)14L;
    /**
     * {@snippet lang=c :
     * #define EFAULT 14
     * }
     */
    public static int EFAULT() {
        return EFAULT;
    }
    private static final int ENOTBLK = (int)15L;
    /**
     * {@snippet lang=c :
     * #define ENOTBLK 15
     * }
     */
    public static int ENOTBLK() {
        return ENOTBLK;
    }
    private static final int EBUSY = (int)16L;
    /**
     * {@snippet lang=c :
     * #define EBUSY 16
     * }
     */
    public static int EBUSY() {
        return EBUSY;
    }
    private static final int EEXIST = (int)17L;
    /**
     * {@snippet lang=c :
     * #define EEXIST 17
     * }
     */
    public static int EEXIST() {
        return EEXIST;
    }
    private static final int EXDEV = (int)18L;
    /**
     * {@snippet lang=c :
     * #define EXDEV 18
     * }
     */
    public static int EXDEV() {
        return EXDEV;
    }
    private static final int ENODEV = (int)19L;
    /**
     * {@snippet lang=c :
     * #define ENODEV 19
     * }
     */
    public static int ENODEV() {
        return ENODEV;
    }
    private static final int ENOTDIR = (int)20L;
    /**
     * {@snippet lang=c :
     * #define ENOTDIR 20
     * }
     */
    public static int ENOTDIR() {
        return ENOTDIR;
    }
    private static final int EISDIR = (int)21L;
    /**
     * {@snippet lang=c :
     * #define EISDIR 21
     * }
     */
    public static int EISDIR() {
        return EISDIR;
    }
    private static final int EINVAL = (int)22L;
    /**
     * {@snippet lang=c :
     * #define EINVAL 22
     * }
     */
    public static int EINVAL() {
        return EINVAL;
    }
    private static final int ENFILE = (int)23L;
    /**
     * {@snippet lang=c :
     * #define ENFILE 23
     * }
     */
    public static int ENFILE() {
        return ENFILE;
    }
    private static final int EMFILE = (int)24L;
    /**
     * {@snippet lang=c :
     * #define EMFILE 24
     * }
     */
    public static int EMFILE() {
        return EMFILE;
    }
    private static final int ENOTTY = (int)25L;
    /**
     * {@snippet lang=c :
     * #define ENOTTY 25
     * }
     */
    public static int ENOTTY() {
        return ENOTTY;
    }
    private static final int ETXTBSY = (int)26L;
    /**
     * {@snippet lang=c :
     * #define ETXTBSY 26
     * }
     */
    public static int ETXTBSY() {
        return ETXTBSY;
    }
    private static final int EFBIG = (int)27L;
    /**
     * {@snippet lang=c :
     * #define EFBIG 27
     * }
     */
    public static int EFBIG() {
        return EFBIG;
    }
    private static final int ENOSPC = (int)28L;
    /**
     * {@snippet lang=c :
     * #define ENOSPC 28
     * }
     */
    public static int ENOSPC() {
        return ENOSPC;
    }
    private static final int ESPIPE = (int)29L;
    /**
     * {@snippet lang=c :
     * #define ESPIPE 29
     * }
     */
    public static int ESPIPE() {
        return ESPIPE;
    }
    private static final int EROFS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define EROFS 30
     * }
     */
    public static int EROFS() {
        return EROFS;
    }
    private static final int EMLINK = (int)31L;
    /**
     * {@snippet lang=c :
     * #define EMLINK 31
     * }
     */
    public static int EMLINK() {
        return EMLINK;
    }
    private static final int EPIPE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EPIPE 32
     * }
     */
    public static int EPIPE() {
        return EPIPE;
    }
    private static final int EDOM = (int)33L;
    /**
     * {@snippet lang=c :
     * #define EDOM 33
     * }
     */
    public static int EDOM() {
        return EDOM;
    }
    private static final int ERANGE = (int)34L;
    /**
     * {@snippet lang=c :
     * #define ERANGE 34
     * }
     */
    public static int ERANGE() {
        return ERANGE;
    }
    private static final int EDEADLK = (int)35L;
    /**
     * {@snippet lang=c :
     * #define EDEADLK 35
     * }
     */
    public static int EDEADLK() {
        return EDEADLK;
    }
    private static final int ENAMETOOLONG = (int)36L;
    /**
     * {@snippet lang=c :
     * #define ENAMETOOLONG 36
     * }
     */
    public static int ENAMETOOLONG() {
        return ENAMETOOLONG;
    }
    private static final int ENOLCK = (int)37L;
    /**
     * {@snippet lang=c :
     * #define ENOLCK 37
     * }
     */
    public static int ENOLCK() {
        return ENOLCK;
    }
    private static final int ENOSYS = (int)38L;
    /**
     * {@snippet lang=c :
     * #define ENOSYS 38
     * }
     */
    public static int ENOSYS() {
        return ENOSYS;
    }
    private static final int ENOTEMPTY = (int)39L;
    /**
     * {@snippet lang=c :
     * #define ENOTEMPTY 39
     * }
     */
    public static int ENOTEMPTY() {
        return ENOTEMPTY;
    }
    private static final int ELOOP = (int)40L;
    /**
     * {@snippet lang=c :
     * #define ELOOP 40
     * }
     */
    public static int ELOOP() {
        return ELOOP;
    }
    private static final int ENOMSG = (int)42L;
    /**
     * {@snippet lang=c :
     * #define ENOMSG 42
     * }
     */
    public static int ENOMSG() {
        return ENOMSG;
    }
    private static final int EIDRM = (int)43L;
    /**
     * {@snippet lang=c :
     * #define EIDRM 43
     * }
     */
    public static int EIDRM() {
        return EIDRM;
    }
    private static final int ECHRNG = (int)44L;
    /**
     * {@snippet lang=c :
     * #define ECHRNG 44
     * }
     */
    public static int ECHRNG() {
        return ECHRNG;
    }
    private static final int EL2NSYNC = (int)45L;
    /**
     * {@snippet lang=c :
     * #define EL2NSYNC 45
     * }
     */
    public static int EL2NSYNC() {
        return EL2NSYNC;
    }
    private static final int EL3HLT = (int)46L;
    /**
     * {@snippet lang=c :
     * #define EL3HLT 46
     * }
     */
    public static int EL3HLT() {
        return EL3HLT;
    }
    private static final int EL3RST = (int)47L;
    /**
     * {@snippet lang=c :
     * #define EL3RST 47
     * }
     */
    public static int EL3RST() {
        return EL3RST;
    }
    private static final int ELNRNG = (int)48L;
    /**
     * {@snippet lang=c :
     * #define ELNRNG 48
     * }
     */
    public static int ELNRNG() {
        return ELNRNG;
    }
    private static final int EUNATCH = (int)49L;
    /**
     * {@snippet lang=c :
     * #define EUNATCH 49
     * }
     */
    public static int EUNATCH() {
        return EUNATCH;
    }
    private static final int ENOCSI = (int)50L;
    /**
     * {@snippet lang=c :
     * #define ENOCSI 50
     * }
     */
    public static int ENOCSI() {
        return ENOCSI;
    }
    private static final int EL2HLT = (int)51L;
    /**
     * {@snippet lang=c :
     * #define EL2HLT 51
     * }
     */
    public static int EL2HLT() {
        return EL2HLT;
    }
    private static final int EBADE = (int)52L;
    /**
     * {@snippet lang=c :
     * #define EBADE 52
     * }
     */
    public static int EBADE() {
        return EBADE;
    }
    private static final int EBADR = (int)53L;
    /**
     * {@snippet lang=c :
     * #define EBADR 53
     * }
     */
    public static int EBADR() {
        return EBADR;
    }
    private static final int EXFULL = (int)54L;
    /**
     * {@snippet lang=c :
     * #define EXFULL 54
     * }
     */
    public static int EXFULL() {
        return EXFULL;
    }
    private static final int ENOANO = (int)55L;
    /**
     * {@snippet lang=c :
     * #define ENOANO 55
     * }
     */
    public static int ENOANO() {
        return ENOANO;
    }
    private static final int EBADRQC = (int)56L;
    /**
     * {@snippet lang=c :
     * #define EBADRQC 56
     * }
     */
    public static int EBADRQC() {
        return EBADRQC;
    }
    private static final int EBADSLT = (int)57L;
    /**
     * {@snippet lang=c :
     * #define EBADSLT 57
     * }
     */
    public static int EBADSLT() {
        return EBADSLT;
    }
    private static final int EBFONT = (int)59L;
    /**
     * {@snippet lang=c :
     * #define EBFONT 59
     * }
     */
    public static int EBFONT() {
        return EBFONT;
    }
    private static final int ENOSTR = (int)60L;
    /**
     * {@snippet lang=c :
     * #define ENOSTR 60
     * }
     */
    public static int ENOSTR() {
        return ENOSTR;
    }
    private static final int ENODATA = (int)61L;
    /**
     * {@snippet lang=c :
     * #define ENODATA 61
     * }
     */
    public static int ENODATA() {
        return ENODATA;
    }
    private static final int ETIME = (int)62L;
    /**
     * {@snippet lang=c :
     * #define ETIME 62
     * }
     */
    public static int ETIME() {
        return ETIME;
    }
    private static final int ENOSR = (int)63L;
    /**
     * {@snippet lang=c :
     * #define ENOSR 63
     * }
     */
    public static int ENOSR() {
        return ENOSR;
    }
    private static final int ENONET = (int)64L;
    /**
     * {@snippet lang=c :
     * #define ENONET 64
     * }
     */
    public static int ENONET() {
        return ENONET;
    }
    private static final int ENOPKG = (int)65L;
    /**
     * {@snippet lang=c :
     * #define ENOPKG 65
     * }
     */
    public static int ENOPKG() {
        return ENOPKG;
    }
    private static final int EREMOTE = (int)66L;
    /**
     * {@snippet lang=c :
     * #define EREMOTE 66
     * }
     */
    public static int EREMOTE() {
        return EREMOTE;
    }
    private static final int ENOLINK = (int)67L;
    /**
     * {@snippet lang=c :
     * #define ENOLINK 67
     * }
     */
    public static int ENOLINK() {
        return ENOLINK;
    }
    private static final int EADV = (int)68L;
    /**
     * {@snippet lang=c :
     * #define EADV 68
     * }
     */
    public static int EADV() {
        return EADV;
    }
    private static final int ESRMNT = (int)69L;
    /**
     * {@snippet lang=c :
     * #define ESRMNT 69
     * }
     */
    public static int ESRMNT() {
        return ESRMNT;
    }
    private static final int ECOMM = (int)70L;
    /**
     * {@snippet lang=c :
     * #define ECOMM 70
     * }
     */
    public static int ECOMM() {
        return ECOMM;
    }
    private static final int EPROTO = (int)71L;
    /**
     * {@snippet lang=c :
     * #define EPROTO 71
     * }
     */
    public static int EPROTO() {
        return EPROTO;
    }
    private static final int EMULTIHOP = (int)72L;
    /**
     * {@snippet lang=c :
     * #define EMULTIHOP 72
     * }
     */
    public static int EMULTIHOP() {
        return EMULTIHOP;
    }
    private static final int EDOTDOT = (int)73L;
    /**
     * {@snippet lang=c :
     * #define EDOTDOT 73
     * }
     */
    public static int EDOTDOT() {
        return EDOTDOT;
    }
    private static final int EBADMSG = (int)74L;
    /**
     * {@snippet lang=c :
     * #define EBADMSG 74
     * }
     */
    public static int EBADMSG() {
        return EBADMSG;
    }
    private static final int EOVERFLOW = (int)75L;
    /**
     * {@snippet lang=c :
     * #define EOVERFLOW 75
     * }
     */
    public static int EOVERFLOW() {
        return EOVERFLOW;
    }
    private static final int ENOTUNIQ = (int)76L;
    /**
     * {@snippet lang=c :
     * #define ENOTUNIQ 76
     * }
     */
    public static int ENOTUNIQ() {
        return ENOTUNIQ;
    }
    private static final int EBADFD = (int)77L;
    /**
     * {@snippet lang=c :
     * #define EBADFD 77
     * }
     */
    public static int EBADFD() {
        return EBADFD;
    }
    private static final int EREMCHG = (int)78L;
    /**
     * {@snippet lang=c :
     * #define EREMCHG 78
     * }
     */
    public static int EREMCHG() {
        return EREMCHG;
    }
    private static final int ELIBACC = (int)79L;
    /**
     * {@snippet lang=c :
     * #define ELIBACC 79
     * }
     */
    public static int ELIBACC() {
        return ELIBACC;
    }
    private static final int ELIBBAD = (int)80L;
    /**
     * {@snippet lang=c :
     * #define ELIBBAD 80
     * }
     */
    public static int ELIBBAD() {
        return ELIBBAD;
    }
    private static final int ELIBSCN = (int)81L;
    /**
     * {@snippet lang=c :
     * #define ELIBSCN 81
     * }
     */
    public static int ELIBSCN() {
        return ELIBSCN;
    }
    private static final int ELIBMAX = (int)82L;
    /**
     * {@snippet lang=c :
     * #define ELIBMAX 82
     * }
     */
    public static int ELIBMAX() {
        return ELIBMAX;
    }
    private static final int ELIBEXEC = (int)83L;
    /**
     * {@snippet lang=c :
     * #define ELIBEXEC 83
     * }
     */
    public static int ELIBEXEC() {
        return ELIBEXEC;
    }
    private static final int EILSEQ = (int)84L;
    /**
     * {@snippet lang=c :
     * #define EILSEQ 84
     * }
     */
    public static int EILSEQ() {
        return EILSEQ;
    }
    private static final int ERESTART = (int)85L;
    /**
     * {@snippet lang=c :
     * #define ERESTART 85
     * }
     */
    public static int ERESTART() {
        return ERESTART;
    }
    private static final int ESTRPIPE = (int)86L;
    /**
     * {@snippet lang=c :
     * #define ESTRPIPE 86
     * }
     */
    public static int ESTRPIPE() {
        return ESTRPIPE;
    }
    private static final int EUSERS = (int)87L;
    /**
     * {@snippet lang=c :
     * #define EUSERS 87
     * }
     */
    public static int EUSERS() {
        return EUSERS;
    }
    private static final int ENOTSOCK = (int)88L;
    /**
     * {@snippet lang=c :
     * #define ENOTSOCK 88
     * }
     */
    public static int ENOTSOCK() {
        return ENOTSOCK;
    }
    private static final int EDESTADDRREQ = (int)89L;
    /**
     * {@snippet lang=c :
     * #define EDESTADDRREQ 89
     * }
     */
    public static int EDESTADDRREQ() {
        return EDESTADDRREQ;
    }
    private static final int EMSGSIZE = (int)90L;
    /**
     * {@snippet lang=c :
     * #define EMSGSIZE 90
     * }
     */
    public static int EMSGSIZE() {
        return EMSGSIZE;
    }
    private static final int EPROTOTYPE = (int)91L;
    /**
     * {@snippet lang=c :
     * #define EPROTOTYPE 91
     * }
     */
    public static int EPROTOTYPE() {
        return EPROTOTYPE;
    }
    private static final int ENOPROTOOPT = (int)92L;
    /**
     * {@snippet lang=c :
     * #define ENOPROTOOPT 92
     * }
     */
    public static int ENOPROTOOPT() {
        return ENOPROTOOPT;
    }
    private static final int EPROTONOSUPPORT = (int)93L;
    /**
     * {@snippet lang=c :
     * #define EPROTONOSUPPORT 93
     * }
     */
    public static int EPROTONOSUPPORT() {
        return EPROTONOSUPPORT;
    }
    private static final int ESOCKTNOSUPPORT = (int)94L;
    /**
     * {@snippet lang=c :
     * #define ESOCKTNOSUPPORT 94
     * }
     */
    public static int ESOCKTNOSUPPORT() {
        return ESOCKTNOSUPPORT;
    }
    private static final int EOPNOTSUPP = (int)95L;
    /**
     * {@snippet lang=c :
     * #define EOPNOTSUPP 95
     * }
     */
    public static int EOPNOTSUPP() {
        return EOPNOTSUPP;
    }
    private static final int EPFNOSUPPORT = (int)96L;
    /**
     * {@snippet lang=c :
     * #define EPFNOSUPPORT 96
     * }
     */
    public static int EPFNOSUPPORT() {
        return EPFNOSUPPORT;
    }
    private static final int EAFNOSUPPORT = (int)97L;
    /**
     * {@snippet lang=c :
     * #define EAFNOSUPPORT 97
     * }
     */
    public static int EAFNOSUPPORT() {
        return EAFNOSUPPORT;
    }
    private static final int EADDRINUSE = (int)98L;
    /**
     * {@snippet lang=c :
     * #define EADDRINUSE 98
     * }
     */
    public static int EADDRINUSE() {
        return EADDRINUSE;
    }
    private static final int EADDRNOTAVAIL = (int)99L;
    /**
     * {@snippet lang=c :
     * #define EADDRNOTAVAIL 99
     * }
     */
    public static int EADDRNOTAVAIL() {
        return EADDRNOTAVAIL;
    }
    private static final int ENETDOWN = (int)100L;
    /**
     * {@snippet lang=c :
     * #define ENETDOWN 100
     * }
     */
    public static int ENETDOWN() {
        return ENETDOWN;
    }
    private static final int ENETUNREACH = (int)101L;
    /**
     * {@snippet lang=c :
     * #define ENETUNREACH 101
     * }
     */
    public static int ENETUNREACH() {
        return ENETUNREACH;
    }
    private static final int ENETRESET = (int)102L;
    /**
     * {@snippet lang=c :
     * #define ENETRESET 102
     * }
     */
    public static int ENETRESET() {
        return ENETRESET;
    }
    private static final int ECONNABORTED = (int)103L;
    /**
     * {@snippet lang=c :
     * #define ECONNABORTED 103
     * }
     */
    public static int ECONNABORTED() {
        return ECONNABORTED;
    }
    private static final int ECONNRESET = (int)104L;
    /**
     * {@snippet lang=c :
     * #define ECONNRESET 104
     * }
     */
    public static int ECONNRESET() {
        return ECONNRESET;
    }
    private static final int ENOBUFS = (int)105L;
    /**
     * {@snippet lang=c :
     * #define ENOBUFS 105
     * }
     */
    public static int ENOBUFS() {
        return ENOBUFS;
    }
    private static final int EISCONN = (int)106L;
    /**
     * {@snippet lang=c :
     * #define EISCONN 106
     * }
     */
    public static int EISCONN() {
        return EISCONN;
    }
    private static final int ENOTCONN = (int)107L;
    /**
     * {@snippet lang=c :
     * #define ENOTCONN 107
     * }
     */
    public static int ENOTCONN() {
        return ENOTCONN;
    }
    private static final int ESHUTDOWN = (int)108L;
    /**
     * {@snippet lang=c :
     * #define ESHUTDOWN 108
     * }
     */
    public static int ESHUTDOWN() {
        return ESHUTDOWN;
    }
    private static final int ETOOMANYREFS = (int)109L;
    /**
     * {@snippet lang=c :
     * #define ETOOMANYREFS 109
     * }
     */
    public static int ETOOMANYREFS() {
        return ETOOMANYREFS;
    }
    private static final int ETIMEDOUT = (int)110L;
    /**
     * {@snippet lang=c :
     * #define ETIMEDOUT 110
     * }
     */
    public static int ETIMEDOUT() {
        return ETIMEDOUT;
    }
    private static final int ECONNREFUSED = (int)111L;
    /**
     * {@snippet lang=c :
     * #define ECONNREFUSED 111
     * }
     */
    public static int ECONNREFUSED() {
        return ECONNREFUSED;
    }
    private static final int EHOSTDOWN = (int)112L;
    /**
     * {@snippet lang=c :
     * #define EHOSTDOWN 112
     * }
     */
    public static int EHOSTDOWN() {
        return EHOSTDOWN;
    }
    private static final int EHOSTUNREACH = (int)113L;
    /**
     * {@snippet lang=c :
     * #define EHOSTUNREACH 113
     * }
     */
    public static int EHOSTUNREACH() {
        return EHOSTUNREACH;
    }
    private static final int EALREADY = (int)114L;
    /**
     * {@snippet lang=c :
     * #define EALREADY 114
     * }
     */
    public static int EALREADY() {
        return EALREADY;
    }
    private static final int EINPROGRESS = (int)115L;
    /**
     * {@snippet lang=c :
     * #define EINPROGRESS 115
     * }
     */
    public static int EINPROGRESS() {
        return EINPROGRESS;
    }
    private static final int ESTALE = (int)116L;
    /**
     * {@snippet lang=c :
     * #define ESTALE 116
     * }
     */
    public static int ESTALE() {
        return ESTALE;
    }
    private static final int EUCLEAN = (int)117L;
    /**
     * {@snippet lang=c :
     * #define EUCLEAN 117
     * }
     */
    public static int EUCLEAN() {
        return EUCLEAN;
    }
    private static final int ENOTNAM = (int)118L;
    /**
     * {@snippet lang=c :
     * #define ENOTNAM 118
     * }
     */
    public static int ENOTNAM() {
        return ENOTNAM;
    }
    private static final int ENAVAIL = (int)119L;
    /**
     * {@snippet lang=c :
     * #define ENAVAIL 119
     * }
     */
    public static int ENAVAIL() {
        return ENAVAIL;
    }
    private static final int EISNAM = (int)120L;
    /**
     * {@snippet lang=c :
     * #define EISNAM 120
     * }
     */
    public static int EISNAM() {
        return EISNAM;
    }
    private static final int EREMOTEIO = (int)121L;
    /**
     * {@snippet lang=c :
     * #define EREMOTEIO 121
     * }
     */
    public static int EREMOTEIO() {
        return EREMOTEIO;
    }
    private static final int EDQUOT = (int)122L;
    /**
     * {@snippet lang=c :
     * #define EDQUOT 122
     * }
     */
    public static int EDQUOT() {
        return EDQUOT;
    }
    private static final int ENOMEDIUM = (int)123L;
    /**
     * {@snippet lang=c :
     * #define ENOMEDIUM 123
     * }
     */
    public static int ENOMEDIUM() {
        return ENOMEDIUM;
    }
    private static final int EMEDIUMTYPE = (int)124L;
    /**
     * {@snippet lang=c :
     * #define EMEDIUMTYPE 124
     * }
     */
    public static int EMEDIUMTYPE() {
        return EMEDIUMTYPE;
    }
    private static final int ECANCELED = (int)125L;
    /**
     * {@snippet lang=c :
     * #define ECANCELED 125
     * }
     */
    public static int ECANCELED() {
        return ECANCELED;
    }
    private static final int ENOKEY = (int)126L;
    /**
     * {@snippet lang=c :
     * #define ENOKEY 126
     * }
     */
    public static int ENOKEY() {
        return ENOKEY;
    }
    private static final int EKEYEXPIRED = (int)127L;
    /**
     * {@snippet lang=c :
     * #define EKEYEXPIRED 127
     * }
     */
    public static int EKEYEXPIRED() {
        return EKEYEXPIRED;
    }
    private static final int EKEYREVOKED = (int)128L;
    /**
     * {@snippet lang=c :
     * #define EKEYREVOKED 128
     * }
     */
    public static int EKEYREVOKED() {
        return EKEYREVOKED;
    }
    private static final int EKEYREJECTED = (int)129L;
    /**
     * {@snippet lang=c :
     * #define EKEYREJECTED 129
     * }
     */
    public static int EKEYREJECTED() {
        return EKEYREJECTED;
    }
    private static final int EOWNERDEAD = (int)130L;
    /**
     * {@snippet lang=c :
     * #define EOWNERDEAD 130
     * }
     */
    public static int EOWNERDEAD() {
        return EOWNERDEAD;
    }
    private static final int ENOTRECOVERABLE = (int)131L;
    /**
     * {@snippet lang=c :
     * #define ENOTRECOVERABLE 131
     * }
     */
    public static int ENOTRECOVERABLE() {
        return ENOTRECOVERABLE;
    }
    private static final int ERFKILL = (int)132L;
    /**
     * {@snippet lang=c :
     * #define ERFKILL 132
     * }
     */
    public static int ERFKILL() {
        return ERFKILL;
    }
    private static final int EHWPOISON = (int)133L;
    /**
     * {@snippet lang=c :
     * #define EHWPOISON 133
     * }
     */
    public static int EHWPOISON() {
        return EHWPOISON;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = C.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = C.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = C.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = C.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = C.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = C.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = C.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = C.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = C.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = C.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds64_t
     * }
     */
    public static final OfLong __suseconds64_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = C.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = C.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_char u_char
     * }
     */
    public static final OfByte u_char = C.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __u_short u_short
     * }
     */
    public static final OfShort u_short = C.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u_int u_int
     * }
     */
    public static final OfInt u_int = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_long u_long
     * }
     */
    public static final OfLong u_long = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __quad_t quad_t
     * }
     */
    public static final OfLong quad_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u_quad_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __loff_t loff_t
     * }
     */
    public static final OfLong loff_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ino_t ino_t
     * }
     */
    public static final OfLong ino_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __dev_t dev_t
     * }
     */
    public static final OfLong dev_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __gid_t gid_t
     * }
     */
    public static final OfInt gid_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __mode_t mode_t
     * }
     */
    public static final OfInt mode_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __nlink_t nlink_t
     * }
     */
    public static final OfLong nlink_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uid_t uid_t
     * }
     */
    public static final OfInt uid_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __id_t id_t
     * }
     */
    public static final OfInt id_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __daddr_t daddr_t
     * }
     */
    public static final OfInt daddr_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __caddr_t caddr_t
     * }
     */
    public static final AddressLayout caddr_t = C.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __key_t key_t
     * }
     */
    public static final OfInt key_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __clock_t clock_t
     * }
     */
    public static final OfLong clock_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __clockid_t clockid_t
     * }
     */
    public static final OfInt clockid_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __timer_t timer_t
     * }
     */
    public static final AddressLayout timer_t = C.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long ulong
     * }
     */
    public static final OfLong ulong = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = C.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = C.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = C.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t u_int8_t
     * }
     */
    public static final OfByte u_int8_t = C.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t u_int16_t
     * }
     */
    public static final OfShort u_int16_t = C.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t u_int32_t
     * }
     */
    public static final OfInt u_int32_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t u_int64_t
     * }
     */
    public static final OfLong u_int64_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int register_t
     * }
     */
    public static final OfLong register_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __suseconds_t suseconds_t
     * }
     */
    public static final OfLong suseconds_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fd_mask
     * }
     */
    public static final OfLong __fd_mask = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fd_mask fd_mask
     * }
     */
    public static final OfLong fd_mask = C.C_LONG;

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static int select(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", __nfds, __readfds, __writefds, __exceptfds, __timeout);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("pselect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static int pselect(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout, MemorySegment __sigmask) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", __nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __blksize_t blksize_t
     * }
     */
    public static final OfLong blksize_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfLong fsblkcnt_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfLong fsfilcnt_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __tss_t
     * }
     */
    public static final OfInt __tss_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __thrd_t
     * }
     */
    public static final OfLong __thrd_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long pthread_t
     * }
     */
    public static final OfLong pthread_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int pthread_key_t
     * }
     */
    public static final OfInt pthread_key_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int pthread_once_t
     * }
     */
    public static final OfInt pthread_once_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef volatile int pthread_spinlock_t
     * }
     */
    public static final OfInt pthread_spinlock_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = C.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = C.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = C.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = C.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = C.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = C.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = C.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = C.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intptr_t
     * }
     */
    public static final OfLong intptr_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef float _Float32
     * }
     */
    public static final OfFloat _Float32 = C.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double _Float64
     * }
     */
    public static final OfDouble _Float64 = C.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double _Float32x
     * }
     */
    public static final OfDouble _Float32x = C.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef float float_t
     * }
     */
    public static final OfFloat float_t = C.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double double_t
     * }
     */
    public static final OfDouble double_t = C.C_DOUBLE;

    private static class __fpclassify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__fpclassify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __fpclassify(double __value)
     * }
     */
    public static FunctionDescriptor __fpclassify$descriptor() {
        return __fpclassify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __fpclassify(double __value)
     * }
     */
    public static MethodHandle __fpclassify$handle() {
        return __fpclassify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __fpclassify(double __value)
     * }
     */
    public static MemorySegment __fpclassify$address() {
        return __fpclassify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __fpclassify(double __value)
     * }
     */
    public static int __fpclassify(double __value) {
        var mh$ = __fpclassify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fpclassify", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __signbit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__signbit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __signbit(double __value)
     * }
     */
    public static FunctionDescriptor __signbit$descriptor() {
        return __signbit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __signbit(double __value)
     * }
     */
    public static MethodHandle __signbit$handle() {
        return __signbit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __signbit(double __value)
     * }
     */
    public static MemorySegment __signbit$address() {
        return __signbit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __signbit(double __value)
     * }
     */
    public static int __signbit(double __value) {
        var mh$ = __signbit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__signbit", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __isinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__isinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __isinf(double __value)
     * }
     */
    public static FunctionDescriptor __isinf$descriptor() {
        return __isinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __isinf(double __value)
     * }
     */
    public static MethodHandle __isinf$handle() {
        return __isinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __isinf(double __value)
     * }
     */
    public static MemorySegment __isinf$address() {
        return __isinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __isinf(double __value)
     * }
     */
    public static int __isinf(double __value) {
        var mh$ = __isinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__isinf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __finite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__finite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __finite(double __value)
     * }
     */
    public static FunctionDescriptor __finite$descriptor() {
        return __finite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __finite(double __value)
     * }
     */
    public static MethodHandle __finite$handle() {
        return __finite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __finite(double __value)
     * }
     */
    public static MemorySegment __finite$address() {
        return __finite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __finite(double __value)
     * }
     */
    public static int __finite(double __value) {
        var mh$ = __finite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__finite", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __isnan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__isnan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __isnan(double __value)
     * }
     */
    public static FunctionDescriptor __isnan$descriptor() {
        return __isnan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __isnan(double __value)
     * }
     */
    public static MethodHandle __isnan$handle() {
        return __isnan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __isnan(double __value)
     * }
     */
    public static MemorySegment __isnan$address() {
        return __isnan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __isnan(double __value)
     * }
     */
    public static int __isnan(double __value) {
        var mh$ = __isnan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__isnan", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __iseqsig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__iseqsig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __iseqsig(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __iseqsig$descriptor() {
        return __iseqsig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __iseqsig(double __x, double __y)
     * }
     */
    public static MethodHandle __iseqsig$handle() {
        return __iseqsig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __iseqsig(double __x, double __y)
     * }
     */
    public static MemorySegment __iseqsig$address() {
        return __iseqsig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __iseqsig(double __x, double __y)
     * }
     */
    public static int __iseqsig(double __x, double __y) {
        var mh$ = __iseqsig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__iseqsig", __x, __y);
            }
            return (int)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __issignaling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__issignaling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __issignaling(double __value)
     * }
     */
    public static FunctionDescriptor __issignaling$descriptor() {
        return __issignaling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __issignaling(double __value)
     * }
     */
    public static MethodHandle __issignaling$handle() {
        return __issignaling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __issignaling(double __value)
     * }
     */
    public static MemorySegment __issignaling$address() {
        return __issignaling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __issignaling(double __value)
     * }
     */
    public static int __issignaling(double __value) {
        var mh$ = __issignaling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__issignaling", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("acos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double acos(double __x)
     * }
     */
    public static FunctionDescriptor acos$descriptor() {
        return acos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double acos(double __x)
     * }
     */
    public static MethodHandle acos$handle() {
        return acos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double acos(double __x)
     * }
     */
    public static MemorySegment acos$address() {
        return acos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double acos(double __x)
     * }
     */
    public static double acos(double __x) {
        var mh$ = acos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acos", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __acos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__acos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __acos(double __x)
     * }
     */
    public static FunctionDescriptor __acos$descriptor() {
        return __acos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __acos(double __x)
     * }
     */
    public static MethodHandle __acos$handle() {
        return __acos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __acos(double __x)
     * }
     */
    public static MemorySegment __acos$address() {
        return __acos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __acos(double __x)
     * }
     */
    public static double __acos(double __x) {
        var mh$ = __acos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__acos", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("asin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double asin(double __x)
     * }
     */
    public static FunctionDescriptor asin$descriptor() {
        return asin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double asin(double __x)
     * }
     */
    public static MethodHandle asin$handle() {
        return asin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double asin(double __x)
     * }
     */
    public static MemorySegment asin$address() {
        return asin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double asin(double __x)
     * }
     */
    public static double asin(double __x) {
        var mh$ = asin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asin", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __asin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__asin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __asin(double __x)
     * }
     */
    public static FunctionDescriptor __asin$descriptor() {
        return __asin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __asin(double __x)
     * }
     */
    public static MethodHandle __asin$handle() {
        return __asin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __asin(double __x)
     * }
     */
    public static MemorySegment __asin$address() {
        return __asin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __asin(double __x)
     * }
     */
    public static double __asin(double __x) {
        var mh$ = __asin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__asin", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("atan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atan(double __x)
     * }
     */
    public static FunctionDescriptor atan$descriptor() {
        return atan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atan(double __x)
     * }
     */
    public static MethodHandle atan$handle() {
        return atan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atan(double __x)
     * }
     */
    public static MemorySegment atan$address() {
        return atan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atan(double __x)
     * }
     */
    public static double atan(double __x) {
        var mh$ = atan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __atan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__atan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __atan(double __x)
     * }
     */
    public static FunctionDescriptor __atan$descriptor() {
        return __atan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __atan(double __x)
     * }
     */
    public static MethodHandle __atan$handle() {
        return __atan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __atan(double __x)
     * }
     */
    public static MemorySegment __atan$address() {
        return __atan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __atan(double __x)
     * }
     */
    public static double __atan(double __x) {
        var mh$ = __atan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__atan", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("atan2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atan2(double __y, double __x)
     * }
     */
    public static FunctionDescriptor atan2$descriptor() {
        return atan2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atan2(double __y, double __x)
     * }
     */
    public static MethodHandle atan2$handle() {
        return atan2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atan2(double __y, double __x)
     * }
     */
    public static MemorySegment atan2$address() {
        return atan2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atan2(double __y, double __x)
     * }
     */
    public static double atan2(double __y, double __x) {
        var mh$ = atan2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2", __y, __x);
            }
            return (double)mh$.invokeExact(__y, __x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __atan2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__atan2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __atan2(double __y, double __x)
     * }
     */
    public static FunctionDescriptor __atan2$descriptor() {
        return __atan2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __atan2(double __y, double __x)
     * }
     */
    public static MethodHandle __atan2$handle() {
        return __atan2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __atan2(double __y, double __x)
     * }
     */
    public static MemorySegment __atan2$address() {
        return __atan2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __atan2(double __y, double __x)
     * }
     */
    public static double __atan2(double __y, double __x) {
        var mh$ = __atan2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__atan2", __y, __x);
            }
            return (double)mh$.invokeExact(__y, __x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("cos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cos(double __x)
     * }
     */
    public static FunctionDescriptor cos$descriptor() {
        return cos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cos(double __x)
     * }
     */
    public static MethodHandle cos$handle() {
        return cos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cos(double __x)
     * }
     */
    public static MemorySegment cos$address() {
        return cos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cos(double __x)
     * }
     */
    public static double cos(double __x) {
        var mh$ = cos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cos", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__cos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __cos(double __x)
     * }
     */
    public static FunctionDescriptor __cos$descriptor() {
        return __cos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __cos(double __x)
     * }
     */
    public static MethodHandle __cos$handle() {
        return __cos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __cos(double __x)
     * }
     */
    public static MemorySegment __cos$address() {
        return __cos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __cos(double __x)
     * }
     */
    public static double __cos(double __x) {
        var mh$ = __cos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cos", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("sin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sin(double __x)
     * }
     */
    public static FunctionDescriptor sin$descriptor() {
        return sin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sin(double __x)
     * }
     */
    public static MethodHandle sin$handle() {
        return sin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sin(double __x)
     * }
     */
    public static MemorySegment sin$address() {
        return sin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sin(double __x)
     * }
     */
    public static double sin(double __x) {
        var mh$ = sin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sin", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__sin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __sin(double __x)
     * }
     */
    public static FunctionDescriptor __sin$descriptor() {
        return __sin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __sin(double __x)
     * }
     */
    public static MethodHandle __sin$handle() {
        return __sin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __sin(double __x)
     * }
     */
    public static MemorySegment __sin$address() {
        return __sin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __sin(double __x)
     * }
     */
    public static double __sin(double __x) {
        var mh$ = __sin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sin", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("tan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tan(double __x)
     * }
     */
    public static FunctionDescriptor tan$descriptor() {
        return tan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tan(double __x)
     * }
     */
    public static MethodHandle tan$handle() {
        return tan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tan(double __x)
     * }
     */
    public static MemorySegment tan$address() {
        return tan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tan(double __x)
     * }
     */
    public static double tan(double __x) {
        var mh$ = tan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tan", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__tan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __tan(double __x)
     * }
     */
    public static FunctionDescriptor __tan$descriptor() {
        return __tan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __tan(double __x)
     * }
     */
    public static MethodHandle __tan$handle() {
        return __tan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __tan(double __x)
     * }
     */
    public static MemorySegment __tan$address() {
        return __tan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __tan(double __x)
     * }
     */
    public static double __tan(double __x) {
        var mh$ = __tan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tan", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("cosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cosh(double __x)
     * }
     */
    public static FunctionDescriptor cosh$descriptor() {
        return cosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cosh(double __x)
     * }
     */
    public static MethodHandle cosh$handle() {
        return cosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cosh(double __x)
     * }
     */
    public static MemorySegment cosh$address() {
        return cosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cosh(double __x)
     * }
     */
    public static double cosh(double __x) {
        var mh$ = cosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__cosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __cosh(double __x)
     * }
     */
    public static FunctionDescriptor __cosh$descriptor() {
        return __cosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __cosh(double __x)
     * }
     */
    public static MethodHandle __cosh$handle() {
        return __cosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __cosh(double __x)
     * }
     */
    public static MemorySegment __cosh$address() {
        return __cosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __cosh(double __x)
     * }
     */
    public static double __cosh(double __x) {
        var mh$ = __cosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cosh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("sinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sinh(double __x)
     * }
     */
    public static FunctionDescriptor sinh$descriptor() {
        return sinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sinh(double __x)
     * }
     */
    public static MethodHandle sinh$handle() {
        return sinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sinh(double __x)
     * }
     */
    public static MemorySegment sinh$address() {
        return sinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sinh(double __x)
     * }
     */
    public static double sinh(double __x) {
        var mh$ = sinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__sinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __sinh(double __x)
     * }
     */
    public static FunctionDescriptor __sinh$descriptor() {
        return __sinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __sinh(double __x)
     * }
     */
    public static MethodHandle __sinh$handle() {
        return __sinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __sinh(double __x)
     * }
     */
    public static MemorySegment __sinh$address() {
        return __sinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __sinh(double __x)
     * }
     */
    public static double __sinh(double __x) {
        var mh$ = __sinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sinh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("tanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tanh(double __x)
     * }
     */
    public static FunctionDescriptor tanh$descriptor() {
        return tanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tanh(double __x)
     * }
     */
    public static MethodHandle tanh$handle() {
        return tanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tanh(double __x)
     * }
     */
    public static MemorySegment tanh$address() {
        return tanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tanh(double __x)
     * }
     */
    public static double tanh(double __x) {
        var mh$ = tanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__tanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __tanh(double __x)
     * }
     */
    public static FunctionDescriptor __tanh$descriptor() {
        return __tanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __tanh(double __x)
     * }
     */
    public static MethodHandle __tanh$handle() {
        return __tanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __tanh(double __x)
     * }
     */
    public static MemorySegment __tanh$address() {
        return __tanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __tanh(double __x)
     * }
     */
    public static double __tanh(double __x) {
        var mh$ = __tanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tanh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("acosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double acosh(double __x)
     * }
     */
    public static FunctionDescriptor acosh$descriptor() {
        return acosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double acosh(double __x)
     * }
     */
    public static MethodHandle acosh$handle() {
        return acosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double acosh(double __x)
     * }
     */
    public static MemorySegment acosh$address() {
        return acosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double acosh(double __x)
     * }
     */
    public static double acosh(double __x) {
        var mh$ = acosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __acosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__acosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __acosh(double __x)
     * }
     */
    public static FunctionDescriptor __acosh$descriptor() {
        return __acosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __acosh(double __x)
     * }
     */
    public static MethodHandle __acosh$handle() {
        return __acosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __acosh(double __x)
     * }
     */
    public static MemorySegment __acosh$address() {
        return __acosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __acosh(double __x)
     * }
     */
    public static double __acosh(double __x) {
        var mh$ = __acosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__acosh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("asinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double asinh(double __x)
     * }
     */
    public static FunctionDescriptor asinh$descriptor() {
        return asinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double asinh(double __x)
     * }
     */
    public static MethodHandle asinh$handle() {
        return asinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double asinh(double __x)
     * }
     */
    public static MemorySegment asinh$address() {
        return asinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double asinh(double __x)
     * }
     */
    public static double asinh(double __x) {
        var mh$ = asinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __asinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__asinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __asinh(double __x)
     * }
     */
    public static FunctionDescriptor __asinh$descriptor() {
        return __asinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __asinh(double __x)
     * }
     */
    public static MethodHandle __asinh$handle() {
        return __asinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __asinh(double __x)
     * }
     */
    public static MemorySegment __asinh$address() {
        return __asinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __asinh(double __x)
     * }
     */
    public static double __asinh(double __x) {
        var mh$ = __asinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__asinh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("atanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atanh(double __x)
     * }
     */
    public static FunctionDescriptor atanh$descriptor() {
        return atanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atanh(double __x)
     * }
     */
    public static MethodHandle atanh$handle() {
        return atanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atanh(double __x)
     * }
     */
    public static MemorySegment atanh$address() {
        return atanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atanh(double __x)
     * }
     */
    public static double atanh(double __x) {
        var mh$ = atanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __atanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__atanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __atanh(double __x)
     * }
     */
    public static FunctionDescriptor __atanh$descriptor() {
        return __atanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __atanh(double __x)
     * }
     */
    public static MethodHandle __atanh$handle() {
        return __atanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __atanh(double __x)
     * }
     */
    public static MemorySegment __atanh$address() {
        return __atanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __atanh(double __x)
     * }
     */
    public static double __atanh(double __x) {
        var mh$ = __atanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__atanh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double exp(double __x)
     * }
     */
    public static FunctionDescriptor exp$descriptor() {
        return exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double exp(double __x)
     * }
     */
    public static MethodHandle exp$handle() {
        return exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double exp(double __x)
     * }
     */
    public static MemorySegment exp$address() {
        return exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double exp(double __x)
     * }
     */
    public static double exp(double __x) {
        var mh$ = exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __exp(double __x)
     * }
     */
    public static FunctionDescriptor __exp$descriptor() {
        return __exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __exp(double __x)
     * }
     */
    public static MethodHandle __exp$handle() {
        return __exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __exp(double __x)
     * }
     */
    public static MemorySegment __exp$address() {
        return __exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __exp(double __x)
     * }
     */
    public static double __exp(double __x) {
        var mh$ = __exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__exp", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class frexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("frexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double frexp(double __x, int *__exponent)
     * }
     */
    public static FunctionDescriptor frexp$descriptor() {
        return frexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double frexp(double __x, int *__exponent)
     * }
     */
    public static MethodHandle frexp$handle() {
        return frexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double frexp(double __x, int *__exponent)
     * }
     */
    public static MemorySegment frexp$address() {
        return frexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double frexp(double __x, int *__exponent)
     * }
     */
    public static double frexp(double __x, MemorySegment __exponent) {
        var mh$ = frexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("frexp", __x, __exponent);
            }
            return (double)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __frexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("__frexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __frexp(double __x, int *__exponent)
     * }
     */
    public static FunctionDescriptor __frexp$descriptor() {
        return __frexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __frexp(double __x, int *__exponent)
     * }
     */
    public static MethodHandle __frexp$handle() {
        return __frexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __frexp(double __x, int *__exponent)
     * }
     */
    public static MemorySegment __frexp$address() {
        return __frexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __frexp(double __x, int *__exponent)
     * }
     */
    public static double __frexp(double __x, MemorySegment __exponent) {
        var mh$ = __frexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__frexp", __x, __exponent);
            }
            return (double)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("ldexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ldexp(double __x, int __exponent)
     * }
     */
    public static FunctionDescriptor ldexp$descriptor() {
        return ldexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ldexp(double __x, int __exponent)
     * }
     */
    public static MethodHandle ldexp$handle() {
        return ldexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ldexp(double __x, int __exponent)
     * }
     */
    public static MemorySegment ldexp$address() {
        return ldexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ldexp(double __x, int __exponent)
     * }
     */
    public static double ldexp(double __x, int __exponent) {
        var mh$ = ldexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldexp", __x, __exponent);
            }
            return (double)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ldexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__ldexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __ldexp(double __x, int __exponent)
     * }
     */
    public static FunctionDescriptor __ldexp$descriptor() {
        return __ldexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __ldexp(double __x, int __exponent)
     * }
     */
    public static MethodHandle __ldexp$handle() {
        return __ldexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __ldexp(double __x, int __exponent)
     * }
     */
    public static MemorySegment __ldexp$address() {
        return __ldexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __ldexp(double __x, int __exponent)
     * }
     */
    public static double __ldexp(double __x, int __exponent) {
        var mh$ = __ldexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ldexp", __x, __exponent);
            }
            return (double)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log(double __x)
     * }
     */
    public static FunctionDescriptor log$descriptor() {
        return log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log(double __x)
     * }
     */
    public static MethodHandle log$handle() {
        return log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log(double __x)
     * }
     */
    public static MemorySegment log$address() {
        return log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log(double __x)
     * }
     */
    public static double log(double __x) {
        var mh$ = log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __log(double __x)
     * }
     */
    public static FunctionDescriptor __log$descriptor() {
        return __log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __log(double __x)
     * }
     */
    public static MethodHandle __log$handle() {
        return __log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __log(double __x)
     * }
     */
    public static MemorySegment __log$address() {
        return __log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __log(double __x)
     * }
     */
    public static double __log(double __x) {
        var mh$ = __log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("log10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log10(double __x)
     * }
     */
    public static FunctionDescriptor log10$descriptor() {
        return log10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log10(double __x)
     * }
     */
    public static MethodHandle log10$handle() {
        return log10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log10(double __x)
     * }
     */
    public static MemorySegment log10$address() {
        return log10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log10(double __x)
     * }
     */
    public static double log10(double __x) {
        var mh$ = log10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__log10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __log10(double __x)
     * }
     */
    public static FunctionDescriptor __log10$descriptor() {
        return __log10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __log10(double __x)
     * }
     */
    public static MethodHandle __log10$handle() {
        return __log10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __log10(double __x)
     * }
     */
    public static MemorySegment __log10$address() {
        return __log10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __log10(double __x)
     * }
     */
    public static double __log10(double __x) {
        var mh$ = __log10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log10", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("modf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double modf(double __x, double *__iptr)
     * }
     */
    public static FunctionDescriptor modf$descriptor() {
        return modf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double modf(double __x, double *__iptr)
     * }
     */
    public static MethodHandle modf$handle() {
        return modf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double modf(double __x, double *__iptr)
     * }
     */
    public static MemorySegment modf$address() {
        return modf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double modf(double __x, double *__iptr)
     * }
     */
    public static double modf(double __x, MemorySegment __iptr) {
        var mh$ = modf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modf", __x, __iptr);
            }
            return (double)mh$.invokeExact(__x, __iptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __modf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("__modf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __modf(double __x, double *__iptr)
     * }
     */
    public static FunctionDescriptor __modf$descriptor() {
        return __modf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __modf(double __x, double *__iptr)
     * }
     */
    public static MethodHandle __modf$handle() {
        return __modf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __modf(double __x, double *__iptr)
     * }
     */
    public static MemorySegment __modf$address() {
        return __modf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __modf(double __x, double *__iptr)
     * }
     */
    public static double __modf(double __x, MemorySegment __iptr) {
        var mh$ = __modf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__modf", __x, __iptr);
            }
            return (double)mh$.invokeExact(__x, __iptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("expm1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double expm1(double __x)
     * }
     */
    public static FunctionDescriptor expm1$descriptor() {
        return expm1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double expm1(double __x)
     * }
     */
    public static MethodHandle expm1$handle() {
        return expm1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double expm1(double __x)
     * }
     */
    public static MemorySegment expm1$address() {
        return expm1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double expm1(double __x)
     * }
     */
    public static double expm1(double __x) {
        var mh$ = expm1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __expm1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__expm1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __expm1(double __x)
     * }
     */
    public static FunctionDescriptor __expm1$descriptor() {
        return __expm1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __expm1(double __x)
     * }
     */
    public static MethodHandle __expm1$handle() {
        return __expm1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __expm1(double __x)
     * }
     */
    public static MemorySegment __expm1$address() {
        return __expm1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __expm1(double __x)
     * }
     */
    public static double __expm1(double __x) {
        var mh$ = __expm1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__expm1", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("log1p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log1p(double __x)
     * }
     */
    public static FunctionDescriptor log1p$descriptor() {
        return log1p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log1p(double __x)
     * }
     */
    public static MethodHandle log1p$handle() {
        return log1p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log1p(double __x)
     * }
     */
    public static MemorySegment log1p$address() {
        return log1p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log1p(double __x)
     * }
     */
    public static double log1p(double __x) {
        var mh$ = log1p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1p", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log1p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__log1p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __log1p(double __x)
     * }
     */
    public static FunctionDescriptor __log1p$descriptor() {
        return __log1p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __log1p(double __x)
     * }
     */
    public static MethodHandle __log1p$handle() {
        return __log1p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __log1p(double __x)
     * }
     */
    public static MemorySegment __log1p$address() {
        return __log1p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __log1p(double __x)
     * }
     */
    public static double __log1p(double __x) {
        var mh$ = __log1p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log1p", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("logb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double logb(double __x)
     * }
     */
    public static FunctionDescriptor logb$descriptor() {
        return logb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double logb(double __x)
     * }
     */
    public static MethodHandle logb$handle() {
        return logb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double logb(double __x)
     * }
     */
    public static MemorySegment logb$address() {
        return logb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double logb(double __x)
     * }
     */
    public static double logb(double __x) {
        var mh$ = logb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logb", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __logb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__logb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __logb(double __x)
     * }
     */
    public static FunctionDescriptor __logb$descriptor() {
        return __logb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __logb(double __x)
     * }
     */
    public static MethodHandle __logb$handle() {
        return __logb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __logb(double __x)
     * }
     */
    public static MemorySegment __logb$address() {
        return __logb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __logb(double __x)
     * }
     */
    public static double __logb(double __x) {
        var mh$ = __logb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__logb", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("exp2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double exp2(double __x)
     * }
     */
    public static FunctionDescriptor exp2$descriptor() {
        return exp2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double exp2(double __x)
     * }
     */
    public static MethodHandle exp2$handle() {
        return exp2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double exp2(double __x)
     * }
     */
    public static MemorySegment exp2$address() {
        return exp2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double exp2(double __x)
     * }
     */
    public static double exp2(double __x) {
        var mh$ = exp2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __exp2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__exp2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __exp2(double __x)
     * }
     */
    public static FunctionDescriptor __exp2$descriptor() {
        return __exp2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __exp2(double __x)
     * }
     */
    public static MethodHandle __exp2$handle() {
        return __exp2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __exp2(double __x)
     * }
     */
    public static MemorySegment __exp2$address() {
        return __exp2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __exp2(double __x)
     * }
     */
    public static double __exp2(double __x) {
        var mh$ = __exp2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__exp2", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log2(double __x)
     * }
     */
    public static FunctionDescriptor log2$descriptor() {
        return log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log2(double __x)
     * }
     */
    public static MethodHandle log2$handle() {
        return log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log2(double __x)
     * }
     */
    public static MemorySegment log2$address() {
        return log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log2(double __x)
     * }
     */
    public static double log2(double __x) {
        var mh$ = log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __log2(double __x)
     * }
     */
    public static FunctionDescriptor __log2$descriptor() {
        return __log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __log2(double __x)
     * }
     */
    public static MethodHandle __log2$handle() {
        return __log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __log2(double __x)
     * }
     */
    public static MemorySegment __log2$address() {
        return __log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __log2(double __x)
     * }
     */
    public static double __log2(double __x) {
        var mh$ = __log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log2", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("pow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double pow(double __x, double __y)
     * }
     */
    public static FunctionDescriptor pow$descriptor() {
        return pow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double pow(double __x, double __y)
     * }
     */
    public static MethodHandle pow$handle() {
        return pow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double pow(double __x, double __y)
     * }
     */
    public static MemorySegment pow$address() {
        return pow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double pow(double __x, double __y)
     * }
     */
    public static double pow(double __x, double __y) {
        var mh$ = pow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pow", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __pow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__pow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __pow(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __pow$descriptor() {
        return __pow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __pow(double __x, double __y)
     * }
     */
    public static MethodHandle __pow$handle() {
        return __pow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __pow(double __x, double __y)
     * }
     */
    public static MemorySegment __pow$address() {
        return __pow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __pow(double __x, double __y)
     * }
     */
    public static double __pow(double __x, double __y) {
        var mh$ = __pow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__pow", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("sqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sqrt(double __x)
     * }
     */
    public static FunctionDescriptor sqrt$descriptor() {
        return sqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sqrt(double __x)
     * }
     */
    public static MethodHandle sqrt$handle() {
        return sqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sqrt(double __x)
     * }
     */
    public static MemorySegment sqrt$address() {
        return sqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sqrt(double __x)
     * }
     */
    public static double sqrt(double __x) {
        var mh$ = sqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrt", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__sqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __sqrt(double __x)
     * }
     */
    public static FunctionDescriptor __sqrt$descriptor() {
        return __sqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __sqrt(double __x)
     * }
     */
    public static MethodHandle __sqrt$handle() {
        return __sqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __sqrt(double __x)
     * }
     */
    public static MemorySegment __sqrt$address() {
        return __sqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __sqrt(double __x)
     * }
     */
    public static double __sqrt(double __x) {
        var mh$ = __sqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sqrt", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hypot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("hypot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double hypot(double __x, double __y)
     * }
     */
    public static FunctionDescriptor hypot$descriptor() {
        return hypot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double hypot(double __x, double __y)
     * }
     */
    public static MethodHandle hypot$handle() {
        return hypot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double hypot(double __x, double __y)
     * }
     */
    public static MemorySegment hypot$address() {
        return hypot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double hypot(double __x, double __y)
     * }
     */
    public static double hypot(double __x, double __y) {
        var mh$ = hypot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hypot", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __hypot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__hypot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __hypot(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __hypot$descriptor() {
        return __hypot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __hypot(double __x, double __y)
     * }
     */
    public static MethodHandle __hypot$handle() {
        return __hypot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __hypot(double __x, double __y)
     * }
     */
    public static MemorySegment __hypot$address() {
        return __hypot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __hypot(double __x, double __y)
     * }
     */
    public static double __hypot(double __x, double __y) {
        var mh$ = __hypot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__hypot", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("cbrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cbrt(double __x)
     * }
     */
    public static FunctionDescriptor cbrt$descriptor() {
        return cbrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cbrt(double __x)
     * }
     */
    public static MethodHandle cbrt$handle() {
        return cbrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cbrt(double __x)
     * }
     */
    public static MemorySegment cbrt$address() {
        return cbrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cbrt(double __x)
     * }
     */
    public static double cbrt(double __x) {
        var mh$ = cbrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrt", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cbrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__cbrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __cbrt(double __x)
     * }
     */
    public static FunctionDescriptor __cbrt$descriptor() {
        return __cbrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __cbrt(double __x)
     * }
     */
    public static MethodHandle __cbrt$handle() {
        return __cbrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __cbrt(double __x)
     * }
     */
    public static MemorySegment __cbrt$address() {
        return __cbrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __cbrt(double __x)
     * }
     */
    public static double __cbrt(double __x) {
        var mh$ = __cbrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cbrt", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("ceil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ceil(double __x)
     * }
     */
    public static FunctionDescriptor ceil$descriptor() {
        return ceil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ceil(double __x)
     * }
     */
    public static MethodHandle ceil$handle() {
        return ceil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ceil(double __x)
     * }
     */
    public static MemorySegment ceil$address() {
        return ceil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ceil(double __x)
     * }
     */
    public static double ceil(double __x) {
        var mh$ = ceil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceil", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ceil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__ceil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __ceil(double __x)
     * }
     */
    public static FunctionDescriptor __ceil$descriptor() {
        return __ceil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __ceil(double __x)
     * }
     */
    public static MethodHandle __ceil$handle() {
        return __ceil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __ceil(double __x)
     * }
     */
    public static MemorySegment __ceil$address() {
        return __ceil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __ceil(double __x)
     * }
     */
    public static double __ceil(double __x) {
        var mh$ = __ceil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ceil", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("fabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fabs(double __x)
     * }
     */
    public static FunctionDescriptor fabs$descriptor() {
        return fabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fabs(double __x)
     * }
     */
    public static MethodHandle fabs$handle() {
        return fabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fabs(double __x)
     * }
     */
    public static MemorySegment fabs$address() {
        return fabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fabs(double __x)
     * }
     */
    public static double fabs(double __x) {
        var mh$ = fabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fabs", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__fabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __fabs(double __x)
     * }
     */
    public static FunctionDescriptor __fabs$descriptor() {
        return __fabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __fabs(double __x)
     * }
     */
    public static MethodHandle __fabs$handle() {
        return __fabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __fabs(double __x)
     * }
     */
    public static MemorySegment __fabs$address() {
        return __fabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __fabs(double __x)
     * }
     */
    public static double __fabs(double __x) {
        var mh$ = __fabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fabs", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("floor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double floor(double __x)
     * }
     */
    public static FunctionDescriptor floor$descriptor() {
        return floor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double floor(double __x)
     * }
     */
    public static MethodHandle floor$handle() {
        return floor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double floor(double __x)
     * }
     */
    public static MemorySegment floor$address() {
        return floor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double floor(double __x)
     * }
     */
    public static double floor(double __x) {
        var mh$ = floor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floor", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __floor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__floor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __floor(double __x)
     * }
     */
    public static FunctionDescriptor __floor$descriptor() {
        return __floor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __floor(double __x)
     * }
     */
    public static MethodHandle __floor$handle() {
        return __floor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __floor(double __x)
     * }
     */
    public static MemorySegment __floor$address() {
        return __floor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __floor(double __x)
     * }
     */
    public static double __floor(double __x) {
        var mh$ = __floor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__floor", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("fmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmod(double __x, double __y)
     * }
     */
    public static FunctionDescriptor fmod$descriptor() {
        return fmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmod(double __x, double __y)
     * }
     */
    public static MethodHandle fmod$handle() {
        return fmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmod(double __x, double __y)
     * }
     */
    public static MemorySegment fmod$address() {
        return fmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmod(double __x, double __y)
     * }
     */
    public static double fmod(double __x, double __y) {
        var mh$ = fmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmod", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__fmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __fmod(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __fmod$descriptor() {
        return __fmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __fmod(double __x, double __y)
     * }
     */
    public static MethodHandle __fmod$handle() {
        return __fmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __fmod(double __x, double __y)
     * }
     */
    public static MemorySegment __fmod$address() {
        return __fmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __fmod(double __x, double __y)
     * }
     */
    public static double __fmod(double __x, double __y) {
        var mh$ = __fmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fmod", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("isinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isinf(double __value)
     * }
     */
    public static FunctionDescriptor isinf$descriptor() {
        return isinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isinf(double __value)
     * }
     */
    public static MethodHandle isinf$handle() {
        return isinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isinf(double __value)
     * }
     */
    public static MemorySegment isinf$address() {
        return isinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isinf(double __value)
     * }
     */
    public static int isinf(double __value) {
        var mh$ = isinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isinf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class finite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("finite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int finite(double __value)
     * }
     */
    public static FunctionDescriptor finite$descriptor() {
        return finite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int finite(double __value)
     * }
     */
    public static MethodHandle finite$handle() {
        return finite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int finite(double __value)
     * }
     */
    public static MemorySegment finite$address() {
        return finite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int finite(double __value)
     * }
     */
    public static int finite(double __value) {
        var mh$ = finite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("finite", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("drem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double drem(double __x, double __y)
     * }
     */
    public static FunctionDescriptor drem$descriptor() {
        return drem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double drem(double __x, double __y)
     * }
     */
    public static MethodHandle drem$handle() {
        return drem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double drem(double __x, double __y)
     * }
     */
    public static MemorySegment drem$address() {
        return drem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double drem(double __x, double __y)
     * }
     */
    public static double drem(double __x, double __y) {
        var mh$ = drem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drem", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __drem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__drem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __drem(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __drem$descriptor() {
        return __drem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __drem(double __x, double __y)
     * }
     */
    public static MethodHandle __drem$handle() {
        return __drem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __drem(double __x, double __y)
     * }
     */
    public static MemorySegment __drem$address() {
        return __drem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __drem(double __x, double __y)
     * }
     */
    public static double __drem(double __x, double __y) {
        var mh$ = __drem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__drem", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class significand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("significand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double significand(double __x)
     * }
     */
    public static FunctionDescriptor significand$descriptor() {
        return significand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double significand(double __x)
     * }
     */
    public static MethodHandle significand$handle() {
        return significand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double significand(double __x)
     * }
     */
    public static MemorySegment significand$address() {
        return significand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double significand(double __x)
     * }
     */
    public static double significand(double __x) {
        var mh$ = significand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("significand", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __significand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__significand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __significand(double __x)
     * }
     */
    public static FunctionDescriptor __significand$descriptor() {
        return __significand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __significand(double __x)
     * }
     */
    public static MethodHandle __significand$handle() {
        return __significand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __significand(double __x)
     * }
     */
    public static MemorySegment __significand$address() {
        return __significand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __significand(double __x)
     * }
     */
    public static double __significand(double __x) {
        var mh$ = __significand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__significand", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("copysign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double copysign(double __x, double __y)
     * }
     */
    public static FunctionDescriptor copysign$descriptor() {
        return copysign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double copysign(double __x, double __y)
     * }
     */
    public static MethodHandle copysign$handle() {
        return copysign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double copysign(double __x, double __y)
     * }
     */
    public static MemorySegment copysign$address() {
        return copysign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double copysign(double __x, double __y)
     * }
     */
    public static double copysign(double __x, double __y) {
        var mh$ = copysign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysign", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __copysign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__copysign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __copysign(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __copysign$descriptor() {
        return __copysign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __copysign(double __x, double __y)
     * }
     */
    public static MethodHandle __copysign$handle() {
        return __copysign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __copysign(double __x, double __y)
     * }
     */
    public static MemorySegment __copysign$address() {
        return __copysign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __copysign(double __x, double __y)
     * }
     */
    public static double __copysign(double __x, double __y) {
        var mh$ = __copysign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__copysign", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("nan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nan(const char *__tagb)
     * }
     */
    public static FunctionDescriptor nan$descriptor() {
        return nan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nan(const char *__tagb)
     * }
     */
    public static MethodHandle nan$handle() {
        return nan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nan(const char *__tagb)
     * }
     */
    public static MemorySegment nan$address() {
        return nan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nan(const char *__tagb)
     * }
     */
    public static double nan(MemorySegment __tagb) {
        var mh$ = nan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nan", __tagb);
            }
            return (double)mh$.invokeExact(__tagb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __nan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("__nan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __nan(const char *__tagb)
     * }
     */
    public static FunctionDescriptor __nan$descriptor() {
        return __nan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __nan(const char *__tagb)
     * }
     */
    public static MethodHandle __nan$handle() {
        return __nan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __nan(const char *__tagb)
     * }
     */
    public static MemorySegment __nan$address() {
        return __nan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __nan(const char *__tagb)
     * }
     */
    public static double __nan(MemorySegment __tagb) {
        var mh$ = __nan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__nan", __tagb);
            }
            return (double)mh$.invokeExact(__tagb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isnan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("isnan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isnan(double __value)
     * }
     */
    public static FunctionDescriptor isnan$descriptor() {
        return isnan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isnan(double __value)
     * }
     */
    public static MethodHandle isnan$handle() {
        return isnan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isnan(double __value)
     * }
     */
    public static MemorySegment isnan$address() {
        return isnan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isnan(double __value)
     * }
     */
    public static int isnan(double __value) {
        var mh$ = isnan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isnan", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("j0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static FunctionDescriptor j0$descriptor() {
        return j0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static MethodHandle j0$handle() {
        return j0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static MemorySegment j0$address() {
        return j0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static double j0(double x0) {
        var mh$ = j0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __j0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__j0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __j0(double)
     * }
     */
    public static FunctionDescriptor __j0$descriptor() {
        return __j0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __j0(double)
     * }
     */
    public static MethodHandle __j0$handle() {
        return __j0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __j0(double)
     * }
     */
    public static MemorySegment __j0$address() {
        return __j0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __j0(double)
     * }
     */
    public static double __j0(double x0) {
        var mh$ = __j0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__j0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("j1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static FunctionDescriptor j1$descriptor() {
        return j1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static MethodHandle j1$handle() {
        return j1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static MemorySegment j1$address() {
        return j1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static double j1(double x0) {
        var mh$ = j1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __j1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__j1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __j1(double)
     * }
     */
    public static FunctionDescriptor __j1$descriptor() {
        return __j1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __j1(double)
     * }
     */
    public static MethodHandle __j1$handle() {
        return __j1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __j1(double)
     * }
     */
    public static MemorySegment __j1$address() {
        return __j1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __j1(double)
     * }
     */
    public static double __j1(double x0) {
        var mh$ = __j1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__j1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_INT,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("jn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static FunctionDescriptor jn$descriptor() {
        return jn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static MethodHandle jn$handle() {
        return jn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static MemorySegment jn$address() {
        return jn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static double jn(int x0, double x1) {
        var mh$ = jn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __jn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_INT,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__jn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __jn(int, double)
     * }
     */
    public static FunctionDescriptor __jn$descriptor() {
        return __jn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __jn(int, double)
     * }
     */
    public static MethodHandle __jn$handle() {
        return __jn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __jn(int, double)
     * }
     */
    public static MemorySegment __jn$address() {
        return __jn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __jn(int, double)
     * }
     */
    public static double __jn(int x0, double x1) {
        var mh$ = __jn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__jn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("y0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static FunctionDescriptor y0$descriptor() {
        return y0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static MethodHandle y0$handle() {
        return y0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static MemorySegment y0$address() {
        return y0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static double y0(double x0) {
        var mh$ = y0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __y0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__y0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __y0(double)
     * }
     */
    public static FunctionDescriptor __y0$descriptor() {
        return __y0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __y0(double)
     * }
     */
    public static MethodHandle __y0$handle() {
        return __y0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __y0(double)
     * }
     */
    public static MemorySegment __y0$address() {
        return __y0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __y0(double)
     * }
     */
    public static double __y0(double x0) {
        var mh$ = __y0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__y0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("y1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static FunctionDescriptor y1$descriptor() {
        return y1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static MethodHandle y1$handle() {
        return y1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static MemorySegment y1$address() {
        return y1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static double y1(double x0) {
        var mh$ = y1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __y1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__y1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __y1(double)
     * }
     */
    public static FunctionDescriptor __y1$descriptor() {
        return __y1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __y1(double)
     * }
     */
    public static MethodHandle __y1$handle() {
        return __y1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __y1(double)
     * }
     */
    public static MemorySegment __y1$address() {
        return __y1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __y1(double)
     * }
     */
    public static double __y1(double x0) {
        var mh$ = __y1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__y1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class yn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_INT,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("yn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static FunctionDescriptor yn$descriptor() {
        return yn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static MethodHandle yn$handle() {
        return yn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static MemorySegment yn$address() {
        return yn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static double yn(int x0, double x1) {
        var mh$ = yn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("yn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __yn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_INT,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__yn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __yn(int, double)
     * }
     */
    public static FunctionDescriptor __yn$descriptor() {
        return __yn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __yn(int, double)
     * }
     */
    public static MethodHandle __yn$handle() {
        return __yn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __yn(int, double)
     * }
     */
    public static MemorySegment __yn$address() {
        return __yn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __yn(int, double)
     * }
     */
    public static double __yn(int x0, double x1) {
        var mh$ = __yn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__yn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("erf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static FunctionDescriptor erf$descriptor() {
        return erf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static MethodHandle erf$handle() {
        return erf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static MemorySegment erf$address() {
        return erf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static double erf(double x0) {
        var mh$ = erf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erf", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __erf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__erf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __erf(double)
     * }
     */
    public static FunctionDescriptor __erf$descriptor() {
        return __erf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __erf(double)
     * }
     */
    public static MethodHandle __erf$handle() {
        return __erf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __erf(double)
     * }
     */
    public static MemorySegment __erf$address() {
        return __erf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __erf(double)
     * }
     */
    public static double __erf(double x0) {
        var mh$ = __erf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__erf", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("erfc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static FunctionDescriptor erfc$descriptor() {
        return erfc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static MethodHandle erfc$handle() {
        return erfc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static MemorySegment erfc$address() {
        return erfc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static double erfc(double x0) {
        var mh$ = erfc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfc", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __erfc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__erfc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __erfc(double)
     * }
     */
    public static FunctionDescriptor __erfc$descriptor() {
        return __erfc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __erfc(double)
     * }
     */
    public static MethodHandle __erfc$handle() {
        return __erfc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __erfc(double)
     * }
     */
    public static MemorySegment __erfc$address() {
        return __erfc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __erfc(double)
     * }
     */
    public static double __erfc(double x0) {
        var mh$ = __erfc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__erfc", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("lgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static FunctionDescriptor lgamma$descriptor() {
        return lgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static MethodHandle lgamma$handle() {
        return lgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static MemorySegment lgamma$address() {
        return lgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static double lgamma(double x0) {
        var mh$ = lgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__lgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __lgamma(double)
     * }
     */
    public static FunctionDescriptor __lgamma$descriptor() {
        return __lgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __lgamma(double)
     * }
     */
    public static MethodHandle __lgamma$handle() {
        return __lgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __lgamma(double)
     * }
     */
    public static MemorySegment __lgamma$address() {
        return __lgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __lgamma(double)
     * }
     */
    public static double __lgamma(double x0) {
        var mh$ = __lgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("tgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static FunctionDescriptor tgamma$descriptor() {
        return tgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static MethodHandle tgamma$handle() {
        return tgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static MemorySegment tgamma$address() {
        return tgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static double tgamma(double x0) {
        var mh$ = tgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__tgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __tgamma(double)
     * }
     */
    public static FunctionDescriptor __tgamma$descriptor() {
        return __tgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __tgamma(double)
     * }
     */
    public static MethodHandle __tgamma$handle() {
        return __tgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __tgamma(double)
     * }
     */
    public static MemorySegment __tgamma$address() {
        return __tgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __tgamma(double)
     * }
     */
    public static double __tgamma(double x0) {
        var mh$ = __tgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("gamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double gamma(double)
     * }
     */
    public static FunctionDescriptor gamma$descriptor() {
        return gamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double gamma(double)
     * }
     */
    public static MethodHandle gamma$handle() {
        return gamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double gamma(double)
     * }
     */
    public static MemorySegment gamma$address() {
        return gamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double gamma(double)
     * }
     */
    public static double gamma(double x0) {
        var mh$ = gamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__gamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __gamma(double)
     * }
     */
    public static FunctionDescriptor __gamma$descriptor() {
        return __gamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __gamma(double)
     * }
     */
    public static MethodHandle __gamma$handle() {
        return __gamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __gamma(double)
     * }
     */
    public static MemorySegment __gamma$address() {
        return __gamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __gamma(double)
     * }
     */
    public static double __gamma(double x0) {
        var mh$ = __gamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgamma_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("lgamma_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double lgamma_r(double, int *__signgamp)
     * }
     */
    public static FunctionDescriptor lgamma_r$descriptor() {
        return lgamma_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double lgamma_r(double, int *__signgamp)
     * }
     */
    public static MethodHandle lgamma_r$handle() {
        return lgamma_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double lgamma_r(double, int *__signgamp)
     * }
     */
    public static MemorySegment lgamma_r$address() {
        return lgamma_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double lgamma_r(double, int *__signgamp)
     * }
     */
    public static double lgamma_r(double x0, MemorySegment __signgamp) {
        var mh$ = lgamma_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgamma_r", x0, __signgamp);
            }
            return (double)mh$.invokeExact(x0, __signgamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lgamma_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("__lgamma_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __lgamma_r(double, int *__signgamp)
     * }
     */
    public static FunctionDescriptor __lgamma_r$descriptor() {
        return __lgamma_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __lgamma_r(double, int *__signgamp)
     * }
     */
    public static MethodHandle __lgamma_r$handle() {
        return __lgamma_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __lgamma_r(double, int *__signgamp)
     * }
     */
    public static MemorySegment __lgamma_r$address() {
        return __lgamma_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __lgamma_r(double, int *__signgamp)
     * }
     */
    public static double __lgamma_r(double x0, MemorySegment __signgamp) {
        var mh$ = __lgamma_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lgamma_r", x0, __signgamp);
            }
            return (double)mh$.invokeExact(x0, __signgamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("rint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double rint(double __x)
     * }
     */
    public static FunctionDescriptor rint$descriptor() {
        return rint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double rint(double __x)
     * }
     */
    public static MethodHandle rint$handle() {
        return rint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double rint(double __x)
     * }
     */
    public static MemorySegment rint$address() {
        return rint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double rint(double __x)
     * }
     */
    public static double rint(double __x) {
        var mh$ = rint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rint", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __rint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__rint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __rint(double __x)
     * }
     */
    public static FunctionDescriptor __rint$descriptor() {
        return __rint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __rint(double __x)
     * }
     */
    public static MethodHandle __rint$handle() {
        return __rint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __rint(double __x)
     * }
     */
    public static MemorySegment __rint$address() {
        return __rint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __rint(double __x)
     * }
     */
    public static double __rint(double __x) {
        var mh$ = __rint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__rint", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("nextafter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nextafter(double __x, double __y)
     * }
     */
    public static FunctionDescriptor nextafter$descriptor() {
        return nextafter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nextafter(double __x, double __y)
     * }
     */
    public static MethodHandle nextafter$handle() {
        return nextafter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nextafter(double __x, double __y)
     * }
     */
    public static MemorySegment nextafter$address() {
        return nextafter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nextafter(double __x, double __y)
     * }
     */
    public static double nextafter(double __x, double __y) {
        var mh$ = nextafter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafter", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __nextafter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__nextafter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __nextafter(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __nextafter$descriptor() {
        return __nextafter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __nextafter(double __x, double __y)
     * }
     */
    public static MethodHandle __nextafter$handle() {
        return __nextafter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __nextafter(double __x, double __y)
     * }
     */
    public static MemorySegment __nextafter$address() {
        return __nextafter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __nextafter(double __x, double __y)
     * }
     */
    public static double __nextafter(double __x, double __y) {
        var mh$ = __nextafter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__nextafter", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("remainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double remainder(double __x, double __y)
     * }
     */
    public static FunctionDescriptor remainder$descriptor() {
        return remainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double remainder(double __x, double __y)
     * }
     */
    public static MethodHandle remainder$handle() {
        return remainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double remainder(double __x, double __y)
     * }
     */
    public static MemorySegment remainder$address() {
        return remainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double remainder(double __x, double __y)
     * }
     */
    public static double remainder(double __x, double __y) {
        var mh$ = remainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainder", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __remainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__remainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __remainder(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __remainder$descriptor() {
        return __remainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __remainder(double __x, double __y)
     * }
     */
    public static MethodHandle __remainder$handle() {
        return __remainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __remainder(double __x, double __y)
     * }
     */
    public static MemorySegment __remainder$address() {
        return __remainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __remainder(double __x, double __y)
     * }
     */
    public static double __remainder(double __x, double __y) {
        var mh$ = __remainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__remainder", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("scalbn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalbn(double __x, int __n)
     * }
     */
    public static FunctionDescriptor scalbn$descriptor() {
        return scalbn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalbn(double __x, int __n)
     * }
     */
    public static MethodHandle scalbn$handle() {
        return scalbn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalbn(double __x, int __n)
     * }
     */
    public static MemorySegment scalbn$address() {
        return scalbn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalbn(double __x, int __n)
     * }
     */
    public static double scalbn(double __x, int __n) {
        var mh$ = scalbn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbn", __x, __n);
            }
            return (double)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __scalbn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__scalbn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __scalbn(double __x, int __n)
     * }
     */
    public static FunctionDescriptor __scalbn$descriptor() {
        return __scalbn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __scalbn(double __x, int __n)
     * }
     */
    public static MethodHandle __scalbn$handle() {
        return __scalbn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __scalbn(double __x, int __n)
     * }
     */
    public static MemorySegment __scalbn$address() {
        return __scalbn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __scalbn(double __x, int __n)
     * }
     */
    public static double __scalbn(double __x, int __n) {
        var mh$ = __scalbn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__scalbn", __x, __n);
            }
            return (double)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("ilogb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ilogb(double __x)
     * }
     */
    public static FunctionDescriptor ilogb$descriptor() {
        return ilogb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ilogb(double __x)
     * }
     */
    public static MethodHandle ilogb$handle() {
        return ilogb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ilogb(double __x)
     * }
     */
    public static MemorySegment ilogb$address() {
        return ilogb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ilogb(double __x)
     * }
     */
    public static int ilogb(double __x) {
        var mh$ = ilogb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogb", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ilogb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__ilogb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __ilogb(double __x)
     * }
     */
    public static FunctionDescriptor __ilogb$descriptor() {
        return __ilogb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __ilogb(double __x)
     * }
     */
    public static MethodHandle __ilogb$handle() {
        return __ilogb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __ilogb(double __x)
     * }
     */
    public static MemorySegment __ilogb$address() {
        return __ilogb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __ilogb(double __x)
     * }
     */
    public static int __ilogb(double __x) {
        var mh$ = __ilogb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ilogb", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_LONG
        );

        public static final MemorySegment ADDR = C.findOrThrow("scalbln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalbln(double __x, long __n)
     * }
     */
    public static FunctionDescriptor scalbln$descriptor() {
        return scalbln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalbln(double __x, long __n)
     * }
     */
    public static MethodHandle scalbln$handle() {
        return scalbln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalbln(double __x, long __n)
     * }
     */
    public static MemorySegment scalbln$address() {
        return scalbln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalbln(double __x, long __n)
     * }
     */
    public static double scalbln(double __x, long __n) {
        var mh$ = scalbln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbln", __x, __n);
            }
            return (double)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __scalbln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_LONG
        );

        public static final MemorySegment ADDR = C.findOrThrow("__scalbln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __scalbln(double __x, long __n)
     * }
     */
    public static FunctionDescriptor __scalbln$descriptor() {
        return __scalbln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __scalbln(double __x, long __n)
     * }
     */
    public static MethodHandle __scalbln$handle() {
        return __scalbln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __scalbln(double __x, long __n)
     * }
     */
    public static MemorySegment __scalbln$address() {
        return __scalbln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __scalbln(double __x, long __n)
     * }
     */
    public static double __scalbln(double __x, long __n) {
        var mh$ = __scalbln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__scalbln", __x, __n);
            }
            return (double)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("nearbyint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nearbyint(double __x)
     * }
     */
    public static FunctionDescriptor nearbyint$descriptor() {
        return nearbyint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nearbyint(double __x)
     * }
     */
    public static MethodHandle nearbyint$handle() {
        return nearbyint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nearbyint(double __x)
     * }
     */
    public static MemorySegment nearbyint$address() {
        return nearbyint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nearbyint(double __x)
     * }
     */
    public static double nearbyint(double __x) {
        var mh$ = nearbyint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyint", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __nearbyint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__nearbyint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __nearbyint(double __x)
     * }
     */
    public static FunctionDescriptor __nearbyint$descriptor() {
        return __nearbyint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __nearbyint(double __x)
     * }
     */
    public static MethodHandle __nearbyint$handle() {
        return __nearbyint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __nearbyint(double __x)
     * }
     */
    public static MemorySegment __nearbyint$address() {
        return __nearbyint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __nearbyint(double __x)
     * }
     */
    public static double __nearbyint(double __x) {
        var mh$ = __nearbyint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__nearbyint", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class round {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("round");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double round(double __x)
     * }
     */
    public static FunctionDescriptor round$descriptor() {
        return round.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double round(double __x)
     * }
     */
    public static MethodHandle round$handle() {
        return round.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double round(double __x)
     * }
     */
    public static MemorySegment round$address() {
        return round.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double round(double __x)
     * }
     */
    public static double round(double __x) {
        var mh$ = round.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("round", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __round {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__round");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __round(double __x)
     * }
     */
    public static FunctionDescriptor __round$descriptor() {
        return __round.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __round(double __x)
     * }
     */
    public static MethodHandle __round$handle() {
        return __round.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __round(double __x)
     * }
     */
    public static MemorySegment __round$address() {
        return __round.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __round(double __x)
     * }
     */
    public static double __round(double __x) {
        var mh$ = __round.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__round", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class trunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("trunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double trunc(double __x)
     * }
     */
    public static FunctionDescriptor trunc$descriptor() {
        return trunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double trunc(double __x)
     * }
     */
    public static MethodHandle trunc$handle() {
        return trunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double trunc(double __x)
     * }
     */
    public static MemorySegment trunc$address() {
        return trunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double trunc(double __x)
     * }
     */
    public static double trunc(double __x) {
        var mh$ = trunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("trunc", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __trunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__trunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __trunc(double __x)
     * }
     */
    public static FunctionDescriptor __trunc$descriptor() {
        return __trunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __trunc(double __x)
     * }
     */
    public static MethodHandle __trunc$handle() {
        return __trunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __trunc(double __x)
     * }
     */
    public static MemorySegment __trunc$address() {
        return __trunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __trunc(double __x)
     * }
     */
    public static double __trunc(double __x) {
        var mh$ = __trunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__trunc", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("remquo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double remquo(double __x, double __y, int *__quo)
     * }
     */
    public static FunctionDescriptor remquo$descriptor() {
        return remquo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double remquo(double __x, double __y, int *__quo)
     * }
     */
    public static MethodHandle remquo$handle() {
        return remquo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double remquo(double __x, double __y, int *__quo)
     * }
     */
    public static MemorySegment remquo$address() {
        return remquo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double remquo(double __x, double __y, int *__quo)
     * }
     */
    public static double remquo(double __x, double __y, MemorySegment __quo) {
        var mh$ = remquo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquo", __x, __y, __quo);
            }
            return (double)mh$.invokeExact(__x, __y, __quo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __remquo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("__remquo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __remquo(double __x, double __y, int *__quo)
     * }
     */
    public static FunctionDescriptor __remquo$descriptor() {
        return __remquo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __remquo(double __x, double __y, int *__quo)
     * }
     */
    public static MethodHandle __remquo$handle() {
        return __remquo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __remquo(double __x, double __y, int *__quo)
     * }
     */
    public static MemorySegment __remquo$address() {
        return __remquo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __remquo(double __x, double __y, int *__quo)
     * }
     */
    public static double __remquo(double __x, double __y, MemorySegment __quo) {
        var mh$ = __remquo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__remquo", __x, __y, __quo);
            }
            return (double)mh$.invokeExact(__x, __y, __quo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("lrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrint(double __x)
     * }
     */
    public static FunctionDescriptor lrint$descriptor() {
        return lrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrint(double __x)
     * }
     */
    public static MethodHandle lrint$handle() {
        return lrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrint(double __x)
     * }
     */
    public static MemorySegment lrint$address() {
        return lrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrint(double __x)
     * }
     */
    public static long lrint(double __x) {
        var mh$ = lrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrint", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__lrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long __lrint(double __x)
     * }
     */
    public static FunctionDescriptor __lrint$descriptor() {
        return __lrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long __lrint(double __x)
     * }
     */
    public static MethodHandle __lrint$handle() {
        return __lrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long __lrint(double __x)
     * }
     */
    public static MemorySegment __lrint$address() {
        return __lrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long __lrint(double __x)
     * }
     */
    public static long __lrint(double __x) {
        var mh$ = __lrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lrint", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG_LONG,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("llrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llrint(double __x)
     * }
     */
    public static FunctionDescriptor llrint$descriptor() {
        return llrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llrint(double __x)
     * }
     */
    public static MethodHandle llrint$handle() {
        return llrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llrint(double __x)
     * }
     */
    public static MemorySegment llrint$address() {
        return llrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llrint(double __x)
     * }
     */
    public static long llrint(double __x) {
        var mh$ = llrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrint", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __llrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG_LONG,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__llrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long __llrint(double __x)
     * }
     */
    public static FunctionDescriptor __llrint$descriptor() {
        return __llrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long __llrint(double __x)
     * }
     */
    public static MethodHandle __llrint$handle() {
        return __llrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long __llrint(double __x)
     * }
     */
    public static MemorySegment __llrint$address() {
        return __llrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long __llrint(double __x)
     * }
     */
    public static long __llrint(double __x) {
        var mh$ = __llrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__llrint", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("lround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lround(double __x)
     * }
     */
    public static FunctionDescriptor lround$descriptor() {
        return lround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lround(double __x)
     * }
     */
    public static MethodHandle lround$handle() {
        return lround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lround(double __x)
     * }
     */
    public static MemorySegment lround$address() {
        return lround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lround(double __x)
     * }
     */
    public static long lround(double __x) {
        var mh$ = lround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lround", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__lround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long __lround(double __x)
     * }
     */
    public static FunctionDescriptor __lround$descriptor() {
        return __lround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long __lround(double __x)
     * }
     */
    public static MethodHandle __lround$handle() {
        return __lround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long __lround(double __x)
     * }
     */
    public static MemorySegment __lround$address() {
        return __lround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long __lround(double __x)
     * }
     */
    public static long __lround(double __x) {
        var mh$ = __lround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lround", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG_LONG,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("llround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llround(double __x)
     * }
     */
    public static FunctionDescriptor llround$descriptor() {
        return llround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llround(double __x)
     * }
     */
    public static MethodHandle llround$handle() {
        return llround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llround(double __x)
     * }
     */
    public static MemorySegment llround$address() {
        return llround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llround(double __x)
     * }
     */
    public static long llround(double __x) {
        var mh$ = llround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llround", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __llround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG_LONG,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__llround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long __llround(double __x)
     * }
     */
    public static FunctionDescriptor __llround$descriptor() {
        return __llround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long __llround(double __x)
     * }
     */
    public static MethodHandle __llround$handle() {
        return __llround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long __llround(double __x)
     * }
     */
    public static MemorySegment __llround$address() {
        return __llround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long __llround(double __x)
     * }
     */
    public static long __llround(double __x) {
        var mh$ = __llround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__llround", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("fdim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fdim(double __x, double __y)
     * }
     */
    public static FunctionDescriptor fdim$descriptor() {
        return fdim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fdim(double __x, double __y)
     * }
     */
    public static MethodHandle fdim$handle() {
        return fdim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fdim(double __x, double __y)
     * }
     */
    public static MemorySegment fdim$address() {
        return fdim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fdim(double __x, double __y)
     * }
     */
    public static double fdim(double __x, double __y) {
        var mh$ = fdim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdim", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fdim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__fdim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __fdim(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __fdim$descriptor() {
        return __fdim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __fdim(double __x, double __y)
     * }
     */
    public static MethodHandle __fdim$handle() {
        return __fdim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __fdim(double __x, double __y)
     * }
     */
    public static MemorySegment __fdim$address() {
        return __fdim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __fdim(double __x, double __y)
     * }
     */
    public static double __fdim(double __x, double __y) {
        var mh$ = __fdim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fdim", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("fmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmax(double __x, double __y)
     * }
     */
    public static FunctionDescriptor fmax$descriptor() {
        return fmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmax(double __x, double __y)
     * }
     */
    public static MethodHandle fmax$handle() {
        return fmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmax(double __x, double __y)
     * }
     */
    public static MemorySegment fmax$address() {
        return fmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmax(double __x, double __y)
     * }
     */
    public static double fmax(double __x, double __y) {
        var mh$ = fmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmax", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__fmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __fmax(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __fmax$descriptor() {
        return __fmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __fmax(double __x, double __y)
     * }
     */
    public static MethodHandle __fmax$handle() {
        return __fmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __fmax(double __x, double __y)
     * }
     */
    public static MemorySegment __fmax$address() {
        return __fmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __fmax(double __x, double __y)
     * }
     */
    public static double __fmax(double __x, double __y) {
        var mh$ = __fmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fmax", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("fmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmin(double __x, double __y)
     * }
     */
    public static FunctionDescriptor fmin$descriptor() {
        return fmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmin(double __x, double __y)
     * }
     */
    public static MethodHandle fmin$handle() {
        return fmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmin(double __x, double __y)
     * }
     */
    public static MemorySegment fmin$address() {
        return fmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmin(double __x, double __y)
     * }
     */
    public static double fmin(double __x, double __y) {
        var mh$ = fmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmin", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__fmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __fmin(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __fmin$descriptor() {
        return __fmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __fmin(double __x, double __y)
     * }
     */
    public static MethodHandle __fmin$handle() {
        return __fmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __fmin(double __x, double __y)
     * }
     */
    public static MemorySegment __fmin$address() {
        return __fmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __fmin(double __x, double __y)
     * }
     */
    public static double __fmin(double __x, double __y) {
        var mh$ = __fmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fmin", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("fma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fma(double __x, double __y, double __z)
     * }
     */
    public static FunctionDescriptor fma$descriptor() {
        return fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fma(double __x, double __y, double __z)
     * }
     */
    public static MethodHandle fma$handle() {
        return fma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fma(double __x, double __y, double __z)
     * }
     */
    public static MemorySegment fma$address() {
        return fma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fma(double __x, double __y, double __z)
     * }
     */
    public static double fma(double __x, double __y, double __z) {
        var mh$ = fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fma", __x, __y, __z);
            }
            return (double)mh$.invokeExact(__x, __y, __z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__fma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __fma(double __x, double __y, double __z)
     * }
     */
    public static FunctionDescriptor __fma$descriptor() {
        return __fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __fma(double __x, double __y, double __z)
     * }
     */
    public static MethodHandle __fma$handle() {
        return __fma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __fma(double __x, double __y, double __z)
     * }
     */
    public static MemorySegment __fma$address() {
        return __fma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __fma(double __x, double __y, double __z)
     * }
     */
    public static double __fma(double __x, double __y, double __z) {
        var mh$ = __fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fma", __x, __y, __z);
            }
            return (double)mh$.invokeExact(__x, __y, __z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("scalb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalb(double __x, double __n)
     * }
     */
    public static FunctionDescriptor scalb$descriptor() {
        return scalb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalb(double __x, double __n)
     * }
     */
    public static MethodHandle scalb$handle() {
        return scalb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalb(double __x, double __n)
     * }
     */
    public static MemorySegment scalb$address() {
        return scalb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalb(double __x, double __n)
     * }
     */
    public static double scalb(double __x, double __n) {
        var mh$ = scalb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalb", __x, __n);
            }
            return (double)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __scalb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_DOUBLE,
            C.C_DOUBLE,
            C.C_DOUBLE
        );

        public static final MemorySegment ADDR = C.findOrThrow("__scalb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __scalb(double __x, double __n)
     * }
     */
    public static FunctionDescriptor __scalb$descriptor() {
        return __scalb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __scalb(double __x, double __n)
     * }
     */
    public static MethodHandle __scalb$handle() {
        return __scalb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __scalb(double __x, double __n)
     * }
     */
    public static MemorySegment __scalb$address() {
        return __scalb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __scalb(double __x, double __n)
     * }
     */
    public static double __scalb(double __x, double __n) {
        var mh$ = __scalb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__scalb", __x, __n);
            }
            return (double)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fpclassifyf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__fpclassifyf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float __value)
     * }
     */
    public static FunctionDescriptor __fpclassifyf$descriptor() {
        return __fpclassifyf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float __value)
     * }
     */
    public static MethodHandle __fpclassifyf$handle() {
        return __fpclassifyf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float __value)
     * }
     */
    public static MemorySegment __fpclassifyf$address() {
        return __fpclassifyf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __fpclassifyf(float __value)
     * }
     */
    public static int __fpclassifyf(float __value) {
        var mh$ = __fpclassifyf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fpclassifyf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __signbitf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__signbitf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __signbitf(float __value)
     * }
     */
    public static FunctionDescriptor __signbitf$descriptor() {
        return __signbitf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __signbitf(float __value)
     * }
     */
    public static MethodHandle __signbitf$handle() {
        return __signbitf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __signbitf(float __value)
     * }
     */
    public static MemorySegment __signbitf$address() {
        return __signbitf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __signbitf(float __value)
     * }
     */
    public static int __signbitf(float __value) {
        var mh$ = __signbitf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__signbitf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __isinff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__isinff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __isinff(float __value)
     * }
     */
    public static FunctionDescriptor __isinff$descriptor() {
        return __isinff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __isinff(float __value)
     * }
     */
    public static MethodHandle __isinff$handle() {
        return __isinff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __isinff(float __value)
     * }
     */
    public static MemorySegment __isinff$address() {
        return __isinff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __isinff(float __value)
     * }
     */
    public static int __isinff(float __value) {
        var mh$ = __isinff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__isinff", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __finitef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__finitef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __finitef(float __value)
     * }
     */
    public static FunctionDescriptor __finitef$descriptor() {
        return __finitef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __finitef(float __value)
     * }
     */
    public static MethodHandle __finitef$handle() {
        return __finitef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __finitef(float __value)
     * }
     */
    public static MemorySegment __finitef$address() {
        return __finitef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __finitef(float __value)
     * }
     */
    public static int __finitef(float __value) {
        var mh$ = __finitef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__finitef", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __isnanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__isnanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __isnanf(float __value)
     * }
     */
    public static FunctionDescriptor __isnanf$descriptor() {
        return __isnanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __isnanf(float __value)
     * }
     */
    public static MethodHandle __isnanf$handle() {
        return __isnanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __isnanf(float __value)
     * }
     */
    public static MemorySegment __isnanf$address() {
        return __isnanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __isnanf(float __value)
     * }
     */
    public static int __isnanf(float __value) {
        var mh$ = __isnanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__isnanf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __iseqsigf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__iseqsigf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __iseqsigf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __iseqsigf$descriptor() {
        return __iseqsigf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __iseqsigf(float __x, float __y)
     * }
     */
    public static MethodHandle __iseqsigf$handle() {
        return __iseqsigf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __iseqsigf(float __x, float __y)
     * }
     */
    public static MemorySegment __iseqsigf$address() {
        return __iseqsigf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __iseqsigf(float __x, float __y)
     * }
     */
    public static int __iseqsigf(float __x, float __y) {
        var mh$ = __iseqsigf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__iseqsigf", __x, __y);
            }
            return (int)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __issignalingf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__issignalingf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __issignalingf(float __value)
     * }
     */
    public static FunctionDescriptor __issignalingf$descriptor() {
        return __issignalingf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __issignalingf(float __value)
     * }
     */
    public static MethodHandle __issignalingf$handle() {
        return __issignalingf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __issignalingf(float __value)
     * }
     */
    public static MemorySegment __issignalingf$address() {
        return __issignalingf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __issignalingf(float __value)
     * }
     */
    public static int __issignalingf(float __value) {
        var mh$ = __issignalingf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__issignalingf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("acosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float acosf(float __x)
     * }
     */
    public static FunctionDescriptor acosf$descriptor() {
        return acosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float acosf(float __x)
     * }
     */
    public static MethodHandle acosf$handle() {
        return acosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float acosf(float __x)
     * }
     */
    public static MemorySegment acosf$address() {
        return acosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float acosf(float __x)
     * }
     */
    public static float acosf(float __x) {
        var mh$ = acosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __acosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__acosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __acosf(float __x)
     * }
     */
    public static FunctionDescriptor __acosf$descriptor() {
        return __acosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __acosf(float __x)
     * }
     */
    public static MethodHandle __acosf$handle() {
        return __acosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __acosf(float __x)
     * }
     */
    public static MemorySegment __acosf$address() {
        return __acosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __acosf(float __x)
     * }
     */
    public static float __acosf(float __x) {
        var mh$ = __acosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__acosf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("asinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float asinf(float __x)
     * }
     */
    public static FunctionDescriptor asinf$descriptor() {
        return asinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float asinf(float __x)
     * }
     */
    public static MethodHandle asinf$handle() {
        return asinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float asinf(float __x)
     * }
     */
    public static MemorySegment asinf$address() {
        return asinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float asinf(float __x)
     * }
     */
    public static float asinf(float __x) {
        var mh$ = asinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __asinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__asinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __asinf(float __x)
     * }
     */
    public static FunctionDescriptor __asinf$descriptor() {
        return __asinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __asinf(float __x)
     * }
     */
    public static MethodHandle __asinf$handle() {
        return __asinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __asinf(float __x)
     * }
     */
    public static MemorySegment __asinf$address() {
        return __asinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __asinf(float __x)
     * }
     */
    public static float __asinf(float __x) {
        var mh$ = __asinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__asinf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("atanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atanf(float __x)
     * }
     */
    public static FunctionDescriptor atanf$descriptor() {
        return atanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atanf(float __x)
     * }
     */
    public static MethodHandle atanf$handle() {
        return atanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atanf(float __x)
     * }
     */
    public static MemorySegment atanf$address() {
        return atanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atanf(float __x)
     * }
     */
    public static float atanf(float __x) {
        var mh$ = atanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __atanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__atanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __atanf(float __x)
     * }
     */
    public static FunctionDescriptor __atanf$descriptor() {
        return __atanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __atanf(float __x)
     * }
     */
    public static MethodHandle __atanf$handle() {
        return __atanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __atanf(float __x)
     * }
     */
    public static MemorySegment __atanf$address() {
        return __atanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __atanf(float __x)
     * }
     */
    public static float __atanf(float __x) {
        var mh$ = __atanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__atanf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("atan2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atan2f(float __y, float __x)
     * }
     */
    public static FunctionDescriptor atan2f$descriptor() {
        return atan2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atan2f(float __y, float __x)
     * }
     */
    public static MethodHandle atan2f$handle() {
        return atan2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atan2f(float __y, float __x)
     * }
     */
    public static MemorySegment atan2f$address() {
        return atan2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atan2f(float __y, float __x)
     * }
     */
    public static float atan2f(float __y, float __x) {
        var mh$ = atan2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2f", __y, __x);
            }
            return (float)mh$.invokeExact(__y, __x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __atan2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__atan2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __atan2f(float __y, float __x)
     * }
     */
    public static FunctionDescriptor __atan2f$descriptor() {
        return __atan2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __atan2f(float __y, float __x)
     * }
     */
    public static MethodHandle __atan2f$handle() {
        return __atan2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __atan2f(float __y, float __x)
     * }
     */
    public static MemorySegment __atan2f$address() {
        return __atan2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __atan2f(float __y, float __x)
     * }
     */
    public static float __atan2f(float __y, float __x) {
        var mh$ = __atan2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__atan2f", __y, __x);
            }
            return (float)mh$.invokeExact(__y, __x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("cosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cosf(float __x)
     * }
     */
    public static FunctionDescriptor cosf$descriptor() {
        return cosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cosf(float __x)
     * }
     */
    public static MethodHandle cosf$handle() {
        return cosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cosf(float __x)
     * }
     */
    public static MemorySegment cosf$address() {
        return cosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cosf(float __x)
     * }
     */
    public static float cosf(float __x) {
        var mh$ = cosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__cosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cosf(float __x)
     * }
     */
    public static FunctionDescriptor __cosf$descriptor() {
        return __cosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cosf(float __x)
     * }
     */
    public static MethodHandle __cosf$handle() {
        return __cosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cosf(float __x)
     * }
     */
    public static MemorySegment __cosf$address() {
        return __cosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cosf(float __x)
     * }
     */
    public static float __cosf(float __x) {
        var mh$ = __cosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cosf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("sinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sinf(float __x)
     * }
     */
    public static FunctionDescriptor sinf$descriptor() {
        return sinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sinf(float __x)
     * }
     */
    public static MethodHandle sinf$handle() {
        return sinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sinf(float __x)
     * }
     */
    public static MemorySegment sinf$address() {
        return sinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sinf(float __x)
     * }
     */
    public static float sinf(float __x) {
        var mh$ = sinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__sinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __sinf(float __x)
     * }
     */
    public static FunctionDescriptor __sinf$descriptor() {
        return __sinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __sinf(float __x)
     * }
     */
    public static MethodHandle __sinf$handle() {
        return __sinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __sinf(float __x)
     * }
     */
    public static MemorySegment __sinf$address() {
        return __sinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __sinf(float __x)
     * }
     */
    public static float __sinf(float __x) {
        var mh$ = __sinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sinf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("tanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tanf(float __x)
     * }
     */
    public static FunctionDescriptor tanf$descriptor() {
        return tanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tanf(float __x)
     * }
     */
    public static MethodHandle tanf$handle() {
        return tanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tanf(float __x)
     * }
     */
    public static MemorySegment tanf$address() {
        return tanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tanf(float __x)
     * }
     */
    public static float tanf(float __x) {
        var mh$ = tanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__tanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __tanf(float __x)
     * }
     */
    public static FunctionDescriptor __tanf$descriptor() {
        return __tanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __tanf(float __x)
     * }
     */
    public static MethodHandle __tanf$handle() {
        return __tanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __tanf(float __x)
     * }
     */
    public static MemorySegment __tanf$address() {
        return __tanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __tanf(float __x)
     * }
     */
    public static float __tanf(float __x) {
        var mh$ = __tanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tanf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class coshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("coshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float coshf(float __x)
     * }
     */
    public static FunctionDescriptor coshf$descriptor() {
        return coshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float coshf(float __x)
     * }
     */
    public static MethodHandle coshf$handle() {
        return coshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float coshf(float __x)
     * }
     */
    public static MemorySegment coshf$address() {
        return coshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float coshf(float __x)
     * }
     */
    public static float coshf(float __x) {
        var mh$ = coshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("coshf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __coshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__coshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __coshf(float __x)
     * }
     */
    public static FunctionDescriptor __coshf$descriptor() {
        return __coshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __coshf(float __x)
     * }
     */
    public static MethodHandle __coshf$handle() {
        return __coshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __coshf(float __x)
     * }
     */
    public static MemorySegment __coshf$address() {
        return __coshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __coshf(float __x)
     * }
     */
    public static float __coshf(float __x) {
        var mh$ = __coshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__coshf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("sinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sinhf(float __x)
     * }
     */
    public static FunctionDescriptor sinhf$descriptor() {
        return sinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sinhf(float __x)
     * }
     */
    public static MethodHandle sinhf$handle() {
        return sinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sinhf(float __x)
     * }
     */
    public static MemorySegment sinhf$address() {
        return sinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sinhf(float __x)
     * }
     */
    public static float sinhf(float __x) {
        var mh$ = sinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__sinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __sinhf(float __x)
     * }
     */
    public static FunctionDescriptor __sinhf$descriptor() {
        return __sinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __sinhf(float __x)
     * }
     */
    public static MethodHandle __sinhf$handle() {
        return __sinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __sinhf(float __x)
     * }
     */
    public static MemorySegment __sinhf$address() {
        return __sinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __sinhf(float __x)
     * }
     */
    public static float __sinhf(float __x) {
        var mh$ = __sinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sinhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("tanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tanhf(float __x)
     * }
     */
    public static FunctionDescriptor tanhf$descriptor() {
        return tanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tanhf(float __x)
     * }
     */
    public static MethodHandle tanhf$handle() {
        return tanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tanhf(float __x)
     * }
     */
    public static MemorySegment tanhf$address() {
        return tanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tanhf(float __x)
     * }
     */
    public static float tanhf(float __x) {
        var mh$ = tanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__tanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __tanhf(float __x)
     * }
     */
    public static FunctionDescriptor __tanhf$descriptor() {
        return __tanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __tanhf(float __x)
     * }
     */
    public static MethodHandle __tanhf$handle() {
        return __tanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __tanhf(float __x)
     * }
     */
    public static MemorySegment __tanhf$address() {
        return __tanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __tanhf(float __x)
     * }
     */
    public static float __tanhf(float __x) {
        var mh$ = __tanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tanhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("acoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float acoshf(float __x)
     * }
     */
    public static FunctionDescriptor acoshf$descriptor() {
        return acoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float acoshf(float __x)
     * }
     */
    public static MethodHandle acoshf$handle() {
        return acoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float acoshf(float __x)
     * }
     */
    public static MemorySegment acoshf$address() {
        return acoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float acoshf(float __x)
     * }
     */
    public static float acoshf(float __x) {
        var mh$ = acoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acoshf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __acoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__acoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __acoshf(float __x)
     * }
     */
    public static FunctionDescriptor __acoshf$descriptor() {
        return __acoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __acoshf(float __x)
     * }
     */
    public static MethodHandle __acoshf$handle() {
        return __acoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __acoshf(float __x)
     * }
     */
    public static MemorySegment __acoshf$address() {
        return __acoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __acoshf(float __x)
     * }
     */
    public static float __acoshf(float __x) {
        var mh$ = __acoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__acoshf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("asinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float asinhf(float __x)
     * }
     */
    public static FunctionDescriptor asinhf$descriptor() {
        return asinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float asinhf(float __x)
     * }
     */
    public static MethodHandle asinhf$handle() {
        return asinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float asinhf(float __x)
     * }
     */
    public static MemorySegment asinhf$address() {
        return asinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float asinhf(float __x)
     * }
     */
    public static float asinhf(float __x) {
        var mh$ = asinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __asinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__asinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __asinhf(float __x)
     * }
     */
    public static FunctionDescriptor __asinhf$descriptor() {
        return __asinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __asinhf(float __x)
     * }
     */
    public static MethodHandle __asinhf$handle() {
        return __asinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __asinhf(float __x)
     * }
     */
    public static MemorySegment __asinhf$address() {
        return __asinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __asinhf(float __x)
     * }
     */
    public static float __asinhf(float __x) {
        var mh$ = __asinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__asinhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("atanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atanhf(float __x)
     * }
     */
    public static FunctionDescriptor atanhf$descriptor() {
        return atanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atanhf(float __x)
     * }
     */
    public static MethodHandle atanhf$handle() {
        return atanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atanhf(float __x)
     * }
     */
    public static MemorySegment atanhf$address() {
        return atanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atanhf(float __x)
     * }
     */
    public static float atanhf(float __x) {
        var mh$ = atanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __atanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__atanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __atanhf(float __x)
     * }
     */
    public static FunctionDescriptor __atanhf$descriptor() {
        return __atanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __atanhf(float __x)
     * }
     */
    public static MethodHandle __atanhf$handle() {
        return __atanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __atanhf(float __x)
     * }
     */
    public static MemorySegment __atanhf$address() {
        return __atanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __atanhf(float __x)
     * }
     */
    public static float __atanhf(float __x) {
        var mh$ = __atanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__atanhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("expf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float expf(float __x)
     * }
     */
    public static FunctionDescriptor expf$descriptor() {
        return expf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float expf(float __x)
     * }
     */
    public static MethodHandle expf$handle() {
        return expf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float expf(float __x)
     * }
     */
    public static MemorySegment expf$address() {
        return expf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float expf(float __x)
     * }
     */
    public static float expf(float __x) {
        var mh$ = expf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __expf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__expf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __expf(float __x)
     * }
     */
    public static FunctionDescriptor __expf$descriptor() {
        return __expf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __expf(float __x)
     * }
     */
    public static MethodHandle __expf$handle() {
        return __expf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __expf(float __x)
     * }
     */
    public static MemorySegment __expf$address() {
        return __expf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __expf(float __x)
     * }
     */
    public static float __expf(float __x) {
        var mh$ = __expf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__expf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class frexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("frexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float frexpf(float __x, int *__exponent)
     * }
     */
    public static FunctionDescriptor frexpf$descriptor() {
        return frexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float frexpf(float __x, int *__exponent)
     * }
     */
    public static MethodHandle frexpf$handle() {
        return frexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float frexpf(float __x, int *__exponent)
     * }
     */
    public static MemorySegment frexpf$address() {
        return frexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float frexpf(float __x, int *__exponent)
     * }
     */
    public static float frexpf(float __x, MemorySegment __exponent) {
        var mh$ = frexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("frexpf", __x, __exponent);
            }
            return (float)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __frexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("__frexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __frexpf(float __x, int *__exponent)
     * }
     */
    public static FunctionDescriptor __frexpf$descriptor() {
        return __frexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __frexpf(float __x, int *__exponent)
     * }
     */
    public static MethodHandle __frexpf$handle() {
        return __frexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __frexpf(float __x, int *__exponent)
     * }
     */
    public static MemorySegment __frexpf$address() {
        return __frexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __frexpf(float __x, int *__exponent)
     * }
     */
    public static float __frexpf(float __x, MemorySegment __exponent) {
        var mh$ = __frexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__frexpf", __x, __exponent);
            }
            return (float)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("ldexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ldexpf(float __x, int __exponent)
     * }
     */
    public static FunctionDescriptor ldexpf$descriptor() {
        return ldexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ldexpf(float __x, int __exponent)
     * }
     */
    public static MethodHandle ldexpf$handle() {
        return ldexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ldexpf(float __x, int __exponent)
     * }
     */
    public static MemorySegment ldexpf$address() {
        return ldexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ldexpf(float __x, int __exponent)
     * }
     */
    public static float ldexpf(float __x, int __exponent) {
        var mh$ = ldexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldexpf", __x, __exponent);
            }
            return (float)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ldexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__ldexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __ldexpf(float __x, int __exponent)
     * }
     */
    public static FunctionDescriptor __ldexpf$descriptor() {
        return __ldexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __ldexpf(float __x, int __exponent)
     * }
     */
    public static MethodHandle __ldexpf$handle() {
        return __ldexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __ldexpf(float __x, int __exponent)
     * }
     */
    public static MemorySegment __ldexpf$address() {
        return __ldexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __ldexpf(float __x, int __exponent)
     * }
     */
    public static float __ldexpf(float __x, int __exponent) {
        var mh$ = __ldexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ldexpf", __x, __exponent);
            }
            return (float)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("logf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float logf(float __x)
     * }
     */
    public static FunctionDescriptor logf$descriptor() {
        return logf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float logf(float __x)
     * }
     */
    public static MethodHandle logf$handle() {
        return logf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float logf(float __x)
     * }
     */
    public static MemorySegment logf$address() {
        return logf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float logf(float __x)
     * }
     */
    public static float logf(float __x) {
        var mh$ = logf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __logf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__logf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __logf(float __x)
     * }
     */
    public static FunctionDescriptor __logf$descriptor() {
        return __logf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __logf(float __x)
     * }
     */
    public static MethodHandle __logf$handle() {
        return __logf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __logf(float __x)
     * }
     */
    public static MemorySegment __logf$address() {
        return __logf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __logf(float __x)
     * }
     */
    public static float __logf(float __x) {
        var mh$ = __logf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__logf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("log10f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log10f(float __x)
     * }
     */
    public static FunctionDescriptor log10f$descriptor() {
        return log10f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log10f(float __x)
     * }
     */
    public static MethodHandle log10f$handle() {
        return log10f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log10f(float __x)
     * }
     */
    public static MemorySegment log10f$address() {
        return log10f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log10f(float __x)
     * }
     */
    public static float log10f(float __x) {
        var mh$ = log10f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log10f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__log10f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __log10f(float __x)
     * }
     */
    public static FunctionDescriptor __log10f$descriptor() {
        return __log10f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __log10f(float __x)
     * }
     */
    public static MethodHandle __log10f$handle() {
        return __log10f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __log10f(float __x)
     * }
     */
    public static MemorySegment __log10f$address() {
        return __log10f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __log10f(float __x)
     * }
     */
    public static float __log10f(float __x) {
        var mh$ = __log10f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log10f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("modff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float modff(float __x, float *__iptr)
     * }
     */
    public static FunctionDescriptor modff$descriptor() {
        return modff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float modff(float __x, float *__iptr)
     * }
     */
    public static MethodHandle modff$handle() {
        return modff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float modff(float __x, float *__iptr)
     * }
     */
    public static MemorySegment modff$address() {
        return modff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float modff(float __x, float *__iptr)
     * }
     */
    public static float modff(float __x, MemorySegment __iptr) {
        var mh$ = modff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modff", __x, __iptr);
            }
            return (float)mh$.invokeExact(__x, __iptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __modff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("__modff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __modff(float __x, float *__iptr)
     * }
     */
    public static FunctionDescriptor __modff$descriptor() {
        return __modff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __modff(float __x, float *__iptr)
     * }
     */
    public static MethodHandle __modff$handle() {
        return __modff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __modff(float __x, float *__iptr)
     * }
     */
    public static MemorySegment __modff$address() {
        return __modff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __modff(float __x, float *__iptr)
     * }
     */
    public static float __modff(float __x, MemorySegment __iptr) {
        var mh$ = __modff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__modff", __x, __iptr);
            }
            return (float)mh$.invokeExact(__x, __iptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("expm1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float expm1f(float __x)
     * }
     */
    public static FunctionDescriptor expm1f$descriptor() {
        return expm1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float expm1f(float __x)
     * }
     */
    public static MethodHandle expm1f$handle() {
        return expm1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float expm1f(float __x)
     * }
     */
    public static MemorySegment expm1f$address() {
        return expm1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float expm1f(float __x)
     * }
     */
    public static float expm1f(float __x) {
        var mh$ = expm1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __expm1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__expm1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __expm1f(float __x)
     * }
     */
    public static FunctionDescriptor __expm1f$descriptor() {
        return __expm1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __expm1f(float __x)
     * }
     */
    public static MethodHandle __expm1f$handle() {
        return __expm1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __expm1f(float __x)
     * }
     */
    public static MemorySegment __expm1f$address() {
        return __expm1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __expm1f(float __x)
     * }
     */
    public static float __expm1f(float __x) {
        var mh$ = __expm1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__expm1f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1pf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("log1pf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log1pf(float __x)
     * }
     */
    public static FunctionDescriptor log1pf$descriptor() {
        return log1pf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log1pf(float __x)
     * }
     */
    public static MethodHandle log1pf$handle() {
        return log1pf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log1pf(float __x)
     * }
     */
    public static MemorySegment log1pf$address() {
        return log1pf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log1pf(float __x)
     * }
     */
    public static float log1pf(float __x) {
        var mh$ = log1pf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1pf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log1pf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__log1pf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __log1pf(float __x)
     * }
     */
    public static FunctionDescriptor __log1pf$descriptor() {
        return __log1pf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __log1pf(float __x)
     * }
     */
    public static MethodHandle __log1pf$handle() {
        return __log1pf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __log1pf(float __x)
     * }
     */
    public static MemorySegment __log1pf$address() {
        return __log1pf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __log1pf(float __x)
     * }
     */
    public static float __log1pf(float __x) {
        var mh$ = __log1pf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log1pf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("logbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float logbf(float __x)
     * }
     */
    public static FunctionDescriptor logbf$descriptor() {
        return logbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float logbf(float __x)
     * }
     */
    public static MethodHandle logbf$handle() {
        return logbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float logbf(float __x)
     * }
     */
    public static MemorySegment logbf$address() {
        return logbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float logbf(float __x)
     * }
     */
    public static float logbf(float __x) {
        var mh$ = logbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logbf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __logbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__logbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __logbf(float __x)
     * }
     */
    public static FunctionDescriptor __logbf$descriptor() {
        return __logbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __logbf(float __x)
     * }
     */
    public static MethodHandle __logbf$handle() {
        return __logbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __logbf(float __x)
     * }
     */
    public static MemorySegment __logbf$address() {
        return __logbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __logbf(float __x)
     * }
     */
    public static float __logbf(float __x) {
        var mh$ = __logbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__logbf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("exp2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float exp2f(float __x)
     * }
     */
    public static FunctionDescriptor exp2f$descriptor() {
        return exp2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float exp2f(float __x)
     * }
     */
    public static MethodHandle exp2f$handle() {
        return exp2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float exp2f(float __x)
     * }
     */
    public static MemorySegment exp2f$address() {
        return exp2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float exp2f(float __x)
     * }
     */
    public static float exp2f(float __x) {
        var mh$ = exp2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __exp2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__exp2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __exp2f(float __x)
     * }
     */
    public static FunctionDescriptor __exp2f$descriptor() {
        return __exp2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __exp2f(float __x)
     * }
     */
    public static MethodHandle __exp2f$handle() {
        return __exp2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __exp2f(float __x)
     * }
     */
    public static MemorySegment __exp2f$address() {
        return __exp2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __exp2f(float __x)
     * }
     */
    public static float __exp2f(float __x) {
        var mh$ = __exp2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__exp2f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("log2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log2f(float __x)
     * }
     */
    public static FunctionDescriptor log2f$descriptor() {
        return log2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log2f(float __x)
     * }
     */
    public static MethodHandle log2f$handle() {
        return log2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log2f(float __x)
     * }
     */
    public static MemorySegment log2f$address() {
        return log2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log2f(float __x)
     * }
     */
    public static float log2f(float __x) {
        var mh$ = log2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__log2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __log2f(float __x)
     * }
     */
    public static FunctionDescriptor __log2f$descriptor() {
        return __log2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __log2f(float __x)
     * }
     */
    public static MethodHandle __log2f$handle() {
        return __log2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __log2f(float __x)
     * }
     */
    public static MemorySegment __log2f$address() {
        return __log2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __log2f(float __x)
     * }
     */
    public static float __log2f(float __x) {
        var mh$ = __log2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log2f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class powf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("powf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float powf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor powf$descriptor() {
        return powf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float powf(float __x, float __y)
     * }
     */
    public static MethodHandle powf$handle() {
        return powf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float powf(float __x, float __y)
     * }
     */
    public static MemorySegment powf$address() {
        return powf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float powf(float __x, float __y)
     * }
     */
    public static float powf(float __x, float __y) {
        var mh$ = powf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("powf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __powf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__powf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __powf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __powf$descriptor() {
        return __powf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __powf(float __x, float __y)
     * }
     */
    public static MethodHandle __powf$handle() {
        return __powf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __powf(float __x, float __y)
     * }
     */
    public static MemorySegment __powf$address() {
        return __powf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __powf(float __x, float __y)
     * }
     */
    public static float __powf(float __x, float __y) {
        var mh$ = __powf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__powf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("sqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sqrtf(float __x)
     * }
     */
    public static FunctionDescriptor sqrtf$descriptor() {
        return sqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sqrtf(float __x)
     * }
     */
    public static MethodHandle sqrtf$handle() {
        return sqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sqrtf(float __x)
     * }
     */
    public static MemorySegment sqrtf$address() {
        return sqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sqrtf(float __x)
     * }
     */
    public static float sqrtf(float __x) {
        var mh$ = sqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrtf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__sqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __sqrtf(float __x)
     * }
     */
    public static FunctionDescriptor __sqrtf$descriptor() {
        return __sqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __sqrtf(float __x)
     * }
     */
    public static MethodHandle __sqrtf$handle() {
        return __sqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __sqrtf(float __x)
     * }
     */
    public static MemorySegment __sqrtf$address() {
        return __sqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __sqrtf(float __x)
     * }
     */
    public static float __sqrtf(float __x) {
        var mh$ = __sqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sqrtf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hypotf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("hypotf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float hypotf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor hypotf$descriptor() {
        return hypotf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float hypotf(float __x, float __y)
     * }
     */
    public static MethodHandle hypotf$handle() {
        return hypotf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float hypotf(float __x, float __y)
     * }
     */
    public static MemorySegment hypotf$address() {
        return hypotf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float hypotf(float __x, float __y)
     * }
     */
    public static float hypotf(float __x, float __y) {
        var mh$ = hypotf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hypotf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __hypotf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__hypotf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __hypotf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __hypotf$descriptor() {
        return __hypotf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __hypotf(float __x, float __y)
     * }
     */
    public static MethodHandle __hypotf$handle() {
        return __hypotf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __hypotf(float __x, float __y)
     * }
     */
    public static MemorySegment __hypotf$address() {
        return __hypotf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __hypotf(float __x, float __y)
     * }
     */
    public static float __hypotf(float __x, float __y) {
        var mh$ = __hypotf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__hypotf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("cbrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cbrtf(float __x)
     * }
     */
    public static FunctionDescriptor cbrtf$descriptor() {
        return cbrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cbrtf(float __x)
     * }
     */
    public static MethodHandle cbrtf$handle() {
        return cbrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cbrtf(float __x)
     * }
     */
    public static MemorySegment cbrtf$address() {
        return cbrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cbrtf(float __x)
     * }
     */
    public static float cbrtf(float __x) {
        var mh$ = cbrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrtf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cbrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__cbrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cbrtf(float __x)
     * }
     */
    public static FunctionDescriptor __cbrtf$descriptor() {
        return __cbrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cbrtf(float __x)
     * }
     */
    public static MethodHandle __cbrtf$handle() {
        return __cbrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cbrtf(float __x)
     * }
     */
    public static MemorySegment __cbrtf$address() {
        return __cbrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cbrtf(float __x)
     * }
     */
    public static float __cbrtf(float __x) {
        var mh$ = __cbrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cbrtf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceilf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("ceilf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ceilf(float __x)
     * }
     */
    public static FunctionDescriptor ceilf$descriptor() {
        return ceilf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ceilf(float __x)
     * }
     */
    public static MethodHandle ceilf$handle() {
        return ceilf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ceilf(float __x)
     * }
     */
    public static MemorySegment ceilf$address() {
        return ceilf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ceilf(float __x)
     * }
     */
    public static float ceilf(float __x) {
        var mh$ = ceilf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceilf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ceilf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__ceilf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __ceilf(float __x)
     * }
     */
    public static FunctionDescriptor __ceilf$descriptor() {
        return __ceilf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __ceilf(float __x)
     * }
     */
    public static MethodHandle __ceilf$handle() {
        return __ceilf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __ceilf(float __x)
     * }
     */
    public static MemorySegment __ceilf$address() {
        return __ceilf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __ceilf(float __x)
     * }
     */
    public static float __ceilf(float __x) {
        var mh$ = __ceilf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ceilf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fabsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("fabsf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fabsf(float __x)
     * }
     */
    public static FunctionDescriptor fabsf$descriptor() {
        return fabsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fabsf(float __x)
     * }
     */
    public static MethodHandle fabsf$handle() {
        return fabsf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fabsf(float __x)
     * }
     */
    public static MemorySegment fabsf$address() {
        return fabsf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fabsf(float __x)
     * }
     */
    public static float fabsf(float __x) {
        var mh$ = fabsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fabsf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fabsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__fabsf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __fabsf(float __x)
     * }
     */
    public static FunctionDescriptor __fabsf$descriptor() {
        return __fabsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __fabsf(float __x)
     * }
     */
    public static MethodHandle __fabsf$handle() {
        return __fabsf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __fabsf(float __x)
     * }
     */
    public static MemorySegment __fabsf$address() {
        return __fabsf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __fabsf(float __x)
     * }
     */
    public static float __fabsf(float __x) {
        var mh$ = __fabsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fabsf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floorf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("floorf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float floorf(float __x)
     * }
     */
    public static FunctionDescriptor floorf$descriptor() {
        return floorf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float floorf(float __x)
     * }
     */
    public static MethodHandle floorf$handle() {
        return floorf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float floorf(float __x)
     * }
     */
    public static MemorySegment floorf$address() {
        return floorf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float floorf(float __x)
     * }
     */
    public static float floorf(float __x) {
        var mh$ = floorf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floorf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __floorf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__floorf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __floorf(float __x)
     * }
     */
    public static FunctionDescriptor __floorf$descriptor() {
        return __floorf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __floorf(float __x)
     * }
     */
    public static MethodHandle __floorf$handle() {
        return __floorf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __floorf(float __x)
     * }
     */
    public static MemorySegment __floorf$address() {
        return __floorf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __floorf(float __x)
     * }
     */
    public static float __floorf(float __x) {
        var mh$ = __floorf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__floorf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmodf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("fmodf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmodf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor fmodf$descriptor() {
        return fmodf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmodf(float __x, float __y)
     * }
     */
    public static MethodHandle fmodf$handle() {
        return fmodf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmodf(float __x, float __y)
     * }
     */
    public static MemorySegment fmodf$address() {
        return fmodf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmodf(float __x, float __y)
     * }
     */
    public static float fmodf(float __x, float __y) {
        var mh$ = fmodf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmodf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fmodf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__fmodf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __fmodf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __fmodf$descriptor() {
        return __fmodf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __fmodf(float __x, float __y)
     * }
     */
    public static MethodHandle __fmodf$handle() {
        return __fmodf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __fmodf(float __x, float __y)
     * }
     */
    public static MemorySegment __fmodf$address() {
        return __fmodf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __fmodf(float __x, float __y)
     * }
     */
    public static float __fmodf(float __x, float __y) {
        var mh$ = __fmodf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fmodf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isinff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("isinff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isinff(float __value)
     * }
     */
    public static FunctionDescriptor isinff$descriptor() {
        return isinff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isinff(float __value)
     * }
     */
    public static MethodHandle isinff$handle() {
        return isinff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isinff(float __value)
     * }
     */
    public static MemorySegment isinff$address() {
        return isinff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isinff(float __value)
     * }
     */
    public static int isinff(float __value) {
        var mh$ = isinff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isinff", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class finitef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("finitef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int finitef(float __value)
     * }
     */
    public static FunctionDescriptor finitef$descriptor() {
        return finitef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int finitef(float __value)
     * }
     */
    public static MethodHandle finitef$handle() {
        return finitef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int finitef(float __value)
     * }
     */
    public static MemorySegment finitef$address() {
        return finitef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int finitef(float __value)
     * }
     */
    public static int finitef(float __value) {
        var mh$ = finitef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("finitef", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dremf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("dremf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float dremf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor dremf$descriptor() {
        return dremf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float dremf(float __x, float __y)
     * }
     */
    public static MethodHandle dremf$handle() {
        return dremf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float dremf(float __x, float __y)
     * }
     */
    public static MemorySegment dremf$address() {
        return dremf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float dremf(float __x, float __y)
     * }
     */
    public static float dremf(float __x, float __y) {
        var mh$ = dremf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dremf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __dremf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__dremf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __dremf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __dremf$descriptor() {
        return __dremf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __dremf(float __x, float __y)
     * }
     */
    public static MethodHandle __dremf$handle() {
        return __dremf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __dremf(float __x, float __y)
     * }
     */
    public static MemorySegment __dremf$address() {
        return __dremf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __dremf(float __x, float __y)
     * }
     */
    public static float __dremf(float __x, float __y) {
        var mh$ = __dremf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__dremf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class significandf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("significandf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float significandf(float __x)
     * }
     */
    public static FunctionDescriptor significandf$descriptor() {
        return significandf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float significandf(float __x)
     * }
     */
    public static MethodHandle significandf$handle() {
        return significandf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float significandf(float __x)
     * }
     */
    public static MemorySegment significandf$address() {
        return significandf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float significandf(float __x)
     * }
     */
    public static float significandf(float __x) {
        var mh$ = significandf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("significandf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __significandf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__significandf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __significandf(float __x)
     * }
     */
    public static FunctionDescriptor __significandf$descriptor() {
        return __significandf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __significandf(float __x)
     * }
     */
    public static MethodHandle __significandf$handle() {
        return __significandf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __significandf(float __x)
     * }
     */
    public static MemorySegment __significandf$address() {
        return __significandf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __significandf(float __x)
     * }
     */
    public static float __significandf(float __x) {
        var mh$ = __significandf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__significandf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("copysignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float copysignf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor copysignf$descriptor() {
        return copysignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float copysignf(float __x, float __y)
     * }
     */
    public static MethodHandle copysignf$handle() {
        return copysignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float copysignf(float __x, float __y)
     * }
     */
    public static MemorySegment copysignf$address() {
        return copysignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float copysignf(float __x, float __y)
     * }
     */
    public static float copysignf(float __x, float __y) {
        var mh$ = copysignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysignf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __copysignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__copysignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __copysignf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __copysignf$descriptor() {
        return __copysignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __copysignf(float __x, float __y)
     * }
     */
    public static MethodHandle __copysignf$handle() {
        return __copysignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __copysignf(float __x, float __y)
     * }
     */
    public static MemorySegment __copysignf$address() {
        return __copysignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __copysignf(float __x, float __y)
     * }
     */
    public static float __copysignf(float __x, float __y) {
        var mh$ = __copysignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__copysignf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("nanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nanf(const char *__tagb)
     * }
     */
    public static FunctionDescriptor nanf$descriptor() {
        return nanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nanf(const char *__tagb)
     * }
     */
    public static MethodHandle nanf$handle() {
        return nanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nanf(const char *__tagb)
     * }
     */
    public static MemorySegment nanf$address() {
        return nanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nanf(const char *__tagb)
     * }
     */
    public static float nanf(MemorySegment __tagb) {
        var mh$ = nanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanf", __tagb);
            }
            return (float)mh$.invokeExact(__tagb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __nanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("__nanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __nanf(const char *__tagb)
     * }
     */
    public static FunctionDescriptor __nanf$descriptor() {
        return __nanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __nanf(const char *__tagb)
     * }
     */
    public static MethodHandle __nanf$handle() {
        return __nanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __nanf(const char *__tagb)
     * }
     */
    public static MemorySegment __nanf$address() {
        return __nanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __nanf(const char *__tagb)
     * }
     */
    public static float __nanf(MemorySegment __tagb) {
        var mh$ = __nanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__nanf", __tagb);
            }
            return (float)mh$.invokeExact(__tagb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isnanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("isnanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isnanf(float __value)
     * }
     */
    public static FunctionDescriptor isnanf$descriptor() {
        return isnanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isnanf(float __value)
     * }
     */
    public static MethodHandle isnanf$handle() {
        return isnanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isnanf(float __value)
     * }
     */
    public static MemorySegment isnanf$address() {
        return isnanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isnanf(float __value)
     * }
     */
    public static int isnanf(float __value) {
        var mh$ = isnanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isnanf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j0f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("j0f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float j0f(float)
     * }
     */
    public static FunctionDescriptor j0f$descriptor() {
        return j0f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float j0f(float)
     * }
     */
    public static MethodHandle j0f$handle() {
        return j0f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float j0f(float)
     * }
     */
    public static MemorySegment j0f$address() {
        return j0f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float j0f(float)
     * }
     */
    public static float j0f(float x0) {
        var mh$ = j0f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j0f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __j0f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__j0f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __j0f(float)
     * }
     */
    public static FunctionDescriptor __j0f$descriptor() {
        return __j0f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __j0f(float)
     * }
     */
    public static MethodHandle __j0f$handle() {
        return __j0f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __j0f(float)
     * }
     */
    public static MemorySegment __j0f$address() {
        return __j0f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __j0f(float)
     * }
     */
    public static float __j0f(float x0) {
        var mh$ = __j0f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__j0f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("j1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float j1f(float)
     * }
     */
    public static FunctionDescriptor j1f$descriptor() {
        return j1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float j1f(float)
     * }
     */
    public static MethodHandle j1f$handle() {
        return j1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float j1f(float)
     * }
     */
    public static MemorySegment j1f$address() {
        return j1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float j1f(float)
     * }
     */
    public static float j1f(float x0) {
        var mh$ = j1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j1f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __j1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__j1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __j1f(float)
     * }
     */
    public static FunctionDescriptor __j1f$descriptor() {
        return __j1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __j1f(float)
     * }
     */
    public static MethodHandle __j1f$handle() {
        return __j1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __j1f(float)
     * }
     */
    public static MemorySegment __j1f$address() {
        return __j1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __j1f(float)
     * }
     */
    public static float __j1f(float x0) {
        var mh$ = __j1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__j1f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_INT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("jnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float jnf(int, float)
     * }
     */
    public static FunctionDescriptor jnf$descriptor() {
        return jnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float jnf(int, float)
     * }
     */
    public static MethodHandle jnf$handle() {
        return jnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float jnf(int, float)
     * }
     */
    public static MemorySegment jnf$address() {
        return jnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float jnf(int, float)
     * }
     */
    public static float jnf(int x0, float x1) {
        var mh$ = jnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jnf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __jnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_INT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__jnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __jnf(int, float)
     * }
     */
    public static FunctionDescriptor __jnf$descriptor() {
        return __jnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __jnf(int, float)
     * }
     */
    public static MethodHandle __jnf$handle() {
        return __jnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __jnf(int, float)
     * }
     */
    public static MemorySegment __jnf$address() {
        return __jnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __jnf(int, float)
     * }
     */
    public static float __jnf(int x0, float x1) {
        var mh$ = __jnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__jnf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y0f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("y0f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float y0f(float)
     * }
     */
    public static FunctionDescriptor y0f$descriptor() {
        return y0f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float y0f(float)
     * }
     */
    public static MethodHandle y0f$handle() {
        return y0f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float y0f(float)
     * }
     */
    public static MemorySegment y0f$address() {
        return y0f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float y0f(float)
     * }
     */
    public static float y0f(float x0) {
        var mh$ = y0f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y0f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __y0f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__y0f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __y0f(float)
     * }
     */
    public static FunctionDescriptor __y0f$descriptor() {
        return __y0f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __y0f(float)
     * }
     */
    public static MethodHandle __y0f$handle() {
        return __y0f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __y0f(float)
     * }
     */
    public static MemorySegment __y0f$address() {
        return __y0f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __y0f(float)
     * }
     */
    public static float __y0f(float x0) {
        var mh$ = __y0f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__y0f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("y1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float y1f(float)
     * }
     */
    public static FunctionDescriptor y1f$descriptor() {
        return y1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float y1f(float)
     * }
     */
    public static MethodHandle y1f$handle() {
        return y1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float y1f(float)
     * }
     */
    public static MemorySegment y1f$address() {
        return y1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float y1f(float)
     * }
     */
    public static float y1f(float x0) {
        var mh$ = y1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y1f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __y1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__y1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __y1f(float)
     * }
     */
    public static FunctionDescriptor __y1f$descriptor() {
        return __y1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __y1f(float)
     * }
     */
    public static MethodHandle __y1f$handle() {
        return __y1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __y1f(float)
     * }
     */
    public static MemorySegment __y1f$address() {
        return __y1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __y1f(float)
     * }
     */
    public static float __y1f(float x0) {
        var mh$ = __y1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__y1f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ynf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_INT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("ynf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ynf(int, float)
     * }
     */
    public static FunctionDescriptor ynf$descriptor() {
        return ynf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ynf(int, float)
     * }
     */
    public static MethodHandle ynf$handle() {
        return ynf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ynf(int, float)
     * }
     */
    public static MemorySegment ynf$address() {
        return ynf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ynf(int, float)
     * }
     */
    public static float ynf(int x0, float x1) {
        var mh$ = ynf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ynf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ynf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_INT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__ynf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __ynf(int, float)
     * }
     */
    public static FunctionDescriptor __ynf$descriptor() {
        return __ynf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __ynf(int, float)
     * }
     */
    public static MethodHandle __ynf$handle() {
        return __ynf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __ynf(int, float)
     * }
     */
    public static MemorySegment __ynf$address() {
        return __ynf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __ynf(int, float)
     * }
     */
    public static float __ynf(int x0, float x1) {
        var mh$ = __ynf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ynf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("erff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static FunctionDescriptor erff$descriptor() {
        return erff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static MethodHandle erff$handle() {
        return erff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static MemorySegment erff$address() {
        return erff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static float erff(float x0) {
        var mh$ = erff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erff", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __erff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__erff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __erff(float)
     * }
     */
    public static FunctionDescriptor __erff$descriptor() {
        return __erff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __erff(float)
     * }
     */
    public static MethodHandle __erff$handle() {
        return __erff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __erff(float)
     * }
     */
    public static MemorySegment __erff$address() {
        return __erff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __erff(float)
     * }
     */
    public static float __erff(float x0) {
        var mh$ = __erff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__erff", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfcf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("erfcf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static FunctionDescriptor erfcf$descriptor() {
        return erfcf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static MethodHandle erfcf$handle() {
        return erfcf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static MemorySegment erfcf$address() {
        return erfcf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static float erfcf(float x0) {
        var mh$ = erfcf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfcf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __erfcf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__erfcf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __erfcf(float)
     * }
     */
    public static FunctionDescriptor __erfcf$descriptor() {
        return __erfcf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __erfcf(float)
     * }
     */
    public static MethodHandle __erfcf$handle() {
        return __erfcf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __erfcf(float)
     * }
     */
    public static MemorySegment __erfcf$address() {
        return __erfcf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __erfcf(float)
     * }
     */
    public static float __erfcf(float x0) {
        var mh$ = __erfcf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__erfcf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("lgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static FunctionDescriptor lgammaf$descriptor() {
        return lgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static MethodHandle lgammaf$handle() {
        return lgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static MemorySegment lgammaf$address() {
        return lgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static float lgammaf(float x0) {
        var mh$ = lgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__lgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __lgammaf(float)
     * }
     */
    public static FunctionDescriptor __lgammaf$descriptor() {
        return __lgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __lgammaf(float)
     * }
     */
    public static MethodHandle __lgammaf$handle() {
        return __lgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __lgammaf(float)
     * }
     */
    public static MemorySegment __lgammaf$address() {
        return __lgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __lgammaf(float)
     * }
     */
    public static float __lgammaf(float x0) {
        var mh$ = __lgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("tgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static FunctionDescriptor tgammaf$descriptor() {
        return tgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static MethodHandle tgammaf$handle() {
        return tgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static MemorySegment tgammaf$address() {
        return tgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static float tgammaf(float x0) {
        var mh$ = tgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__tgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __tgammaf(float)
     * }
     */
    public static FunctionDescriptor __tgammaf$descriptor() {
        return __tgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __tgammaf(float)
     * }
     */
    public static MethodHandle __tgammaf$handle() {
        return __tgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __tgammaf(float)
     * }
     */
    public static MemorySegment __tgammaf$address() {
        return __tgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __tgammaf(float)
     * }
     */
    public static float __tgammaf(float x0) {
        var mh$ = __tgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("gammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float gammaf(float)
     * }
     */
    public static FunctionDescriptor gammaf$descriptor() {
        return gammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float gammaf(float)
     * }
     */
    public static MethodHandle gammaf$handle() {
        return gammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float gammaf(float)
     * }
     */
    public static MemorySegment gammaf$address() {
        return gammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float gammaf(float)
     * }
     */
    public static float gammaf(float x0) {
        var mh$ = gammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__gammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __gammaf(float)
     * }
     */
    public static FunctionDescriptor __gammaf$descriptor() {
        return __gammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __gammaf(float)
     * }
     */
    public static MethodHandle __gammaf$handle() {
        return __gammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __gammaf(float)
     * }
     */
    public static MemorySegment __gammaf$address() {
        return __gammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __gammaf(float)
     * }
     */
    public static float __gammaf(float x0) {
        var mh$ = __gammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammaf_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("lgammaf_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float lgammaf_r(float, int *__signgamp)
     * }
     */
    public static FunctionDescriptor lgammaf_r$descriptor() {
        return lgammaf_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float lgammaf_r(float, int *__signgamp)
     * }
     */
    public static MethodHandle lgammaf_r$handle() {
        return lgammaf_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float lgammaf_r(float, int *__signgamp)
     * }
     */
    public static MemorySegment lgammaf_r$address() {
        return lgammaf_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float lgammaf_r(float, int *__signgamp)
     * }
     */
    public static float lgammaf_r(float x0, MemorySegment __signgamp) {
        var mh$ = lgammaf_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammaf_r", x0, __signgamp);
            }
            return (float)mh$.invokeExact(x0, __signgamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lgammaf_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("__lgammaf_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __lgammaf_r(float, int *__signgamp)
     * }
     */
    public static FunctionDescriptor __lgammaf_r$descriptor() {
        return __lgammaf_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __lgammaf_r(float, int *__signgamp)
     * }
     */
    public static MethodHandle __lgammaf_r$handle() {
        return __lgammaf_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __lgammaf_r(float, int *__signgamp)
     * }
     */
    public static MemorySegment __lgammaf_r$address() {
        return __lgammaf_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __lgammaf_r(float, int *__signgamp)
     * }
     */
    public static float __lgammaf_r(float x0, MemorySegment __signgamp) {
        var mh$ = __lgammaf_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lgammaf_r", x0, __signgamp);
            }
            return (float)mh$.invokeExact(x0, __signgamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("rintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float rintf(float __x)
     * }
     */
    public static FunctionDescriptor rintf$descriptor() {
        return rintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float rintf(float __x)
     * }
     */
    public static MethodHandle rintf$handle() {
        return rintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float rintf(float __x)
     * }
     */
    public static MemorySegment rintf$address() {
        return rintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float rintf(float __x)
     * }
     */
    public static float rintf(float __x) {
        var mh$ = rintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rintf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __rintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__rintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __rintf(float __x)
     * }
     */
    public static FunctionDescriptor __rintf$descriptor() {
        return __rintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __rintf(float __x)
     * }
     */
    public static MethodHandle __rintf$handle() {
        return __rintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __rintf(float __x)
     * }
     */
    public static MemorySegment __rintf$address() {
        return __rintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __rintf(float __x)
     * }
     */
    public static float __rintf(float __x) {
        var mh$ = __rintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__rintf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("nextafterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nextafterf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor nextafterf$descriptor() {
        return nextafterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nextafterf(float __x, float __y)
     * }
     */
    public static MethodHandle nextafterf$handle() {
        return nextafterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nextafterf(float __x, float __y)
     * }
     */
    public static MemorySegment nextafterf$address() {
        return nextafterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nextafterf(float __x, float __y)
     * }
     */
    public static float nextafterf(float __x, float __y) {
        var mh$ = nextafterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafterf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __nextafterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__nextafterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __nextafterf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __nextafterf$descriptor() {
        return __nextafterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __nextafterf(float __x, float __y)
     * }
     */
    public static MethodHandle __nextafterf$handle() {
        return __nextafterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __nextafterf(float __x, float __y)
     * }
     */
    public static MemorySegment __nextafterf$address() {
        return __nextafterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __nextafterf(float __x, float __y)
     * }
     */
    public static float __nextafterf(float __x, float __y) {
        var mh$ = __nextafterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__nextafterf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainderf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("remainderf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float remainderf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor remainderf$descriptor() {
        return remainderf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float remainderf(float __x, float __y)
     * }
     */
    public static MethodHandle remainderf$handle() {
        return remainderf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float remainderf(float __x, float __y)
     * }
     */
    public static MemorySegment remainderf$address() {
        return remainderf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float remainderf(float __x, float __y)
     * }
     */
    public static float remainderf(float __x, float __y) {
        var mh$ = remainderf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainderf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __remainderf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__remainderf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __remainderf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __remainderf$descriptor() {
        return __remainderf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __remainderf(float __x, float __y)
     * }
     */
    public static MethodHandle __remainderf$handle() {
        return __remainderf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __remainderf(float __x, float __y)
     * }
     */
    public static MemorySegment __remainderf$address() {
        return __remainderf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __remainderf(float __x, float __y)
     * }
     */
    public static float __remainderf(float __x, float __y) {
        var mh$ = __remainderf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__remainderf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("scalbnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float scalbnf(float __x, int __n)
     * }
     */
    public static FunctionDescriptor scalbnf$descriptor() {
        return scalbnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float scalbnf(float __x, int __n)
     * }
     */
    public static MethodHandle scalbnf$handle() {
        return scalbnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float scalbnf(float __x, int __n)
     * }
     */
    public static MemorySegment scalbnf$address() {
        return scalbnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float scalbnf(float __x, int __n)
     * }
     */
    public static float scalbnf(float __x, int __n) {
        var mh$ = scalbnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbnf", __x, __n);
            }
            return (float)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __scalbnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__scalbnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __scalbnf(float __x, int __n)
     * }
     */
    public static FunctionDescriptor __scalbnf$descriptor() {
        return __scalbnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __scalbnf(float __x, int __n)
     * }
     */
    public static MethodHandle __scalbnf$handle() {
        return __scalbnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __scalbnf(float __x, int __n)
     * }
     */
    public static MemorySegment __scalbnf$address() {
        return __scalbnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __scalbnf(float __x, int __n)
     * }
     */
    public static float __scalbnf(float __x, int __n) {
        var mh$ = __scalbnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__scalbnf", __x, __n);
            }
            return (float)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("ilogbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ilogbf(float __x)
     * }
     */
    public static FunctionDescriptor ilogbf$descriptor() {
        return ilogbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ilogbf(float __x)
     * }
     */
    public static MethodHandle ilogbf$handle() {
        return ilogbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ilogbf(float __x)
     * }
     */
    public static MemorySegment ilogbf$address() {
        return ilogbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ilogbf(float __x)
     * }
     */
    public static int ilogbf(float __x) {
        var mh$ = ilogbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogbf", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ilogbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__ilogbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __ilogbf(float __x)
     * }
     */
    public static FunctionDescriptor __ilogbf$descriptor() {
        return __ilogbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __ilogbf(float __x)
     * }
     */
    public static MethodHandle __ilogbf$handle() {
        return __ilogbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __ilogbf(float __x)
     * }
     */
    public static MemorySegment __ilogbf$address() {
        return __ilogbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __ilogbf(float __x)
     * }
     */
    public static int __ilogbf(float __x) {
        var mh$ = __ilogbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ilogbf", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalblnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_LONG
        );

        public static final MemorySegment ADDR = C.findOrThrow("scalblnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float scalblnf(float __x, long __n)
     * }
     */
    public static FunctionDescriptor scalblnf$descriptor() {
        return scalblnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float scalblnf(float __x, long __n)
     * }
     */
    public static MethodHandle scalblnf$handle() {
        return scalblnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float scalblnf(float __x, long __n)
     * }
     */
    public static MemorySegment scalblnf$address() {
        return scalblnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float scalblnf(float __x, long __n)
     * }
     */
    public static float scalblnf(float __x, long __n) {
        var mh$ = scalblnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalblnf", __x, __n);
            }
            return (float)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __scalblnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_LONG
        );

        public static final MemorySegment ADDR = C.findOrThrow("__scalblnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __scalblnf(float __x, long __n)
     * }
     */
    public static FunctionDescriptor __scalblnf$descriptor() {
        return __scalblnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __scalblnf(float __x, long __n)
     * }
     */
    public static MethodHandle __scalblnf$handle() {
        return __scalblnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __scalblnf(float __x, long __n)
     * }
     */
    public static MemorySegment __scalblnf$address() {
        return __scalblnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __scalblnf(float __x, long __n)
     * }
     */
    public static float __scalblnf(float __x, long __n) {
        var mh$ = __scalblnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__scalblnf", __x, __n);
            }
            return (float)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("nearbyintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nearbyintf(float __x)
     * }
     */
    public static FunctionDescriptor nearbyintf$descriptor() {
        return nearbyintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nearbyintf(float __x)
     * }
     */
    public static MethodHandle nearbyintf$handle() {
        return nearbyintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nearbyintf(float __x)
     * }
     */
    public static MemorySegment nearbyintf$address() {
        return nearbyintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nearbyintf(float __x)
     * }
     */
    public static float nearbyintf(float __x) {
        var mh$ = nearbyintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyintf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __nearbyintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__nearbyintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __nearbyintf(float __x)
     * }
     */
    public static FunctionDescriptor __nearbyintf$descriptor() {
        return __nearbyintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __nearbyintf(float __x)
     * }
     */
    public static MethodHandle __nearbyintf$handle() {
        return __nearbyintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __nearbyintf(float __x)
     * }
     */
    public static MemorySegment __nearbyintf$address() {
        return __nearbyintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __nearbyintf(float __x)
     * }
     */
    public static float __nearbyintf(float __x) {
        var mh$ = __nearbyintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__nearbyintf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class roundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("roundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float roundf(float __x)
     * }
     */
    public static FunctionDescriptor roundf$descriptor() {
        return roundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float roundf(float __x)
     * }
     */
    public static MethodHandle roundf$handle() {
        return roundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float roundf(float __x)
     * }
     */
    public static MemorySegment roundf$address() {
        return roundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float roundf(float __x)
     * }
     */
    public static float roundf(float __x) {
        var mh$ = roundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("roundf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __roundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__roundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __roundf(float __x)
     * }
     */
    public static FunctionDescriptor __roundf$descriptor() {
        return __roundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __roundf(float __x)
     * }
     */
    public static MethodHandle __roundf$handle() {
        return __roundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __roundf(float __x)
     * }
     */
    public static MemorySegment __roundf$address() {
        return __roundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __roundf(float __x)
     * }
     */
    public static float __roundf(float __x) {
        var mh$ = __roundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__roundf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("truncf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float truncf(float __x)
     * }
     */
    public static FunctionDescriptor truncf$descriptor() {
        return truncf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float truncf(float __x)
     * }
     */
    public static MethodHandle truncf$handle() {
        return truncf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float truncf(float __x)
     * }
     */
    public static MemorySegment truncf$address() {
        return truncf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float truncf(float __x)
     * }
     */
    public static float truncf(float __x) {
        var mh$ = truncf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __truncf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__truncf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __truncf(float __x)
     * }
     */
    public static FunctionDescriptor __truncf$descriptor() {
        return __truncf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __truncf(float __x)
     * }
     */
    public static MethodHandle __truncf$handle() {
        return __truncf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __truncf(float __x)
     * }
     */
    public static MemorySegment __truncf$address() {
        return __truncf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __truncf(float __x)
     * }
     */
    public static float __truncf(float __x) {
        var mh$ = __truncf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__truncf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("remquof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float remquof(float __x, float __y, int *__quo)
     * }
     */
    public static FunctionDescriptor remquof$descriptor() {
        return remquof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float remquof(float __x, float __y, int *__quo)
     * }
     */
    public static MethodHandle remquof$handle() {
        return remquof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float remquof(float __x, float __y, int *__quo)
     * }
     */
    public static MemorySegment remquof$address() {
        return remquof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float remquof(float __x, float __y, int *__quo)
     * }
     */
    public static float remquof(float __x, float __y, MemorySegment __quo) {
        var mh$ = remquof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquof", __x, __y, __quo);
            }
            return (float)mh$.invokeExact(__x, __y, __quo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __remquof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("__remquof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __remquof(float __x, float __y, int *__quo)
     * }
     */
    public static FunctionDescriptor __remquof$descriptor() {
        return __remquof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __remquof(float __x, float __y, int *__quo)
     * }
     */
    public static MethodHandle __remquof$handle() {
        return __remquof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __remquof(float __x, float __y, int *__quo)
     * }
     */
    public static MemorySegment __remquof$address() {
        return __remquof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __remquof(float __x, float __y, int *__quo)
     * }
     */
    public static float __remquof(float __x, float __y, MemorySegment __quo) {
        var mh$ = __remquof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__remquof", __x, __y, __quo);
            }
            return (float)mh$.invokeExact(__x, __y, __quo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("lrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrintf(float __x)
     * }
     */
    public static FunctionDescriptor lrintf$descriptor() {
        return lrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrintf(float __x)
     * }
     */
    public static MethodHandle lrintf$handle() {
        return lrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrintf(float __x)
     * }
     */
    public static MemorySegment lrintf$address() {
        return lrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrintf(float __x)
     * }
     */
    public static long lrintf(float __x) {
        var mh$ = lrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrintf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__lrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long __lrintf(float __x)
     * }
     */
    public static FunctionDescriptor __lrintf$descriptor() {
        return __lrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long __lrintf(float __x)
     * }
     */
    public static MethodHandle __lrintf$handle() {
        return __lrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long __lrintf(float __x)
     * }
     */
    public static MemorySegment __lrintf$address() {
        return __lrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long __lrintf(float __x)
     * }
     */
    public static long __lrintf(float __x) {
        var mh$ = __lrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lrintf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG_LONG,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("llrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llrintf(float __x)
     * }
     */
    public static FunctionDescriptor llrintf$descriptor() {
        return llrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llrintf(float __x)
     * }
     */
    public static MethodHandle llrintf$handle() {
        return llrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llrintf(float __x)
     * }
     */
    public static MemorySegment llrintf$address() {
        return llrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llrintf(float __x)
     * }
     */
    public static long llrintf(float __x) {
        var mh$ = llrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrintf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __llrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG_LONG,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__llrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long __llrintf(float __x)
     * }
     */
    public static FunctionDescriptor __llrintf$descriptor() {
        return __llrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long __llrintf(float __x)
     * }
     */
    public static MethodHandle __llrintf$handle() {
        return __llrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long __llrintf(float __x)
     * }
     */
    public static MemorySegment __llrintf$address() {
        return __llrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long __llrintf(float __x)
     * }
     */
    public static long __llrintf(float __x) {
        var mh$ = __llrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__llrintf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("lroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lroundf(float __x)
     * }
     */
    public static FunctionDescriptor lroundf$descriptor() {
        return lroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lroundf(float __x)
     * }
     */
    public static MethodHandle lroundf$handle() {
        return lroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lroundf(float __x)
     * }
     */
    public static MemorySegment lroundf$address() {
        return lroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lroundf(float __x)
     * }
     */
    public static long lroundf(float __x) {
        var mh$ = lroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lroundf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__lroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long __lroundf(float __x)
     * }
     */
    public static FunctionDescriptor __lroundf$descriptor() {
        return __lroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long __lroundf(float __x)
     * }
     */
    public static MethodHandle __lroundf$handle() {
        return __lroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long __lroundf(float __x)
     * }
     */
    public static MemorySegment __lroundf$address() {
        return __lroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long __lroundf(float __x)
     * }
     */
    public static long __lroundf(float __x) {
        var mh$ = __lroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lroundf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG_LONG,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("llroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llroundf(float __x)
     * }
     */
    public static FunctionDescriptor llroundf$descriptor() {
        return llroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llroundf(float __x)
     * }
     */
    public static MethodHandle llroundf$handle() {
        return llroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llroundf(float __x)
     * }
     */
    public static MemorySegment llroundf$address() {
        return llroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llroundf(float __x)
     * }
     */
    public static long llroundf(float __x) {
        var mh$ = llroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llroundf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __llroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG_LONG,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__llroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long __llroundf(float __x)
     * }
     */
    public static FunctionDescriptor __llroundf$descriptor() {
        return __llroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long __llroundf(float __x)
     * }
     */
    public static MethodHandle __llroundf$handle() {
        return __llroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long __llroundf(float __x)
     * }
     */
    public static MemorySegment __llroundf$address() {
        return __llroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long __llroundf(float __x)
     * }
     */
    public static long __llroundf(float __x) {
        var mh$ = __llroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__llroundf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdimf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("fdimf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fdimf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor fdimf$descriptor() {
        return fdimf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fdimf(float __x, float __y)
     * }
     */
    public static MethodHandle fdimf$handle() {
        return fdimf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fdimf(float __x, float __y)
     * }
     */
    public static MemorySegment fdimf$address() {
        return fdimf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fdimf(float __x, float __y)
     * }
     */
    public static float fdimf(float __x, float __y) {
        var mh$ = fdimf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdimf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fdimf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__fdimf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __fdimf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __fdimf$descriptor() {
        return __fdimf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __fdimf(float __x, float __y)
     * }
     */
    public static MethodHandle __fdimf$handle() {
        return __fdimf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __fdimf(float __x, float __y)
     * }
     */
    public static MemorySegment __fdimf$address() {
        return __fdimf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __fdimf(float __x, float __y)
     * }
     */
    public static float __fdimf(float __x, float __y) {
        var mh$ = __fdimf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fdimf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaxf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("fmaxf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmaxf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor fmaxf$descriptor() {
        return fmaxf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmaxf(float __x, float __y)
     * }
     */
    public static MethodHandle fmaxf$handle() {
        return fmaxf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmaxf(float __x, float __y)
     * }
     */
    public static MemorySegment fmaxf$address() {
        return fmaxf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmaxf(float __x, float __y)
     * }
     */
    public static float fmaxf(float __x, float __y) {
        var mh$ = fmaxf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaxf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fmaxf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__fmaxf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __fmaxf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __fmaxf$descriptor() {
        return __fmaxf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __fmaxf(float __x, float __y)
     * }
     */
    public static MethodHandle __fmaxf$handle() {
        return __fmaxf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __fmaxf(float __x, float __y)
     * }
     */
    public static MemorySegment __fmaxf$address() {
        return __fmaxf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __fmaxf(float __x, float __y)
     * }
     */
    public static float __fmaxf(float __x, float __y) {
        var mh$ = __fmaxf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fmaxf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fminf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("fminf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fminf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor fminf$descriptor() {
        return fminf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fminf(float __x, float __y)
     * }
     */
    public static MethodHandle fminf$handle() {
        return fminf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fminf(float __x, float __y)
     * }
     */
    public static MemorySegment fminf$address() {
        return fminf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fminf(float __x, float __y)
     * }
     */
    public static float fminf(float __x, float __y) {
        var mh$ = fminf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fminf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fminf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__fminf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __fminf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __fminf$descriptor() {
        return __fminf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __fminf(float __x, float __y)
     * }
     */
    public static MethodHandle __fminf$handle() {
        return __fminf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __fminf(float __x, float __y)
     * }
     */
    public static MemorySegment __fminf$address() {
        return __fminf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __fminf(float __x, float __y)
     * }
     */
    public static float __fminf(float __x, float __y) {
        var mh$ = __fminf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fminf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("fmaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmaf(float __x, float __y, float __z)
     * }
     */
    public static FunctionDescriptor fmaf$descriptor() {
        return fmaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmaf(float __x, float __y, float __z)
     * }
     */
    public static MethodHandle fmaf$handle() {
        return fmaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmaf(float __x, float __y, float __z)
     * }
     */
    public static MemorySegment fmaf$address() {
        return fmaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmaf(float __x, float __y, float __z)
     * }
     */
    public static float fmaf(float __x, float __y, float __z) {
        var mh$ = fmaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaf", __x, __y, __z);
            }
            return (float)mh$.invokeExact(__x, __y, __z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fmaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__fmaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __fmaf(float __x, float __y, float __z)
     * }
     */
    public static FunctionDescriptor __fmaf$descriptor() {
        return __fmaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __fmaf(float __x, float __y, float __z)
     * }
     */
    public static MethodHandle __fmaf$handle() {
        return __fmaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __fmaf(float __x, float __y, float __z)
     * }
     */
    public static MemorySegment __fmaf$address() {
        return __fmaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __fmaf(float __x, float __y, float __z)
     * }
     */
    public static float __fmaf(float __x, float __y, float __z) {
        var mh$ = __fmaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fmaf", __x, __y, __z);
            }
            return (float)mh$.invokeExact(__x, __y, __z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("scalbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float scalbf(float __x, float __n)
     * }
     */
    public static FunctionDescriptor scalbf$descriptor() {
        return scalbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float scalbf(float __x, float __n)
     * }
     */
    public static MethodHandle scalbf$handle() {
        return scalbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float scalbf(float __x, float __n)
     * }
     */
    public static MemorySegment scalbf$address() {
        return scalbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float scalbf(float __x, float __n)
     * }
     */
    public static float scalbf(float __x, float __n) {
        var mh$ = scalbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbf", __x, __n);
            }
            return (float)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __scalbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_FLOAT,
            C.C_FLOAT,
            C.C_FLOAT
        );

        public static final MemorySegment ADDR = C.findOrThrow("__scalbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __scalbf(float __x, float __n)
     * }
     */
    public static FunctionDescriptor __scalbf$descriptor() {
        return __scalbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __scalbf(float __x, float __n)
     * }
     */
    public static MethodHandle __scalbf$handle() {
        return __scalbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __scalbf(float __x, float __n)
     * }
     */
    public static MemorySegment __scalbf$address() {
        return __scalbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __scalbf(float __x, float __n)
     * }
     */
    public static float __scalbf(float __x, float __n) {
        var mh$ = __scalbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__scalbf", __x, __n);
            }
            return (float)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class signgam$constants {
        public static final OfInt LAYOUT = C.C_INT;
        public static final MemorySegment SEGMENT = C.findOrThrow("signgam").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static OfInt signgam$layout() {
        return signgam$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static MemorySegment signgam$segment() {
        return signgam$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static int signgam() {
        return signgam$constants.SEGMENT.get(signgam$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static void signgam(int varValue) {
        signgam$constants.SEGMENT.set(signgam$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = C.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = C.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __gwchar_t
     * }
     */
    public static final OfInt __gwchar_t = C.C_INT;

    private static class imaxabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_LONG
        );

        public static final MemorySegment ADDR = C.findOrThrow("imaxabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static FunctionDescriptor imaxabs$descriptor() {
        return imaxabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static MethodHandle imaxabs$handle() {
        return imaxabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static MemorySegment imaxabs$address() {
        return imaxabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static long imaxabs(long __n) {
        var mh$ = imaxabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxabs", __n);
            }
            return (long)mh$.invokeExact(__n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imaxdiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            imaxdiv_t.layout(),
            C.C_LONG,
            C.C_LONG
        );

        public static final MemorySegment ADDR = C.findOrThrow("imaxdiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static FunctionDescriptor imaxdiv$descriptor() {
        return imaxdiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MethodHandle imaxdiv$handle() {
        return imaxdiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv$address() {
        return imaxdiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = imaxdiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxdiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("strtoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoimax$descriptor() {
        return strtoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoimax$handle() {
        return strtoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoimax$address() {
        return strtoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("strtoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoumax$descriptor() {
        return strtoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoumax$handle() {
        return strtoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoumax$address() {
        return strtoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wcstoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoimax$descriptor() {
        return wcstoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoimax$handle() {
        return wcstoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoimax$address() {
        return wcstoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_LONG,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wcstoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoumax$descriptor() {
        return wcstoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoumax$handle() {
        return wcstoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoumax$address() {
        return wcstoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_list_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_list_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_list_init(struct wl_list *list)
     * }
     */
    public static FunctionDescriptor wl_list_init$descriptor() {
        return wl_list_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_list_init(struct wl_list *list)
     * }
     */
    public static MethodHandle wl_list_init$handle() {
        return wl_list_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_list_init(struct wl_list *list)
     * }
     */
    public static MemorySegment wl_list_init$address() {
        return wl_list_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_list_init(struct wl_list *list)
     * }
     */
    public static void wl_list_init(MemorySegment list) {
        var mh$ = wl_list_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_list_init", list);
            }
            mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_list_insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_list_insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_list_insert(struct wl_list *list, struct wl_list *elm)
     * }
     */
    public static FunctionDescriptor wl_list_insert$descriptor() {
        return wl_list_insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_list_insert(struct wl_list *list, struct wl_list *elm)
     * }
     */
    public static MethodHandle wl_list_insert$handle() {
        return wl_list_insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_list_insert(struct wl_list *list, struct wl_list *elm)
     * }
     */
    public static MemorySegment wl_list_insert$address() {
        return wl_list_insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_list_insert(struct wl_list *list, struct wl_list *elm)
     * }
     */
    public static void wl_list_insert(MemorySegment list, MemorySegment elm) {
        var mh$ = wl_list_insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_list_insert", list, elm);
            }
            mh$.invokeExact(list, elm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_list_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_list_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_list_remove(struct wl_list *elm)
     * }
     */
    public static FunctionDescriptor wl_list_remove$descriptor() {
        return wl_list_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_list_remove(struct wl_list *elm)
     * }
     */
    public static MethodHandle wl_list_remove$handle() {
        return wl_list_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_list_remove(struct wl_list *elm)
     * }
     */
    public static MemorySegment wl_list_remove$address() {
        return wl_list_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_list_remove(struct wl_list *elm)
     * }
     */
    public static void wl_list_remove(MemorySegment elm) {
        var mh$ = wl_list_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_list_remove", elm);
            }
            mh$.invokeExact(elm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_list_length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_list_length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wl_list_length(const struct wl_list *list)
     * }
     */
    public static FunctionDescriptor wl_list_length$descriptor() {
        return wl_list_length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wl_list_length(const struct wl_list *list)
     * }
     */
    public static MethodHandle wl_list_length$handle() {
        return wl_list_length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wl_list_length(const struct wl_list *list)
     * }
     */
    public static MemorySegment wl_list_length$address() {
        return wl_list_length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wl_list_length(const struct wl_list *list)
     * }
     */
    public static int wl_list_length(MemorySegment list) {
        var mh$ = wl_list_length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_list_length", list);
            }
            return (int)mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_list_empty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_list_empty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wl_list_empty(const struct wl_list *list)
     * }
     */
    public static FunctionDescriptor wl_list_empty$descriptor() {
        return wl_list_empty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wl_list_empty(const struct wl_list *list)
     * }
     */
    public static MethodHandle wl_list_empty$handle() {
        return wl_list_empty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wl_list_empty(const struct wl_list *list)
     * }
     */
    public static MemorySegment wl_list_empty$address() {
        return wl_list_empty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wl_list_empty(const struct wl_list *list)
     * }
     */
    public static int wl_list_empty(MemorySegment list) {
        var mh$ = wl_list_empty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_list_empty", list);
            }
            return (int)mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_list_insert_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_list_insert_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_list_insert_list(struct wl_list *list, struct wl_list *other)
     * }
     */
    public static FunctionDescriptor wl_list_insert_list$descriptor() {
        return wl_list_insert_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_list_insert_list(struct wl_list *list, struct wl_list *other)
     * }
     */
    public static MethodHandle wl_list_insert_list$handle() {
        return wl_list_insert_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_list_insert_list(struct wl_list *list, struct wl_list *other)
     * }
     */
    public static MemorySegment wl_list_insert_list$address() {
        return wl_list_insert_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_list_insert_list(struct wl_list *list, struct wl_list *other)
     * }
     */
    public static void wl_list_insert_list(MemorySegment list, MemorySegment other) {
        var mh$ = wl_list_insert_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_list_insert_list", list, other);
            }
            mh$.invokeExact(list, other);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_array_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_array_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_array_init(struct wl_array *array)
     * }
     */
    public static FunctionDescriptor wl_array_init$descriptor() {
        return wl_array_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_array_init(struct wl_array *array)
     * }
     */
    public static MethodHandle wl_array_init$handle() {
        return wl_array_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_array_init(struct wl_array *array)
     * }
     */
    public static MemorySegment wl_array_init$address() {
        return wl_array_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_array_init(struct wl_array *array)
     * }
     */
    public static void wl_array_init(MemorySegment array) {
        var mh$ = wl_array_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_array_init", array);
            }
            mh$.invokeExact(array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_array_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_array_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_array_release(struct wl_array *array)
     * }
     */
    public static FunctionDescriptor wl_array_release$descriptor() {
        return wl_array_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_array_release(struct wl_array *array)
     * }
     */
    public static MethodHandle wl_array_release$handle() {
        return wl_array_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_array_release(struct wl_array *array)
     * }
     */
    public static MemorySegment wl_array_release$address() {
        return wl_array_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_array_release(struct wl_array *array)
     * }
     */
    public static void wl_array_release(MemorySegment array) {
        var mh$ = wl_array_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_array_release", array);
            }
            mh$.invokeExact(array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_array_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_LONG
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_array_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *wl_array_add(struct wl_array *array, size_t size)
     * }
     */
    public static FunctionDescriptor wl_array_add$descriptor() {
        return wl_array_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *wl_array_add(struct wl_array *array, size_t size)
     * }
     */
    public static MethodHandle wl_array_add$handle() {
        return wl_array_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *wl_array_add(struct wl_array *array, size_t size)
     * }
     */
    public static MemorySegment wl_array_add$address() {
        return wl_array_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *wl_array_add(struct wl_array *array, size_t size)
     * }
     */
    public static MemorySegment wl_array_add(MemorySegment array, long size) {
        var mh$ = wl_array_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_array_add", array, size);
            }
            return (MemorySegment)mh$.invokeExact(array, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_array_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_array_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wl_array_copy(struct wl_array *array, struct wl_array *source)
     * }
     */
    public static FunctionDescriptor wl_array_copy$descriptor() {
        return wl_array_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wl_array_copy(struct wl_array *array, struct wl_array *source)
     * }
     */
    public static MethodHandle wl_array_copy$handle() {
        return wl_array_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wl_array_copy(struct wl_array *array, struct wl_array *source)
     * }
     */
    public static MemorySegment wl_array_copy$address() {
        return wl_array_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wl_array_copy(struct wl_array *array, struct wl_array *source)
     * }
     */
    public static int wl_array_copy(MemorySegment array, MemorySegment source) {
        var mh$ = wl_array_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_array_copy", array, source);
            }
            return (int)mh$.invokeExact(array, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int32_t wl_fixed_t
     * }
     */
    public static final OfInt wl_fixed_t = C.C_INT;
    private static final int WL_ITERATOR_STOP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_iterator_result.WL_ITERATOR_STOP = 0
     * }
     */
    public static int WL_ITERATOR_STOP() {
        return WL_ITERATOR_STOP;
    }
    private static final int WL_ITERATOR_CONTINUE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_iterator_result.WL_ITERATOR_CONTINUE = 1
     * }
     */
    public static int WL_ITERATOR_CONTINUE() {
        return WL_ITERATOR_CONTINUE;
    }
    private static final int WL_EVENT_READABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WL_EVENT_READABLE = 1
     * }
     */
    public static int WL_EVENT_READABLE() {
        return WL_EVENT_READABLE;
    }
    private static final int WL_EVENT_WRITABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WL_EVENT_WRITABLE = 2
     * }
     */
    public static int WL_EVENT_WRITABLE() {
        return WL_EVENT_WRITABLE;
    }
    private static final int WL_EVENT_HANGUP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WL_EVENT_HANGUP = 4
     * }
     */
    public static int WL_EVENT_HANGUP() {
        return WL_EVENT_HANGUP;
    }
    private static final int WL_EVENT_ERROR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WL_EVENT_ERROR = 8
     * }
     */
    public static int WL_EVENT_ERROR() {
        return WL_EVENT_ERROR;
    }

    private static class wl_event_loop_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER    );

        public static final MemorySegment ADDR = C.findOrThrow("wl_event_loop_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_event_loop *wl_event_loop_create()
     * }
     */
    public static FunctionDescriptor wl_event_loop_create$descriptor() {
        return wl_event_loop_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_event_loop *wl_event_loop_create()
     * }
     */
    public static MethodHandle wl_event_loop_create$handle() {
        return wl_event_loop_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_event_loop *wl_event_loop_create()
     * }
     */
    public static MemorySegment wl_event_loop_create$address() {
        return wl_event_loop_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_event_loop *wl_event_loop_create()
     * }
     */
    public static MemorySegment wl_event_loop_create() {
        var mh$ = wl_event_loop_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_event_loop_create");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_event_loop_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_event_loop_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_event_loop_destroy(struct wl_event_loop *loop)
     * }
     */
    public static FunctionDescriptor wl_event_loop_destroy$descriptor() {
        return wl_event_loop_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_event_loop_destroy(struct wl_event_loop *loop)
     * }
     */
    public static MethodHandle wl_event_loop_destroy$handle() {
        return wl_event_loop_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_event_loop_destroy(struct wl_event_loop *loop)
     * }
     */
    public static MemorySegment wl_event_loop_destroy$address() {
        return wl_event_loop_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_event_loop_destroy(struct wl_event_loop *loop)
     * }
     */
    public static void wl_event_loop_destroy(MemorySegment loop) {
        var mh$ = wl_event_loop_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_event_loop_destroy", loop);
            }
            mh$.invokeExact(loop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_event_loop_add_fd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_event_loop_add_fd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_event_source *wl_event_loop_add_fd(struct wl_event_loop *loop, int fd, uint32_t mask, wl_event_loop_fd_func_t func, void *data)
     * }
     */
    public static FunctionDescriptor wl_event_loop_add_fd$descriptor() {
        return wl_event_loop_add_fd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_event_source *wl_event_loop_add_fd(struct wl_event_loop *loop, int fd, uint32_t mask, wl_event_loop_fd_func_t func, void *data)
     * }
     */
    public static MethodHandle wl_event_loop_add_fd$handle() {
        return wl_event_loop_add_fd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_event_source *wl_event_loop_add_fd(struct wl_event_loop *loop, int fd, uint32_t mask, wl_event_loop_fd_func_t func, void *data)
     * }
     */
    public static MemorySegment wl_event_loop_add_fd$address() {
        return wl_event_loop_add_fd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_event_source *wl_event_loop_add_fd(struct wl_event_loop *loop, int fd, uint32_t mask, wl_event_loop_fd_func_t func, void *data)
     * }
     */
    public static MemorySegment wl_event_loop_add_fd(MemorySegment loop, int fd, int mask, MemorySegment func, MemorySegment data) {
        var mh$ = wl_event_loop_add_fd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_event_loop_add_fd", loop, fd, mask, func, data);
            }
            return (MemorySegment)mh$.invokeExact(loop, fd, mask, func, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_event_source_fd_update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_event_source_fd_update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wl_event_source_fd_update(struct wl_event_source *source, uint32_t mask)
     * }
     */
    public static FunctionDescriptor wl_event_source_fd_update$descriptor() {
        return wl_event_source_fd_update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wl_event_source_fd_update(struct wl_event_source *source, uint32_t mask)
     * }
     */
    public static MethodHandle wl_event_source_fd_update$handle() {
        return wl_event_source_fd_update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wl_event_source_fd_update(struct wl_event_source *source, uint32_t mask)
     * }
     */
    public static MemorySegment wl_event_source_fd_update$address() {
        return wl_event_source_fd_update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wl_event_source_fd_update(struct wl_event_source *source, uint32_t mask)
     * }
     */
    public static int wl_event_source_fd_update(MemorySegment source, int mask) {
        var mh$ = wl_event_source_fd_update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_event_source_fd_update", source, mask);
            }
            return (int)mh$.invokeExact(source, mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_event_loop_add_timer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_event_loop_add_timer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_event_source *wl_event_loop_add_timer(struct wl_event_loop *loop, wl_event_loop_timer_func_t func, void *data)
     * }
     */
    public static FunctionDescriptor wl_event_loop_add_timer$descriptor() {
        return wl_event_loop_add_timer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_event_source *wl_event_loop_add_timer(struct wl_event_loop *loop, wl_event_loop_timer_func_t func, void *data)
     * }
     */
    public static MethodHandle wl_event_loop_add_timer$handle() {
        return wl_event_loop_add_timer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_event_source *wl_event_loop_add_timer(struct wl_event_loop *loop, wl_event_loop_timer_func_t func, void *data)
     * }
     */
    public static MemorySegment wl_event_loop_add_timer$address() {
        return wl_event_loop_add_timer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_event_source *wl_event_loop_add_timer(struct wl_event_loop *loop, wl_event_loop_timer_func_t func, void *data)
     * }
     */
    public static MemorySegment wl_event_loop_add_timer(MemorySegment loop, MemorySegment func, MemorySegment data) {
        var mh$ = wl_event_loop_add_timer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_event_loop_add_timer", loop, func, data);
            }
            return (MemorySegment)mh$.invokeExact(loop, func, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_event_loop_add_signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_event_loop_add_signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_event_source *wl_event_loop_add_signal(struct wl_event_loop *loop, int signal_number, wl_event_loop_signal_func_t func, void *data)
     * }
     */
    public static FunctionDescriptor wl_event_loop_add_signal$descriptor() {
        return wl_event_loop_add_signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_event_source *wl_event_loop_add_signal(struct wl_event_loop *loop, int signal_number, wl_event_loop_signal_func_t func, void *data)
     * }
     */
    public static MethodHandle wl_event_loop_add_signal$handle() {
        return wl_event_loop_add_signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_event_source *wl_event_loop_add_signal(struct wl_event_loop *loop, int signal_number, wl_event_loop_signal_func_t func, void *data)
     * }
     */
    public static MemorySegment wl_event_loop_add_signal$address() {
        return wl_event_loop_add_signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_event_source *wl_event_loop_add_signal(struct wl_event_loop *loop, int signal_number, wl_event_loop_signal_func_t func, void *data)
     * }
     */
    public static MemorySegment wl_event_loop_add_signal(MemorySegment loop, int signal_number, MemorySegment func, MemorySegment data) {
        var mh$ = wl_event_loop_add_signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_event_loop_add_signal", loop, signal_number, func, data);
            }
            return (MemorySegment)mh$.invokeExact(loop, signal_number, func, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_event_source_timer_update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_event_source_timer_update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wl_event_source_timer_update(struct wl_event_source *source, int ms_delay)
     * }
     */
    public static FunctionDescriptor wl_event_source_timer_update$descriptor() {
        return wl_event_source_timer_update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wl_event_source_timer_update(struct wl_event_source *source, int ms_delay)
     * }
     */
    public static MethodHandle wl_event_source_timer_update$handle() {
        return wl_event_source_timer_update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wl_event_source_timer_update(struct wl_event_source *source, int ms_delay)
     * }
     */
    public static MemorySegment wl_event_source_timer_update$address() {
        return wl_event_source_timer_update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wl_event_source_timer_update(struct wl_event_source *source, int ms_delay)
     * }
     */
    public static int wl_event_source_timer_update(MemorySegment source, int ms_delay) {
        var mh$ = wl_event_source_timer_update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_event_source_timer_update", source, ms_delay);
            }
            return (int)mh$.invokeExact(source, ms_delay);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_event_source_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_event_source_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wl_event_source_remove(struct wl_event_source *source)
     * }
     */
    public static FunctionDescriptor wl_event_source_remove$descriptor() {
        return wl_event_source_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wl_event_source_remove(struct wl_event_source *source)
     * }
     */
    public static MethodHandle wl_event_source_remove$handle() {
        return wl_event_source_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wl_event_source_remove(struct wl_event_source *source)
     * }
     */
    public static MemorySegment wl_event_source_remove$address() {
        return wl_event_source_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wl_event_source_remove(struct wl_event_source *source)
     * }
     */
    public static int wl_event_source_remove(MemorySegment source) {
        var mh$ = wl_event_source_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_event_source_remove", source);
            }
            return (int)mh$.invokeExact(source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_event_source_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_event_source_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_event_source_check(struct wl_event_source *source)
     * }
     */
    public static FunctionDescriptor wl_event_source_check$descriptor() {
        return wl_event_source_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_event_source_check(struct wl_event_source *source)
     * }
     */
    public static MethodHandle wl_event_source_check$handle() {
        return wl_event_source_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_event_source_check(struct wl_event_source *source)
     * }
     */
    public static MemorySegment wl_event_source_check$address() {
        return wl_event_source_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_event_source_check(struct wl_event_source *source)
     * }
     */
    public static void wl_event_source_check(MemorySegment source) {
        var mh$ = wl_event_source_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_event_source_check", source);
            }
            mh$.invokeExact(source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_event_loop_dispatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_event_loop_dispatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wl_event_loop_dispatch(struct wl_event_loop *loop, int timeout)
     * }
     */
    public static FunctionDescriptor wl_event_loop_dispatch$descriptor() {
        return wl_event_loop_dispatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wl_event_loop_dispatch(struct wl_event_loop *loop, int timeout)
     * }
     */
    public static MethodHandle wl_event_loop_dispatch$handle() {
        return wl_event_loop_dispatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wl_event_loop_dispatch(struct wl_event_loop *loop, int timeout)
     * }
     */
    public static MemorySegment wl_event_loop_dispatch$address() {
        return wl_event_loop_dispatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wl_event_loop_dispatch(struct wl_event_loop *loop, int timeout)
     * }
     */
    public static int wl_event_loop_dispatch(MemorySegment loop, int timeout) {
        var mh$ = wl_event_loop_dispatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_event_loop_dispatch", loop, timeout);
            }
            return (int)mh$.invokeExact(loop, timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_event_loop_dispatch_idle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_event_loop_dispatch_idle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_event_loop_dispatch_idle(struct wl_event_loop *loop)
     * }
     */
    public static FunctionDescriptor wl_event_loop_dispatch_idle$descriptor() {
        return wl_event_loop_dispatch_idle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_event_loop_dispatch_idle(struct wl_event_loop *loop)
     * }
     */
    public static MethodHandle wl_event_loop_dispatch_idle$handle() {
        return wl_event_loop_dispatch_idle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_event_loop_dispatch_idle(struct wl_event_loop *loop)
     * }
     */
    public static MemorySegment wl_event_loop_dispatch_idle$address() {
        return wl_event_loop_dispatch_idle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_event_loop_dispatch_idle(struct wl_event_loop *loop)
     * }
     */
    public static void wl_event_loop_dispatch_idle(MemorySegment loop) {
        var mh$ = wl_event_loop_dispatch_idle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_event_loop_dispatch_idle", loop);
            }
            mh$.invokeExact(loop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_event_loop_add_idle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_event_loop_add_idle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_event_source *wl_event_loop_add_idle(struct wl_event_loop *loop, wl_event_loop_idle_func_t func, void *data)
     * }
     */
    public static FunctionDescriptor wl_event_loop_add_idle$descriptor() {
        return wl_event_loop_add_idle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_event_source *wl_event_loop_add_idle(struct wl_event_loop *loop, wl_event_loop_idle_func_t func, void *data)
     * }
     */
    public static MethodHandle wl_event_loop_add_idle$handle() {
        return wl_event_loop_add_idle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_event_source *wl_event_loop_add_idle(struct wl_event_loop *loop, wl_event_loop_idle_func_t func, void *data)
     * }
     */
    public static MemorySegment wl_event_loop_add_idle$address() {
        return wl_event_loop_add_idle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_event_source *wl_event_loop_add_idle(struct wl_event_loop *loop, wl_event_loop_idle_func_t func, void *data)
     * }
     */
    public static MemorySegment wl_event_loop_add_idle(MemorySegment loop, MemorySegment func, MemorySegment data) {
        var mh$ = wl_event_loop_add_idle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_event_loop_add_idle", loop, func, data);
            }
            return (MemorySegment)mh$.invokeExact(loop, func, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_event_loop_get_fd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_event_loop_get_fd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wl_event_loop_get_fd(struct wl_event_loop *loop)
     * }
     */
    public static FunctionDescriptor wl_event_loop_get_fd$descriptor() {
        return wl_event_loop_get_fd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wl_event_loop_get_fd(struct wl_event_loop *loop)
     * }
     */
    public static MethodHandle wl_event_loop_get_fd$handle() {
        return wl_event_loop_get_fd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wl_event_loop_get_fd(struct wl_event_loop *loop)
     * }
     */
    public static MemorySegment wl_event_loop_get_fd$address() {
        return wl_event_loop_get_fd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wl_event_loop_get_fd(struct wl_event_loop *loop)
     * }
     */
    public static int wl_event_loop_get_fd(MemorySegment loop) {
        var mh$ = wl_event_loop_get_fd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_event_loop_get_fd", loop);
            }
            return (int)mh$.invokeExact(loop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_event_loop_add_destroy_listener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_event_loop_add_destroy_listener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_event_loop_add_destroy_listener(struct wl_event_loop *loop, struct wl_listener *listener)
     * }
     */
    public static FunctionDescriptor wl_event_loop_add_destroy_listener$descriptor() {
        return wl_event_loop_add_destroy_listener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_event_loop_add_destroy_listener(struct wl_event_loop *loop, struct wl_listener *listener)
     * }
     */
    public static MethodHandle wl_event_loop_add_destroy_listener$handle() {
        return wl_event_loop_add_destroy_listener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_event_loop_add_destroy_listener(struct wl_event_loop *loop, struct wl_listener *listener)
     * }
     */
    public static MemorySegment wl_event_loop_add_destroy_listener$address() {
        return wl_event_loop_add_destroy_listener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_event_loop_add_destroy_listener(struct wl_event_loop *loop, struct wl_listener *listener)
     * }
     */
    public static void wl_event_loop_add_destroy_listener(MemorySegment loop, MemorySegment listener) {
        var mh$ = wl_event_loop_add_destroy_listener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_event_loop_add_destroy_listener", loop, listener);
            }
            mh$.invokeExact(loop, listener);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_event_loop_get_destroy_listener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_event_loop_get_destroy_listener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_listener *wl_event_loop_get_destroy_listener(struct wl_event_loop *loop, wl_notify_func_t notify)
     * }
     */
    public static FunctionDescriptor wl_event_loop_get_destroy_listener$descriptor() {
        return wl_event_loop_get_destroy_listener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_listener *wl_event_loop_get_destroy_listener(struct wl_event_loop *loop, wl_notify_func_t notify)
     * }
     */
    public static MethodHandle wl_event_loop_get_destroy_listener$handle() {
        return wl_event_loop_get_destroy_listener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_listener *wl_event_loop_get_destroy_listener(struct wl_event_loop *loop, wl_notify_func_t notify)
     * }
     */
    public static MemorySegment wl_event_loop_get_destroy_listener$address() {
        return wl_event_loop_get_destroy_listener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_listener *wl_event_loop_get_destroy_listener(struct wl_event_loop *loop, wl_notify_func_t notify)
     * }
     */
    public static MemorySegment wl_event_loop_get_destroy_listener(MemorySegment loop, MemorySegment notify) {
        var mh$ = wl_event_loop_get_destroy_listener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_event_loop_get_destroy_listener", loop, notify);
            }
            return (MemorySegment)mh$.invokeExact(loop, notify);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER    );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_display *wl_display_create()
     * }
     */
    public static FunctionDescriptor wl_display_create$descriptor() {
        return wl_display_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_display *wl_display_create()
     * }
     */
    public static MethodHandle wl_display_create$handle() {
        return wl_display_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_display *wl_display_create()
     * }
     */
    public static MemorySegment wl_display_create$address() {
        return wl_display_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_display *wl_display_create()
     * }
     */
    public static MemorySegment wl_display_create() {
        var mh$ = wl_display_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_create");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_display_destroy(struct wl_display *display)
     * }
     */
    public static FunctionDescriptor wl_display_destroy$descriptor() {
        return wl_display_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_display_destroy(struct wl_display *display)
     * }
     */
    public static MethodHandle wl_display_destroy$handle() {
        return wl_display_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_display_destroy(struct wl_display *display)
     * }
     */
    public static MemorySegment wl_display_destroy$address() {
        return wl_display_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_display_destroy(struct wl_display *display)
     * }
     */
    public static void wl_display_destroy(MemorySegment display) {
        var mh$ = wl_display_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_destroy", display);
            }
            mh$.invokeExact(display);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_get_event_loop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_get_event_loop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_event_loop *wl_display_get_event_loop(struct wl_display *display)
     * }
     */
    public static FunctionDescriptor wl_display_get_event_loop$descriptor() {
        return wl_display_get_event_loop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_event_loop *wl_display_get_event_loop(struct wl_display *display)
     * }
     */
    public static MethodHandle wl_display_get_event_loop$handle() {
        return wl_display_get_event_loop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_event_loop *wl_display_get_event_loop(struct wl_display *display)
     * }
     */
    public static MemorySegment wl_display_get_event_loop$address() {
        return wl_display_get_event_loop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_event_loop *wl_display_get_event_loop(struct wl_display *display)
     * }
     */
    public static MemorySegment wl_display_get_event_loop(MemorySegment display) {
        var mh$ = wl_display_get_event_loop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_get_event_loop", display);
            }
            return (MemorySegment)mh$.invokeExact(display);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_add_socket {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_add_socket");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wl_display_add_socket(struct wl_display *display, const char *name)
     * }
     */
    public static FunctionDescriptor wl_display_add_socket$descriptor() {
        return wl_display_add_socket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wl_display_add_socket(struct wl_display *display, const char *name)
     * }
     */
    public static MethodHandle wl_display_add_socket$handle() {
        return wl_display_add_socket.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wl_display_add_socket(struct wl_display *display, const char *name)
     * }
     */
    public static MemorySegment wl_display_add_socket$address() {
        return wl_display_add_socket.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wl_display_add_socket(struct wl_display *display, const char *name)
     * }
     */
    public static int wl_display_add_socket(MemorySegment display, MemorySegment name) {
        var mh$ = wl_display_add_socket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_add_socket", display, name);
            }
            return (int)mh$.invokeExact(display, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_add_socket_auto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_add_socket_auto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *wl_display_add_socket_auto(struct wl_display *display)
     * }
     */
    public static FunctionDescriptor wl_display_add_socket_auto$descriptor() {
        return wl_display_add_socket_auto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *wl_display_add_socket_auto(struct wl_display *display)
     * }
     */
    public static MethodHandle wl_display_add_socket_auto$handle() {
        return wl_display_add_socket_auto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *wl_display_add_socket_auto(struct wl_display *display)
     * }
     */
    public static MemorySegment wl_display_add_socket_auto$address() {
        return wl_display_add_socket_auto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *wl_display_add_socket_auto(struct wl_display *display)
     * }
     */
    public static MemorySegment wl_display_add_socket_auto(MemorySegment display) {
        var mh$ = wl_display_add_socket_auto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_add_socket_auto", display);
            }
            return (MemorySegment)mh$.invokeExact(display);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_add_socket_fd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_add_socket_fd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wl_display_add_socket_fd(struct wl_display *display, int sock_fd)
     * }
     */
    public static FunctionDescriptor wl_display_add_socket_fd$descriptor() {
        return wl_display_add_socket_fd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wl_display_add_socket_fd(struct wl_display *display, int sock_fd)
     * }
     */
    public static MethodHandle wl_display_add_socket_fd$handle() {
        return wl_display_add_socket_fd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wl_display_add_socket_fd(struct wl_display *display, int sock_fd)
     * }
     */
    public static MemorySegment wl_display_add_socket_fd$address() {
        return wl_display_add_socket_fd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wl_display_add_socket_fd(struct wl_display *display, int sock_fd)
     * }
     */
    public static int wl_display_add_socket_fd(MemorySegment display, int sock_fd) {
        var mh$ = wl_display_add_socket_fd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_add_socket_fd", display, sock_fd);
            }
            return (int)mh$.invokeExact(display, sock_fd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_terminate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_terminate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_display_terminate(struct wl_display *display)
     * }
     */
    public static FunctionDescriptor wl_display_terminate$descriptor() {
        return wl_display_terminate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_display_terminate(struct wl_display *display)
     * }
     */
    public static MethodHandle wl_display_terminate$handle() {
        return wl_display_terminate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_display_terminate(struct wl_display *display)
     * }
     */
    public static MemorySegment wl_display_terminate$address() {
        return wl_display_terminate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_display_terminate(struct wl_display *display)
     * }
     */
    public static void wl_display_terminate(MemorySegment display) {
        var mh$ = wl_display_terminate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_terminate", display);
            }
            mh$.invokeExact(display);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_run {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_run");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_display_run(struct wl_display *display)
     * }
     */
    public static FunctionDescriptor wl_display_run$descriptor() {
        return wl_display_run.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_display_run(struct wl_display *display)
     * }
     */
    public static MethodHandle wl_display_run$handle() {
        return wl_display_run.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_display_run(struct wl_display *display)
     * }
     */
    public static MemorySegment wl_display_run$address() {
        return wl_display_run.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_display_run(struct wl_display *display)
     * }
     */
    public static void wl_display_run(MemorySegment display) {
        var mh$ = wl_display_run.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_run", display);
            }
            mh$.invokeExact(display);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_flush_clients {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_flush_clients");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_display_flush_clients(struct wl_display *display)
     * }
     */
    public static FunctionDescriptor wl_display_flush_clients$descriptor() {
        return wl_display_flush_clients.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_display_flush_clients(struct wl_display *display)
     * }
     */
    public static MethodHandle wl_display_flush_clients$handle() {
        return wl_display_flush_clients.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_display_flush_clients(struct wl_display *display)
     * }
     */
    public static MemorySegment wl_display_flush_clients$address() {
        return wl_display_flush_clients.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_display_flush_clients(struct wl_display *display)
     * }
     */
    public static void wl_display_flush_clients(MemorySegment display) {
        var mh$ = wl_display_flush_clients.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_flush_clients", display);
            }
            mh$.invokeExact(display);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_destroy_clients {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_destroy_clients");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_display_destroy_clients(struct wl_display *display)
     * }
     */
    public static FunctionDescriptor wl_display_destroy_clients$descriptor() {
        return wl_display_destroy_clients.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_display_destroy_clients(struct wl_display *display)
     * }
     */
    public static MethodHandle wl_display_destroy_clients$handle() {
        return wl_display_destroy_clients.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_display_destroy_clients(struct wl_display *display)
     * }
     */
    public static MemorySegment wl_display_destroy_clients$address() {
        return wl_display_destroy_clients.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_display_destroy_clients(struct wl_display *display)
     * }
     */
    public static void wl_display_destroy_clients(MemorySegment display) {
        var mh$ = wl_display_destroy_clients.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_destroy_clients", display);
            }
            mh$.invokeExact(display);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_get_serial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_get_serial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t wl_display_get_serial(struct wl_display *display)
     * }
     */
    public static FunctionDescriptor wl_display_get_serial$descriptor() {
        return wl_display_get_serial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t wl_display_get_serial(struct wl_display *display)
     * }
     */
    public static MethodHandle wl_display_get_serial$handle() {
        return wl_display_get_serial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t wl_display_get_serial(struct wl_display *display)
     * }
     */
    public static MemorySegment wl_display_get_serial$address() {
        return wl_display_get_serial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t wl_display_get_serial(struct wl_display *display)
     * }
     */
    public static int wl_display_get_serial(MemorySegment display) {
        var mh$ = wl_display_get_serial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_get_serial", display);
            }
            return (int)mh$.invokeExact(display);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_next_serial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_next_serial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t wl_display_next_serial(struct wl_display *display)
     * }
     */
    public static FunctionDescriptor wl_display_next_serial$descriptor() {
        return wl_display_next_serial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t wl_display_next_serial(struct wl_display *display)
     * }
     */
    public static MethodHandle wl_display_next_serial$handle() {
        return wl_display_next_serial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t wl_display_next_serial(struct wl_display *display)
     * }
     */
    public static MemorySegment wl_display_next_serial$address() {
        return wl_display_next_serial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t wl_display_next_serial(struct wl_display *display)
     * }
     */
    public static int wl_display_next_serial(MemorySegment display) {
        var mh$ = wl_display_next_serial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_next_serial", display);
            }
            return (int)mh$.invokeExact(display);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_add_destroy_listener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_add_destroy_listener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_display_add_destroy_listener(struct wl_display *display, struct wl_listener *listener)
     * }
     */
    public static FunctionDescriptor wl_display_add_destroy_listener$descriptor() {
        return wl_display_add_destroy_listener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_display_add_destroy_listener(struct wl_display *display, struct wl_listener *listener)
     * }
     */
    public static MethodHandle wl_display_add_destroy_listener$handle() {
        return wl_display_add_destroy_listener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_display_add_destroy_listener(struct wl_display *display, struct wl_listener *listener)
     * }
     */
    public static MemorySegment wl_display_add_destroy_listener$address() {
        return wl_display_add_destroy_listener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_display_add_destroy_listener(struct wl_display *display, struct wl_listener *listener)
     * }
     */
    public static void wl_display_add_destroy_listener(MemorySegment display, MemorySegment listener) {
        var mh$ = wl_display_add_destroy_listener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_add_destroy_listener", display, listener);
            }
            mh$.invokeExact(display, listener);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_add_client_created_listener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_add_client_created_listener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_display_add_client_created_listener(struct wl_display *display, struct wl_listener *listener)
     * }
     */
    public static FunctionDescriptor wl_display_add_client_created_listener$descriptor() {
        return wl_display_add_client_created_listener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_display_add_client_created_listener(struct wl_display *display, struct wl_listener *listener)
     * }
     */
    public static MethodHandle wl_display_add_client_created_listener$handle() {
        return wl_display_add_client_created_listener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_display_add_client_created_listener(struct wl_display *display, struct wl_listener *listener)
     * }
     */
    public static MemorySegment wl_display_add_client_created_listener$address() {
        return wl_display_add_client_created_listener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_display_add_client_created_listener(struct wl_display *display, struct wl_listener *listener)
     * }
     */
    public static void wl_display_add_client_created_listener(MemorySegment display, MemorySegment listener) {
        var mh$ = wl_display_add_client_created_listener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_add_client_created_listener", display, listener);
            }
            mh$.invokeExact(display, listener);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_get_destroy_listener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_get_destroy_listener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_listener *wl_display_get_destroy_listener(struct wl_display *display, wl_notify_func_t notify)
     * }
     */
    public static FunctionDescriptor wl_display_get_destroy_listener$descriptor() {
        return wl_display_get_destroy_listener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_listener *wl_display_get_destroy_listener(struct wl_display *display, wl_notify_func_t notify)
     * }
     */
    public static MethodHandle wl_display_get_destroy_listener$handle() {
        return wl_display_get_destroy_listener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_listener *wl_display_get_destroy_listener(struct wl_display *display, wl_notify_func_t notify)
     * }
     */
    public static MemorySegment wl_display_get_destroy_listener$address() {
        return wl_display_get_destroy_listener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_listener *wl_display_get_destroy_listener(struct wl_display *display, wl_notify_func_t notify)
     * }
     */
    public static MemorySegment wl_display_get_destroy_listener(MemorySegment display, MemorySegment notify) {
        var mh$ = wl_display_get_destroy_listener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_get_destroy_listener", display, notify);
            }
            return (MemorySegment)mh$.invokeExact(display, notify);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_global_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_global_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_global *wl_global_create(struct wl_display *display, const struct wl_interface *interface, int version, void *data, wl_global_bind_func_t bind)
     * }
     */
    public static FunctionDescriptor wl_global_create$descriptor() {
        return wl_global_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_global *wl_global_create(struct wl_display *display, const struct wl_interface *interface, int version, void *data, wl_global_bind_func_t bind)
     * }
     */
    public static MethodHandle wl_global_create$handle() {
        return wl_global_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_global *wl_global_create(struct wl_display *display, const struct wl_interface *interface, int version, void *data, wl_global_bind_func_t bind)
     * }
     */
    public static MemorySegment wl_global_create$address() {
        return wl_global_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_global *wl_global_create(struct wl_display *display, const struct wl_interface *interface, int version, void *data, wl_global_bind_func_t bind)
     * }
     */
    public static MemorySegment wl_global_create(MemorySegment display, MemorySegment interface_, int version, MemorySegment data, MemorySegment bind) {
        var mh$ = wl_global_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_global_create", display, interface_, version, data, bind);
            }
            return (MemorySegment)mh$.invokeExact(display, interface_, version, data, bind);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_global_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_global_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_global_remove(struct wl_global *global)
     * }
     */
    public static FunctionDescriptor wl_global_remove$descriptor() {
        return wl_global_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_global_remove(struct wl_global *global)
     * }
     */
    public static MethodHandle wl_global_remove$handle() {
        return wl_global_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_global_remove(struct wl_global *global)
     * }
     */
    public static MemorySegment wl_global_remove$address() {
        return wl_global_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_global_remove(struct wl_global *global)
     * }
     */
    public static void wl_global_remove(MemorySegment global) {
        var mh$ = wl_global_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_global_remove", global);
            }
            mh$.invokeExact(global);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_global_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_global_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_global_destroy(struct wl_global *global)
     * }
     */
    public static FunctionDescriptor wl_global_destroy$descriptor() {
        return wl_global_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_global_destroy(struct wl_global *global)
     * }
     */
    public static MethodHandle wl_global_destroy$handle() {
        return wl_global_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_global_destroy(struct wl_global *global)
     * }
     */
    public static MemorySegment wl_global_destroy$address() {
        return wl_global_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_global_destroy(struct wl_global *global)
     * }
     */
    public static void wl_global_destroy(MemorySegment global) {
        var mh$ = wl_global_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_global_destroy", global);
            }
            mh$.invokeExact(global);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_set_global_filter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_set_global_filter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_display_set_global_filter(struct wl_display *display, wl_display_global_filter_func_t filter, void *data)
     * }
     */
    public static FunctionDescriptor wl_display_set_global_filter$descriptor() {
        return wl_display_set_global_filter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_display_set_global_filter(struct wl_display *display, wl_display_global_filter_func_t filter, void *data)
     * }
     */
    public static MethodHandle wl_display_set_global_filter$handle() {
        return wl_display_set_global_filter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_display_set_global_filter(struct wl_display *display, wl_display_global_filter_func_t filter, void *data)
     * }
     */
    public static MemorySegment wl_display_set_global_filter$address() {
        return wl_display_set_global_filter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_display_set_global_filter(struct wl_display *display, wl_display_global_filter_func_t filter, void *data)
     * }
     */
    public static void wl_display_set_global_filter(MemorySegment display, MemorySegment filter, MemorySegment data) {
        var mh$ = wl_display_set_global_filter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_set_global_filter", display, filter, data);
            }
            mh$.invokeExact(display, filter, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_global_get_interface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_global_get_interface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const struct wl_interface *wl_global_get_interface(const struct wl_global *global)
     * }
     */
    public static FunctionDescriptor wl_global_get_interface$descriptor() {
        return wl_global_get_interface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const struct wl_interface *wl_global_get_interface(const struct wl_global *global)
     * }
     */
    public static MethodHandle wl_global_get_interface$handle() {
        return wl_global_get_interface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const struct wl_interface *wl_global_get_interface(const struct wl_global *global)
     * }
     */
    public static MemorySegment wl_global_get_interface$address() {
        return wl_global_get_interface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const struct wl_interface *wl_global_get_interface(const struct wl_global *global)
     * }
     */
    public static MemorySegment wl_global_get_interface(MemorySegment global) {
        var mh$ = wl_global_get_interface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_global_get_interface", global);
            }
            return (MemorySegment)mh$.invokeExact(global);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_global_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_global_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t wl_global_get_name(const struct wl_global *global, const struct wl_client *client)
     * }
     */
    public static FunctionDescriptor wl_global_get_name$descriptor() {
        return wl_global_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t wl_global_get_name(const struct wl_global *global, const struct wl_client *client)
     * }
     */
    public static MethodHandle wl_global_get_name$handle() {
        return wl_global_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t wl_global_get_name(const struct wl_global *global, const struct wl_client *client)
     * }
     */
    public static MemorySegment wl_global_get_name$address() {
        return wl_global_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t wl_global_get_name(const struct wl_global *global, const struct wl_client *client)
     * }
     */
    public static int wl_global_get_name(MemorySegment global, MemorySegment client) {
        var mh$ = wl_global_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_global_get_name", global, client);
            }
            return (int)mh$.invokeExact(global, client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_global_get_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_global_get_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t wl_global_get_version(const struct wl_global *global)
     * }
     */
    public static FunctionDescriptor wl_global_get_version$descriptor() {
        return wl_global_get_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t wl_global_get_version(const struct wl_global *global)
     * }
     */
    public static MethodHandle wl_global_get_version$handle() {
        return wl_global_get_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t wl_global_get_version(const struct wl_global *global)
     * }
     */
    public static MemorySegment wl_global_get_version$address() {
        return wl_global_get_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t wl_global_get_version(const struct wl_global *global)
     * }
     */
    public static int wl_global_get_version(MemorySegment global) {
        var mh$ = wl_global_get_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_global_get_version", global);
            }
            return (int)mh$.invokeExact(global);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_global_get_display {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_global_get_display");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_display *wl_global_get_display(const struct wl_global *global)
     * }
     */
    public static FunctionDescriptor wl_global_get_display$descriptor() {
        return wl_global_get_display.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_display *wl_global_get_display(const struct wl_global *global)
     * }
     */
    public static MethodHandle wl_global_get_display$handle() {
        return wl_global_get_display.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_display *wl_global_get_display(const struct wl_global *global)
     * }
     */
    public static MemorySegment wl_global_get_display$address() {
        return wl_global_get_display.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_display *wl_global_get_display(const struct wl_global *global)
     * }
     */
    public static MemorySegment wl_global_get_display(MemorySegment global) {
        var mh$ = wl_global_get_display.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_global_get_display", global);
            }
            return (MemorySegment)mh$.invokeExact(global);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_global_get_user_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_global_get_user_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *wl_global_get_user_data(const struct wl_global *global)
     * }
     */
    public static FunctionDescriptor wl_global_get_user_data$descriptor() {
        return wl_global_get_user_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *wl_global_get_user_data(const struct wl_global *global)
     * }
     */
    public static MethodHandle wl_global_get_user_data$handle() {
        return wl_global_get_user_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *wl_global_get_user_data(const struct wl_global *global)
     * }
     */
    public static MemorySegment wl_global_get_user_data$address() {
        return wl_global_get_user_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *wl_global_get_user_data(const struct wl_global *global)
     * }
     */
    public static MemorySegment wl_global_get_user_data(MemorySegment global) {
        var mh$ = wl_global_get_user_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_global_get_user_data", global);
            }
            return (MemorySegment)mh$.invokeExact(global);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_global_set_user_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_global_set_user_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_global_set_user_data(struct wl_global *global, void *data)
     * }
     */
    public static FunctionDescriptor wl_global_set_user_data$descriptor() {
        return wl_global_set_user_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_global_set_user_data(struct wl_global *global, void *data)
     * }
     */
    public static MethodHandle wl_global_set_user_data$handle() {
        return wl_global_set_user_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_global_set_user_data(struct wl_global *global, void *data)
     * }
     */
    public static MemorySegment wl_global_set_user_data$address() {
        return wl_global_set_user_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_global_set_user_data(struct wl_global *global, void *data)
     * }
     */
    public static void wl_global_set_user_data(MemorySegment global, MemorySegment data) {
        var mh$ = wl_global_set_user_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_global_set_user_data", global, data);
            }
            mh$.invokeExact(global, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_client_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_client_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_client *wl_client_create(struct wl_display *display, int fd)
     * }
     */
    public static FunctionDescriptor wl_client_create$descriptor() {
        return wl_client_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_client *wl_client_create(struct wl_display *display, int fd)
     * }
     */
    public static MethodHandle wl_client_create$handle() {
        return wl_client_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_client *wl_client_create(struct wl_display *display, int fd)
     * }
     */
    public static MemorySegment wl_client_create$address() {
        return wl_client_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_client *wl_client_create(struct wl_display *display, int fd)
     * }
     */
    public static MemorySegment wl_client_create(MemorySegment display, int fd) {
        var mh$ = wl_client_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_client_create", display, fd);
            }
            return (MemorySegment)mh$.invokeExact(display, fd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_get_client_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_get_client_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_list *wl_display_get_client_list(struct wl_display *display)
     * }
     */
    public static FunctionDescriptor wl_display_get_client_list$descriptor() {
        return wl_display_get_client_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_list *wl_display_get_client_list(struct wl_display *display)
     * }
     */
    public static MethodHandle wl_display_get_client_list$handle() {
        return wl_display_get_client_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_list *wl_display_get_client_list(struct wl_display *display)
     * }
     */
    public static MemorySegment wl_display_get_client_list$address() {
        return wl_display_get_client_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_list *wl_display_get_client_list(struct wl_display *display)
     * }
     */
    public static MemorySegment wl_display_get_client_list(MemorySegment display) {
        var mh$ = wl_display_get_client_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_get_client_list", display);
            }
            return (MemorySegment)mh$.invokeExact(display);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_client_get_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_client_get_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_list *wl_client_get_link(struct wl_client *client)
     * }
     */
    public static FunctionDescriptor wl_client_get_link$descriptor() {
        return wl_client_get_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_list *wl_client_get_link(struct wl_client *client)
     * }
     */
    public static MethodHandle wl_client_get_link$handle() {
        return wl_client_get_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_list *wl_client_get_link(struct wl_client *client)
     * }
     */
    public static MemorySegment wl_client_get_link$address() {
        return wl_client_get_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_list *wl_client_get_link(struct wl_client *client)
     * }
     */
    public static MemorySegment wl_client_get_link(MemorySegment client) {
        var mh$ = wl_client_get_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_client_get_link", client);
            }
            return (MemorySegment)mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_client_from_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_client_from_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_client *wl_client_from_link(struct wl_list *link)
     * }
     */
    public static FunctionDescriptor wl_client_from_link$descriptor() {
        return wl_client_from_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_client *wl_client_from_link(struct wl_list *link)
     * }
     */
    public static MethodHandle wl_client_from_link$handle() {
        return wl_client_from_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_client *wl_client_from_link(struct wl_list *link)
     * }
     */
    public static MemorySegment wl_client_from_link$address() {
        return wl_client_from_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_client *wl_client_from_link(struct wl_list *link)
     * }
     */
    public static MemorySegment wl_client_from_link(MemorySegment link) {
        var mh$ = wl_client_from_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_client_from_link", link);
            }
            return (MemorySegment)mh$.invokeExact(link);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_client_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_client_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_client_destroy(struct wl_client *client)
     * }
     */
    public static FunctionDescriptor wl_client_destroy$descriptor() {
        return wl_client_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_client_destroy(struct wl_client *client)
     * }
     */
    public static MethodHandle wl_client_destroy$handle() {
        return wl_client_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_client_destroy(struct wl_client *client)
     * }
     */
    public static MemorySegment wl_client_destroy$address() {
        return wl_client_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_client_destroy(struct wl_client *client)
     * }
     */
    public static void wl_client_destroy(MemorySegment client) {
        var mh$ = wl_client_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_client_destroy", client);
            }
            mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_client_flush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_client_flush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_client_flush(struct wl_client *client)
     * }
     */
    public static FunctionDescriptor wl_client_flush$descriptor() {
        return wl_client_flush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_client_flush(struct wl_client *client)
     * }
     */
    public static MethodHandle wl_client_flush$handle() {
        return wl_client_flush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_client_flush(struct wl_client *client)
     * }
     */
    public static MemorySegment wl_client_flush$address() {
        return wl_client_flush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_client_flush(struct wl_client *client)
     * }
     */
    public static void wl_client_flush(MemorySegment client) {
        var mh$ = wl_client_flush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_client_flush", client);
            }
            mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_client_get_credentials {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_client_get_credentials");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_client_get_credentials(struct wl_client *client, pid_t *pid, uid_t *uid, gid_t *gid)
     * }
     */
    public static FunctionDescriptor wl_client_get_credentials$descriptor() {
        return wl_client_get_credentials.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_client_get_credentials(struct wl_client *client, pid_t *pid, uid_t *uid, gid_t *gid)
     * }
     */
    public static MethodHandle wl_client_get_credentials$handle() {
        return wl_client_get_credentials.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_client_get_credentials(struct wl_client *client, pid_t *pid, uid_t *uid, gid_t *gid)
     * }
     */
    public static MemorySegment wl_client_get_credentials$address() {
        return wl_client_get_credentials.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_client_get_credentials(struct wl_client *client, pid_t *pid, uid_t *uid, gid_t *gid)
     * }
     */
    public static void wl_client_get_credentials(MemorySegment client, MemorySegment pid, MemorySegment uid, MemorySegment gid) {
        var mh$ = wl_client_get_credentials.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_client_get_credentials", client, pid, uid, gid);
            }
            mh$.invokeExact(client, pid, uid, gid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_client_get_fd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_client_get_fd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wl_client_get_fd(struct wl_client *client)
     * }
     */
    public static FunctionDescriptor wl_client_get_fd$descriptor() {
        return wl_client_get_fd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wl_client_get_fd(struct wl_client *client)
     * }
     */
    public static MethodHandle wl_client_get_fd$handle() {
        return wl_client_get_fd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wl_client_get_fd(struct wl_client *client)
     * }
     */
    public static MemorySegment wl_client_get_fd$address() {
        return wl_client_get_fd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wl_client_get_fd(struct wl_client *client)
     * }
     */
    public static int wl_client_get_fd(MemorySegment client) {
        var mh$ = wl_client_get_fd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_client_get_fd", client);
            }
            return (int)mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_client_add_destroy_listener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_client_add_destroy_listener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_client_add_destroy_listener(struct wl_client *client, struct wl_listener *listener)
     * }
     */
    public static FunctionDescriptor wl_client_add_destroy_listener$descriptor() {
        return wl_client_add_destroy_listener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_client_add_destroy_listener(struct wl_client *client, struct wl_listener *listener)
     * }
     */
    public static MethodHandle wl_client_add_destroy_listener$handle() {
        return wl_client_add_destroy_listener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_client_add_destroy_listener(struct wl_client *client, struct wl_listener *listener)
     * }
     */
    public static MemorySegment wl_client_add_destroy_listener$address() {
        return wl_client_add_destroy_listener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_client_add_destroy_listener(struct wl_client *client, struct wl_listener *listener)
     * }
     */
    public static void wl_client_add_destroy_listener(MemorySegment client, MemorySegment listener) {
        var mh$ = wl_client_add_destroy_listener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_client_add_destroy_listener", client, listener);
            }
            mh$.invokeExact(client, listener);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_client_get_destroy_listener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_client_get_destroy_listener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_listener *wl_client_get_destroy_listener(struct wl_client *client, wl_notify_func_t notify)
     * }
     */
    public static FunctionDescriptor wl_client_get_destroy_listener$descriptor() {
        return wl_client_get_destroy_listener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_listener *wl_client_get_destroy_listener(struct wl_client *client, wl_notify_func_t notify)
     * }
     */
    public static MethodHandle wl_client_get_destroy_listener$handle() {
        return wl_client_get_destroy_listener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_listener *wl_client_get_destroy_listener(struct wl_client *client, wl_notify_func_t notify)
     * }
     */
    public static MemorySegment wl_client_get_destroy_listener$address() {
        return wl_client_get_destroy_listener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_listener *wl_client_get_destroy_listener(struct wl_client *client, wl_notify_func_t notify)
     * }
     */
    public static MemorySegment wl_client_get_destroy_listener(MemorySegment client, MemorySegment notify) {
        var mh$ = wl_client_get_destroy_listener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_client_get_destroy_listener", client, notify);
            }
            return (MemorySegment)mh$.invokeExact(client, notify);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_client_add_destroy_late_listener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_client_add_destroy_late_listener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_client_add_destroy_late_listener(struct wl_client *client, struct wl_listener *listener)
     * }
     */
    public static FunctionDescriptor wl_client_add_destroy_late_listener$descriptor() {
        return wl_client_add_destroy_late_listener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_client_add_destroy_late_listener(struct wl_client *client, struct wl_listener *listener)
     * }
     */
    public static MethodHandle wl_client_add_destroy_late_listener$handle() {
        return wl_client_add_destroy_late_listener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_client_add_destroy_late_listener(struct wl_client *client, struct wl_listener *listener)
     * }
     */
    public static MemorySegment wl_client_add_destroy_late_listener$address() {
        return wl_client_add_destroy_late_listener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_client_add_destroy_late_listener(struct wl_client *client, struct wl_listener *listener)
     * }
     */
    public static void wl_client_add_destroy_late_listener(MemorySegment client, MemorySegment listener) {
        var mh$ = wl_client_add_destroy_late_listener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_client_add_destroy_late_listener", client, listener);
            }
            mh$.invokeExact(client, listener);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_client_get_destroy_late_listener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_client_get_destroy_late_listener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_listener *wl_client_get_destroy_late_listener(struct wl_client *client, wl_notify_func_t notify)
     * }
     */
    public static FunctionDescriptor wl_client_get_destroy_late_listener$descriptor() {
        return wl_client_get_destroy_late_listener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_listener *wl_client_get_destroy_late_listener(struct wl_client *client, wl_notify_func_t notify)
     * }
     */
    public static MethodHandle wl_client_get_destroy_late_listener$handle() {
        return wl_client_get_destroy_late_listener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_listener *wl_client_get_destroy_late_listener(struct wl_client *client, wl_notify_func_t notify)
     * }
     */
    public static MemorySegment wl_client_get_destroy_late_listener$address() {
        return wl_client_get_destroy_late_listener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_listener *wl_client_get_destroy_late_listener(struct wl_client *client, wl_notify_func_t notify)
     * }
     */
    public static MemorySegment wl_client_get_destroy_late_listener(MemorySegment client, MemorySegment notify) {
        var mh$ = wl_client_get_destroy_late_listener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_client_get_destroy_late_listener", client, notify);
            }
            return (MemorySegment)mh$.invokeExact(client, notify);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_client_get_object {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_client_get_object");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_resource *wl_client_get_object(struct wl_client *client, uint32_t id)
     * }
     */
    public static FunctionDescriptor wl_client_get_object$descriptor() {
        return wl_client_get_object.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_resource *wl_client_get_object(struct wl_client *client, uint32_t id)
     * }
     */
    public static MethodHandle wl_client_get_object$handle() {
        return wl_client_get_object.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_resource *wl_client_get_object(struct wl_client *client, uint32_t id)
     * }
     */
    public static MemorySegment wl_client_get_object$address() {
        return wl_client_get_object.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_resource *wl_client_get_object(struct wl_client *client, uint32_t id)
     * }
     */
    public static MemorySegment wl_client_get_object(MemorySegment client, int id) {
        var mh$ = wl_client_get_object.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_client_get_object", client, id);
            }
            return (MemorySegment)mh$.invokeExact(client, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_client_post_no_memory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_client_post_no_memory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_client_post_no_memory(struct wl_client *client)
     * }
     */
    public static FunctionDescriptor wl_client_post_no_memory$descriptor() {
        return wl_client_post_no_memory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_client_post_no_memory(struct wl_client *client)
     * }
     */
    public static MethodHandle wl_client_post_no_memory$handle() {
        return wl_client_post_no_memory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_client_post_no_memory(struct wl_client *client)
     * }
     */
    public static MemorySegment wl_client_post_no_memory$address() {
        return wl_client_post_no_memory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_client_post_no_memory(struct wl_client *client)
     * }
     */
    public static void wl_client_post_no_memory(MemorySegment client) {
        var mh$ = wl_client_post_no_memory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_client_post_no_memory", client);
            }
            mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void wl_client_post_implementation_error(struct wl_client *client, const char *msg, ...)
     * }
     */
    public static class wl_client_post_implementation_error {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                C.C_POINTER,
                C.C_POINTER
            );
        private static final MemorySegment ADDR = C.findOrThrow("wl_client_post_implementation_error");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private wl_client_post_implementation_error(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void wl_client_post_implementation_error(struct wl_client *client, const char *msg, ...)
         * }
         */
        public static wl_client_post_implementation_error makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new wl_client_post_implementation_error(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment client, MemorySegment msg, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("wl_client_post_implementation_error", client, msg, x2);
                }
                 spreader.invokeExact(client, msg, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class wl_client_add_resource_created_listener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_client_add_resource_created_listener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_client_add_resource_created_listener(struct wl_client *client, struct wl_listener *listener)
     * }
     */
    public static FunctionDescriptor wl_client_add_resource_created_listener$descriptor() {
        return wl_client_add_resource_created_listener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_client_add_resource_created_listener(struct wl_client *client, struct wl_listener *listener)
     * }
     */
    public static MethodHandle wl_client_add_resource_created_listener$handle() {
        return wl_client_add_resource_created_listener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_client_add_resource_created_listener(struct wl_client *client, struct wl_listener *listener)
     * }
     */
    public static MemorySegment wl_client_add_resource_created_listener$address() {
        return wl_client_add_resource_created_listener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_client_add_resource_created_listener(struct wl_client *client, struct wl_listener *listener)
     * }
     */
    public static void wl_client_add_resource_created_listener(MemorySegment client, MemorySegment listener) {
        var mh$ = wl_client_add_resource_created_listener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_client_add_resource_created_listener", client, listener);
            }
            mh$.invokeExact(client, listener);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_client_for_each_resource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_client_for_each_resource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_client_for_each_resource(struct wl_client *client, wl_client_for_each_resource_iterator_func_t iterator, void *user_data)
     * }
     */
    public static FunctionDescriptor wl_client_for_each_resource$descriptor() {
        return wl_client_for_each_resource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_client_for_each_resource(struct wl_client *client, wl_client_for_each_resource_iterator_func_t iterator, void *user_data)
     * }
     */
    public static MethodHandle wl_client_for_each_resource$handle() {
        return wl_client_for_each_resource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_client_for_each_resource(struct wl_client *client, wl_client_for_each_resource_iterator_func_t iterator, void *user_data)
     * }
     */
    public static MemorySegment wl_client_for_each_resource$address() {
        return wl_client_for_each_resource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_client_for_each_resource(struct wl_client *client, wl_client_for_each_resource_iterator_func_t iterator, void *user_data)
     * }
     */
    public static void wl_client_for_each_resource(MemorySegment client, MemorySegment iterator, MemorySegment user_data) {
        var mh$ = wl_client_for_each_resource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_client_for_each_resource", client, iterator, user_data);
            }
            mh$.invokeExact(client, iterator, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_signal_emit_mutable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_signal_emit_mutable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_signal_emit_mutable(struct wl_signal *signal, void *data)
     * }
     */
    public static FunctionDescriptor wl_signal_emit_mutable$descriptor() {
        return wl_signal_emit_mutable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_signal_emit_mutable(struct wl_signal *signal, void *data)
     * }
     */
    public static MethodHandle wl_signal_emit_mutable$handle() {
        return wl_signal_emit_mutable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_signal_emit_mutable(struct wl_signal *signal, void *data)
     * }
     */
    public static MemorySegment wl_signal_emit_mutable$address() {
        return wl_signal_emit_mutable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_signal_emit_mutable(struct wl_signal *signal, void *data)
     * }
     */
    public static void wl_signal_emit_mutable(MemorySegment signal, MemorySegment data) {
        var mh$ = wl_signal_emit_mutable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_signal_emit_mutable", signal, data);
            }
            mh$.invokeExact(signal, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void wl_resource_post_event(struct wl_resource *resource, uint32_t opcode, ...)
     * }
     */
    public static class wl_resource_post_event {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                C.C_POINTER,
                C.C_INT
            );
        private static final MemorySegment ADDR = C.findOrThrow("wl_resource_post_event");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private wl_resource_post_event(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void wl_resource_post_event(struct wl_resource *resource, uint32_t opcode, ...)
         * }
         */
        public static wl_resource_post_event makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new wl_resource_post_event(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment resource, int opcode, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("wl_resource_post_event", resource, opcode, x2);
                }
                 spreader.invokeExact(resource, opcode, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class wl_resource_post_event_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_resource_post_event_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_resource_post_event_array(struct wl_resource *resource, uint32_t opcode, union wl_argument *args)
     * }
     */
    public static FunctionDescriptor wl_resource_post_event_array$descriptor() {
        return wl_resource_post_event_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_resource_post_event_array(struct wl_resource *resource, uint32_t opcode, union wl_argument *args)
     * }
     */
    public static MethodHandle wl_resource_post_event_array$handle() {
        return wl_resource_post_event_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_resource_post_event_array(struct wl_resource *resource, uint32_t opcode, union wl_argument *args)
     * }
     */
    public static MemorySegment wl_resource_post_event_array$address() {
        return wl_resource_post_event_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_resource_post_event_array(struct wl_resource *resource, uint32_t opcode, union wl_argument *args)
     * }
     */
    public static void wl_resource_post_event_array(MemorySegment resource, int opcode, MemorySegment args) {
        var mh$ = wl_resource_post_event_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_resource_post_event_array", resource, opcode, args);
            }
            mh$.invokeExact(resource, opcode, args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void wl_resource_queue_event(struct wl_resource *resource, uint32_t opcode, ...)
     * }
     */
    public static class wl_resource_queue_event {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                C.C_POINTER,
                C.C_INT
            );
        private static final MemorySegment ADDR = C.findOrThrow("wl_resource_queue_event");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private wl_resource_queue_event(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void wl_resource_queue_event(struct wl_resource *resource, uint32_t opcode, ...)
         * }
         */
        public static wl_resource_queue_event makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new wl_resource_queue_event(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment resource, int opcode, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("wl_resource_queue_event", resource, opcode, x2);
                }
                 spreader.invokeExact(resource, opcode, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class wl_resource_queue_event_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_resource_queue_event_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_resource_queue_event_array(struct wl_resource *resource, uint32_t opcode, union wl_argument *args)
     * }
     */
    public static FunctionDescriptor wl_resource_queue_event_array$descriptor() {
        return wl_resource_queue_event_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_resource_queue_event_array(struct wl_resource *resource, uint32_t opcode, union wl_argument *args)
     * }
     */
    public static MethodHandle wl_resource_queue_event_array$handle() {
        return wl_resource_queue_event_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_resource_queue_event_array(struct wl_resource *resource, uint32_t opcode, union wl_argument *args)
     * }
     */
    public static MemorySegment wl_resource_queue_event_array$address() {
        return wl_resource_queue_event_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_resource_queue_event_array(struct wl_resource *resource, uint32_t opcode, union wl_argument *args)
     * }
     */
    public static void wl_resource_queue_event_array(MemorySegment resource, int opcode, MemorySegment args) {
        var mh$ = wl_resource_queue_event_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_resource_queue_event_array", resource, opcode, args);
            }
            mh$.invokeExact(resource, opcode, args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void wl_resource_post_error(struct wl_resource *resource, uint32_t code, const char *msg, ...)
     * }
     */
    public static class wl_resource_post_error {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                C.C_POINTER,
                C.C_INT,
                C.C_POINTER
            );
        private static final MemorySegment ADDR = C.findOrThrow("wl_resource_post_error");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private wl_resource_post_error(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void wl_resource_post_error(struct wl_resource *resource, uint32_t code, const char *msg, ...)
         * }
         */
        public static wl_resource_post_error makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new wl_resource_post_error(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment resource, int code, MemorySegment msg, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("wl_resource_post_error", resource, code, msg, x3);
                }
                 spreader.invokeExact(resource, code, msg, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class wl_resource_post_no_memory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_resource_post_no_memory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_resource_post_no_memory(struct wl_resource *resource)
     * }
     */
    public static FunctionDescriptor wl_resource_post_no_memory$descriptor() {
        return wl_resource_post_no_memory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_resource_post_no_memory(struct wl_resource *resource)
     * }
     */
    public static MethodHandle wl_resource_post_no_memory$handle() {
        return wl_resource_post_no_memory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_resource_post_no_memory(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wl_resource_post_no_memory$address() {
        return wl_resource_post_no_memory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_resource_post_no_memory(struct wl_resource *resource)
     * }
     */
    public static void wl_resource_post_no_memory(MemorySegment resource) {
        var mh$ = wl_resource_post_no_memory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_resource_post_no_memory", resource);
            }
            mh$.invokeExact(resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_client_get_display {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_client_get_display");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_display *wl_client_get_display(struct wl_client *client)
     * }
     */
    public static FunctionDescriptor wl_client_get_display$descriptor() {
        return wl_client_get_display.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_display *wl_client_get_display(struct wl_client *client)
     * }
     */
    public static MethodHandle wl_client_get_display$handle() {
        return wl_client_get_display.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_display *wl_client_get_display(struct wl_client *client)
     * }
     */
    public static MemorySegment wl_client_get_display$address() {
        return wl_client_get_display.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_display *wl_client_get_display(struct wl_client *client)
     * }
     */
    public static MemorySegment wl_client_get_display(MemorySegment client) {
        var mh$ = wl_client_get_display.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_client_get_display", client);
            }
            return (MemorySegment)mh$.invokeExact(client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_resource_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_resource_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_resource *wl_resource_create(struct wl_client *client, const struct wl_interface *interface, int version, uint32_t id)
     * }
     */
    public static FunctionDescriptor wl_resource_create$descriptor() {
        return wl_resource_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_resource *wl_resource_create(struct wl_client *client, const struct wl_interface *interface, int version, uint32_t id)
     * }
     */
    public static MethodHandle wl_resource_create$handle() {
        return wl_resource_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_resource *wl_resource_create(struct wl_client *client, const struct wl_interface *interface, int version, uint32_t id)
     * }
     */
    public static MemorySegment wl_resource_create$address() {
        return wl_resource_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_resource *wl_resource_create(struct wl_client *client, const struct wl_interface *interface, int version, uint32_t id)
     * }
     */
    public static MemorySegment wl_resource_create(MemorySegment client, MemorySegment interface_, int version, int id) {
        var mh$ = wl_resource_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_resource_create", client, interface_, version, id);
            }
            return (MemorySegment)mh$.invokeExact(client, interface_, version, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_resource_set_implementation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_resource_set_implementation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_resource_set_implementation(struct wl_resource *resource, const void *implementation, void *data, wl_resource_destroy_func_t destroy)
     * }
     */
    public static FunctionDescriptor wl_resource_set_implementation$descriptor() {
        return wl_resource_set_implementation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_resource_set_implementation(struct wl_resource *resource, const void *implementation, void *data, wl_resource_destroy_func_t destroy)
     * }
     */
    public static MethodHandle wl_resource_set_implementation$handle() {
        return wl_resource_set_implementation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_resource_set_implementation(struct wl_resource *resource, const void *implementation, void *data, wl_resource_destroy_func_t destroy)
     * }
     */
    public static MemorySegment wl_resource_set_implementation$address() {
        return wl_resource_set_implementation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_resource_set_implementation(struct wl_resource *resource, const void *implementation, void *data, wl_resource_destroy_func_t destroy)
     * }
     */
    public static void wl_resource_set_implementation(MemorySegment resource, MemorySegment implementation, MemorySegment data, MemorySegment destroy) {
        var mh$ = wl_resource_set_implementation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_resource_set_implementation", resource, implementation, data, destroy);
            }
            mh$.invokeExact(resource, implementation, data, destroy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_resource_set_dispatcher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_resource_set_dispatcher");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_resource_set_dispatcher(struct wl_resource *resource, wl_dispatcher_func_t dispatcher, const void *implementation, void *data, wl_resource_destroy_func_t destroy)
     * }
     */
    public static FunctionDescriptor wl_resource_set_dispatcher$descriptor() {
        return wl_resource_set_dispatcher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_resource_set_dispatcher(struct wl_resource *resource, wl_dispatcher_func_t dispatcher, const void *implementation, void *data, wl_resource_destroy_func_t destroy)
     * }
     */
    public static MethodHandle wl_resource_set_dispatcher$handle() {
        return wl_resource_set_dispatcher.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_resource_set_dispatcher(struct wl_resource *resource, wl_dispatcher_func_t dispatcher, const void *implementation, void *data, wl_resource_destroy_func_t destroy)
     * }
     */
    public static MemorySegment wl_resource_set_dispatcher$address() {
        return wl_resource_set_dispatcher.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_resource_set_dispatcher(struct wl_resource *resource, wl_dispatcher_func_t dispatcher, const void *implementation, void *data, wl_resource_destroy_func_t destroy)
     * }
     */
    public static void wl_resource_set_dispatcher(MemorySegment resource, MemorySegment dispatcher, MemorySegment implementation, MemorySegment data, MemorySegment destroy) {
        var mh$ = wl_resource_set_dispatcher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_resource_set_dispatcher", resource, dispatcher, implementation, data, destroy);
            }
            mh$.invokeExact(resource, dispatcher, implementation, data, destroy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_resource_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_resource_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_resource_destroy(struct wl_resource *resource)
     * }
     */
    public static FunctionDescriptor wl_resource_destroy$descriptor() {
        return wl_resource_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_resource_destroy(struct wl_resource *resource)
     * }
     */
    public static MethodHandle wl_resource_destroy$handle() {
        return wl_resource_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_resource_destroy(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wl_resource_destroy$address() {
        return wl_resource_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_resource_destroy(struct wl_resource *resource)
     * }
     */
    public static void wl_resource_destroy(MemorySegment resource) {
        var mh$ = wl_resource_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_resource_destroy", resource);
            }
            mh$.invokeExact(resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_resource_get_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_resource_get_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t wl_resource_get_id(struct wl_resource *resource)
     * }
     */
    public static FunctionDescriptor wl_resource_get_id$descriptor() {
        return wl_resource_get_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t wl_resource_get_id(struct wl_resource *resource)
     * }
     */
    public static MethodHandle wl_resource_get_id$handle() {
        return wl_resource_get_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t wl_resource_get_id(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wl_resource_get_id$address() {
        return wl_resource_get_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t wl_resource_get_id(struct wl_resource *resource)
     * }
     */
    public static int wl_resource_get_id(MemorySegment resource) {
        var mh$ = wl_resource_get_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_resource_get_id", resource);
            }
            return (int)mh$.invokeExact(resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_resource_get_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_resource_get_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_list *wl_resource_get_link(struct wl_resource *resource)
     * }
     */
    public static FunctionDescriptor wl_resource_get_link$descriptor() {
        return wl_resource_get_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_list *wl_resource_get_link(struct wl_resource *resource)
     * }
     */
    public static MethodHandle wl_resource_get_link$handle() {
        return wl_resource_get_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_list *wl_resource_get_link(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wl_resource_get_link$address() {
        return wl_resource_get_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_list *wl_resource_get_link(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wl_resource_get_link(MemorySegment resource) {
        var mh$ = wl_resource_get_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_resource_get_link", resource);
            }
            return (MemorySegment)mh$.invokeExact(resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_resource_from_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_resource_from_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_resource *wl_resource_from_link(struct wl_list *resource)
     * }
     */
    public static FunctionDescriptor wl_resource_from_link$descriptor() {
        return wl_resource_from_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_resource *wl_resource_from_link(struct wl_list *resource)
     * }
     */
    public static MethodHandle wl_resource_from_link$handle() {
        return wl_resource_from_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_resource *wl_resource_from_link(struct wl_list *resource)
     * }
     */
    public static MemorySegment wl_resource_from_link$address() {
        return wl_resource_from_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_resource *wl_resource_from_link(struct wl_list *resource)
     * }
     */
    public static MemorySegment wl_resource_from_link(MemorySegment resource) {
        var mh$ = wl_resource_from_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_resource_from_link", resource);
            }
            return (MemorySegment)mh$.invokeExact(resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_resource_find_for_client {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_resource_find_for_client");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_resource *wl_resource_find_for_client(struct wl_list *list, struct wl_client *client)
     * }
     */
    public static FunctionDescriptor wl_resource_find_for_client$descriptor() {
        return wl_resource_find_for_client.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_resource *wl_resource_find_for_client(struct wl_list *list, struct wl_client *client)
     * }
     */
    public static MethodHandle wl_resource_find_for_client$handle() {
        return wl_resource_find_for_client.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_resource *wl_resource_find_for_client(struct wl_list *list, struct wl_client *client)
     * }
     */
    public static MemorySegment wl_resource_find_for_client$address() {
        return wl_resource_find_for_client.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_resource *wl_resource_find_for_client(struct wl_list *list, struct wl_client *client)
     * }
     */
    public static MemorySegment wl_resource_find_for_client(MemorySegment list, MemorySegment client) {
        var mh$ = wl_resource_find_for_client.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_resource_find_for_client", list, client);
            }
            return (MemorySegment)mh$.invokeExact(list, client);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_resource_get_client {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_resource_get_client");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_client *wl_resource_get_client(struct wl_resource *resource)
     * }
     */
    public static FunctionDescriptor wl_resource_get_client$descriptor() {
        return wl_resource_get_client.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_client *wl_resource_get_client(struct wl_resource *resource)
     * }
     */
    public static MethodHandle wl_resource_get_client$handle() {
        return wl_resource_get_client.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_client *wl_resource_get_client(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wl_resource_get_client$address() {
        return wl_resource_get_client.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_client *wl_resource_get_client(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wl_resource_get_client(MemorySegment resource) {
        var mh$ = wl_resource_get_client.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_resource_get_client", resource);
            }
            return (MemorySegment)mh$.invokeExact(resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_resource_set_user_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_resource_set_user_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_resource_set_user_data(struct wl_resource *resource, void *data)
     * }
     */
    public static FunctionDescriptor wl_resource_set_user_data$descriptor() {
        return wl_resource_set_user_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_resource_set_user_data(struct wl_resource *resource, void *data)
     * }
     */
    public static MethodHandle wl_resource_set_user_data$handle() {
        return wl_resource_set_user_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_resource_set_user_data(struct wl_resource *resource, void *data)
     * }
     */
    public static MemorySegment wl_resource_set_user_data$address() {
        return wl_resource_set_user_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_resource_set_user_data(struct wl_resource *resource, void *data)
     * }
     */
    public static void wl_resource_set_user_data(MemorySegment resource, MemorySegment data) {
        var mh$ = wl_resource_set_user_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_resource_set_user_data", resource, data);
            }
            mh$.invokeExact(resource, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_resource_get_user_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_resource_get_user_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *wl_resource_get_user_data(struct wl_resource *resource)
     * }
     */
    public static FunctionDescriptor wl_resource_get_user_data$descriptor() {
        return wl_resource_get_user_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *wl_resource_get_user_data(struct wl_resource *resource)
     * }
     */
    public static MethodHandle wl_resource_get_user_data$handle() {
        return wl_resource_get_user_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *wl_resource_get_user_data(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wl_resource_get_user_data$address() {
        return wl_resource_get_user_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *wl_resource_get_user_data(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wl_resource_get_user_data(MemorySegment resource) {
        var mh$ = wl_resource_get_user_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_resource_get_user_data", resource);
            }
            return (MemorySegment)mh$.invokeExact(resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_resource_get_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_resource_get_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wl_resource_get_version(struct wl_resource *resource)
     * }
     */
    public static FunctionDescriptor wl_resource_get_version$descriptor() {
        return wl_resource_get_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wl_resource_get_version(struct wl_resource *resource)
     * }
     */
    public static MethodHandle wl_resource_get_version$handle() {
        return wl_resource_get_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wl_resource_get_version(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wl_resource_get_version$address() {
        return wl_resource_get_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wl_resource_get_version(struct wl_resource *resource)
     * }
     */
    public static int wl_resource_get_version(MemorySegment resource) {
        var mh$ = wl_resource_get_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_resource_get_version", resource);
            }
            return (int)mh$.invokeExact(resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_resource_set_destructor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_resource_set_destructor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_resource_set_destructor(struct wl_resource *resource, wl_resource_destroy_func_t destroy)
     * }
     */
    public static FunctionDescriptor wl_resource_set_destructor$descriptor() {
        return wl_resource_set_destructor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_resource_set_destructor(struct wl_resource *resource, wl_resource_destroy_func_t destroy)
     * }
     */
    public static MethodHandle wl_resource_set_destructor$handle() {
        return wl_resource_set_destructor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_resource_set_destructor(struct wl_resource *resource, wl_resource_destroy_func_t destroy)
     * }
     */
    public static MemorySegment wl_resource_set_destructor$address() {
        return wl_resource_set_destructor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_resource_set_destructor(struct wl_resource *resource, wl_resource_destroy_func_t destroy)
     * }
     */
    public static void wl_resource_set_destructor(MemorySegment resource, MemorySegment destroy) {
        var mh$ = wl_resource_set_destructor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_resource_set_destructor", resource, destroy);
            }
            mh$.invokeExact(resource, destroy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_resource_instance_of {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_resource_instance_of");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wl_resource_instance_of(struct wl_resource *resource, const struct wl_interface *interface, const void *implementation)
     * }
     */
    public static FunctionDescriptor wl_resource_instance_of$descriptor() {
        return wl_resource_instance_of.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wl_resource_instance_of(struct wl_resource *resource, const struct wl_interface *interface, const void *implementation)
     * }
     */
    public static MethodHandle wl_resource_instance_of$handle() {
        return wl_resource_instance_of.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wl_resource_instance_of(struct wl_resource *resource, const struct wl_interface *interface, const void *implementation)
     * }
     */
    public static MemorySegment wl_resource_instance_of$address() {
        return wl_resource_instance_of.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wl_resource_instance_of(struct wl_resource *resource, const struct wl_interface *interface, const void *implementation)
     * }
     */
    public static int wl_resource_instance_of(MemorySegment resource, MemorySegment interface_, MemorySegment implementation) {
        var mh$ = wl_resource_instance_of.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_resource_instance_of", resource, interface_, implementation);
            }
            return (int)mh$.invokeExact(resource, interface_, implementation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_resource_get_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_resource_get_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *wl_resource_get_class(struct wl_resource *resource)
     * }
     */
    public static FunctionDescriptor wl_resource_get_class$descriptor() {
        return wl_resource_get_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *wl_resource_get_class(struct wl_resource *resource)
     * }
     */
    public static MethodHandle wl_resource_get_class$handle() {
        return wl_resource_get_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *wl_resource_get_class(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wl_resource_get_class$address() {
        return wl_resource_get_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *wl_resource_get_class(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wl_resource_get_class(MemorySegment resource) {
        var mh$ = wl_resource_get_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_resource_get_class", resource);
            }
            return (MemorySegment)mh$.invokeExact(resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_resource_add_destroy_listener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_resource_add_destroy_listener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_resource_add_destroy_listener(struct wl_resource *resource, struct wl_listener *listener)
     * }
     */
    public static FunctionDescriptor wl_resource_add_destroy_listener$descriptor() {
        return wl_resource_add_destroy_listener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_resource_add_destroy_listener(struct wl_resource *resource, struct wl_listener *listener)
     * }
     */
    public static MethodHandle wl_resource_add_destroy_listener$handle() {
        return wl_resource_add_destroy_listener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_resource_add_destroy_listener(struct wl_resource *resource, struct wl_listener *listener)
     * }
     */
    public static MemorySegment wl_resource_add_destroy_listener$address() {
        return wl_resource_add_destroy_listener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_resource_add_destroy_listener(struct wl_resource *resource, struct wl_listener *listener)
     * }
     */
    public static void wl_resource_add_destroy_listener(MemorySegment resource, MemorySegment listener) {
        var mh$ = wl_resource_add_destroy_listener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_resource_add_destroy_listener", resource, listener);
            }
            mh$.invokeExact(resource, listener);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_resource_get_destroy_listener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_resource_get_destroy_listener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_listener *wl_resource_get_destroy_listener(struct wl_resource *resource, wl_notify_func_t notify)
     * }
     */
    public static FunctionDescriptor wl_resource_get_destroy_listener$descriptor() {
        return wl_resource_get_destroy_listener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_listener *wl_resource_get_destroy_listener(struct wl_resource *resource, wl_notify_func_t notify)
     * }
     */
    public static MethodHandle wl_resource_get_destroy_listener$handle() {
        return wl_resource_get_destroy_listener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_listener *wl_resource_get_destroy_listener(struct wl_resource *resource, wl_notify_func_t notify)
     * }
     */
    public static MemorySegment wl_resource_get_destroy_listener$address() {
        return wl_resource_get_destroy_listener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_listener *wl_resource_get_destroy_listener(struct wl_resource *resource, wl_notify_func_t notify)
     * }
     */
    public static MemorySegment wl_resource_get_destroy_listener(MemorySegment resource, MemorySegment notify) {
        var mh$ = wl_resource_get_destroy_listener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_resource_get_destroy_listener", resource, notify);
            }
            return (MemorySegment)mh$.invokeExact(resource, notify);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_shm_buffer_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_shm_buffer_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_shm_buffer *wl_shm_buffer_get(struct wl_resource *resource)
     * }
     */
    public static FunctionDescriptor wl_shm_buffer_get$descriptor() {
        return wl_shm_buffer_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_shm_buffer *wl_shm_buffer_get(struct wl_resource *resource)
     * }
     */
    public static MethodHandle wl_shm_buffer_get$handle() {
        return wl_shm_buffer_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_shm_buffer *wl_shm_buffer_get(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wl_shm_buffer_get$address() {
        return wl_shm_buffer_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_shm_buffer *wl_shm_buffer_get(struct wl_resource *resource)
     * }
     */
    public static MemorySegment wl_shm_buffer_get(MemorySegment resource) {
        var mh$ = wl_shm_buffer_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_shm_buffer_get", resource);
            }
            return (MemorySegment)mh$.invokeExact(resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_shm_buffer_begin_access {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_shm_buffer_begin_access");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_shm_buffer_begin_access(struct wl_shm_buffer *buffer)
     * }
     */
    public static FunctionDescriptor wl_shm_buffer_begin_access$descriptor() {
        return wl_shm_buffer_begin_access.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_shm_buffer_begin_access(struct wl_shm_buffer *buffer)
     * }
     */
    public static MethodHandle wl_shm_buffer_begin_access$handle() {
        return wl_shm_buffer_begin_access.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_shm_buffer_begin_access(struct wl_shm_buffer *buffer)
     * }
     */
    public static MemorySegment wl_shm_buffer_begin_access$address() {
        return wl_shm_buffer_begin_access.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_shm_buffer_begin_access(struct wl_shm_buffer *buffer)
     * }
     */
    public static void wl_shm_buffer_begin_access(MemorySegment buffer) {
        var mh$ = wl_shm_buffer_begin_access.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_shm_buffer_begin_access", buffer);
            }
            mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_shm_buffer_end_access {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_shm_buffer_end_access");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_shm_buffer_end_access(struct wl_shm_buffer *buffer)
     * }
     */
    public static FunctionDescriptor wl_shm_buffer_end_access$descriptor() {
        return wl_shm_buffer_end_access.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_shm_buffer_end_access(struct wl_shm_buffer *buffer)
     * }
     */
    public static MethodHandle wl_shm_buffer_end_access$handle() {
        return wl_shm_buffer_end_access.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_shm_buffer_end_access(struct wl_shm_buffer *buffer)
     * }
     */
    public static MemorySegment wl_shm_buffer_end_access$address() {
        return wl_shm_buffer_end_access.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_shm_buffer_end_access(struct wl_shm_buffer *buffer)
     * }
     */
    public static void wl_shm_buffer_end_access(MemorySegment buffer) {
        var mh$ = wl_shm_buffer_end_access.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_shm_buffer_end_access", buffer);
            }
            mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_shm_buffer_get_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_shm_buffer_get_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *wl_shm_buffer_get_data(struct wl_shm_buffer *buffer)
     * }
     */
    public static FunctionDescriptor wl_shm_buffer_get_data$descriptor() {
        return wl_shm_buffer_get_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *wl_shm_buffer_get_data(struct wl_shm_buffer *buffer)
     * }
     */
    public static MethodHandle wl_shm_buffer_get_data$handle() {
        return wl_shm_buffer_get_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *wl_shm_buffer_get_data(struct wl_shm_buffer *buffer)
     * }
     */
    public static MemorySegment wl_shm_buffer_get_data$address() {
        return wl_shm_buffer_get_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *wl_shm_buffer_get_data(struct wl_shm_buffer *buffer)
     * }
     */
    public static MemorySegment wl_shm_buffer_get_data(MemorySegment buffer) {
        var mh$ = wl_shm_buffer_get_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_shm_buffer_get_data", buffer);
            }
            return (MemorySegment)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_shm_buffer_get_stride {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_shm_buffer_get_stride");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t wl_shm_buffer_get_stride(struct wl_shm_buffer *buffer)
     * }
     */
    public static FunctionDescriptor wl_shm_buffer_get_stride$descriptor() {
        return wl_shm_buffer_get_stride.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t wl_shm_buffer_get_stride(struct wl_shm_buffer *buffer)
     * }
     */
    public static MethodHandle wl_shm_buffer_get_stride$handle() {
        return wl_shm_buffer_get_stride.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t wl_shm_buffer_get_stride(struct wl_shm_buffer *buffer)
     * }
     */
    public static MemorySegment wl_shm_buffer_get_stride$address() {
        return wl_shm_buffer_get_stride.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t wl_shm_buffer_get_stride(struct wl_shm_buffer *buffer)
     * }
     */
    public static int wl_shm_buffer_get_stride(MemorySegment buffer) {
        var mh$ = wl_shm_buffer_get_stride.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_shm_buffer_get_stride", buffer);
            }
            return (int)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_shm_buffer_get_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_shm_buffer_get_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t wl_shm_buffer_get_format(struct wl_shm_buffer *buffer)
     * }
     */
    public static FunctionDescriptor wl_shm_buffer_get_format$descriptor() {
        return wl_shm_buffer_get_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t wl_shm_buffer_get_format(struct wl_shm_buffer *buffer)
     * }
     */
    public static MethodHandle wl_shm_buffer_get_format$handle() {
        return wl_shm_buffer_get_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t wl_shm_buffer_get_format(struct wl_shm_buffer *buffer)
     * }
     */
    public static MemorySegment wl_shm_buffer_get_format$address() {
        return wl_shm_buffer_get_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t wl_shm_buffer_get_format(struct wl_shm_buffer *buffer)
     * }
     */
    public static int wl_shm_buffer_get_format(MemorySegment buffer) {
        var mh$ = wl_shm_buffer_get_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_shm_buffer_get_format", buffer);
            }
            return (int)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_shm_buffer_get_width {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_shm_buffer_get_width");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t wl_shm_buffer_get_width(struct wl_shm_buffer *buffer)
     * }
     */
    public static FunctionDescriptor wl_shm_buffer_get_width$descriptor() {
        return wl_shm_buffer_get_width.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t wl_shm_buffer_get_width(struct wl_shm_buffer *buffer)
     * }
     */
    public static MethodHandle wl_shm_buffer_get_width$handle() {
        return wl_shm_buffer_get_width.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t wl_shm_buffer_get_width(struct wl_shm_buffer *buffer)
     * }
     */
    public static MemorySegment wl_shm_buffer_get_width$address() {
        return wl_shm_buffer_get_width.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t wl_shm_buffer_get_width(struct wl_shm_buffer *buffer)
     * }
     */
    public static int wl_shm_buffer_get_width(MemorySegment buffer) {
        var mh$ = wl_shm_buffer_get_width.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_shm_buffer_get_width", buffer);
            }
            return (int)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_shm_buffer_get_height {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_shm_buffer_get_height");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t wl_shm_buffer_get_height(struct wl_shm_buffer *buffer)
     * }
     */
    public static FunctionDescriptor wl_shm_buffer_get_height$descriptor() {
        return wl_shm_buffer_get_height.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t wl_shm_buffer_get_height(struct wl_shm_buffer *buffer)
     * }
     */
    public static MethodHandle wl_shm_buffer_get_height$handle() {
        return wl_shm_buffer_get_height.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t wl_shm_buffer_get_height(struct wl_shm_buffer *buffer)
     * }
     */
    public static MemorySegment wl_shm_buffer_get_height$address() {
        return wl_shm_buffer_get_height.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t wl_shm_buffer_get_height(struct wl_shm_buffer *buffer)
     * }
     */
    public static int wl_shm_buffer_get_height(MemorySegment buffer) {
        var mh$ = wl_shm_buffer_get_height.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_shm_buffer_get_height", buffer);
            }
            return (int)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_shm_buffer_ref_pool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_shm_buffer_ref_pool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_shm_pool *wl_shm_buffer_ref_pool(struct wl_shm_buffer *buffer)
     * }
     */
    public static FunctionDescriptor wl_shm_buffer_ref_pool$descriptor() {
        return wl_shm_buffer_ref_pool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_shm_pool *wl_shm_buffer_ref_pool(struct wl_shm_buffer *buffer)
     * }
     */
    public static MethodHandle wl_shm_buffer_ref_pool$handle() {
        return wl_shm_buffer_ref_pool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_shm_pool *wl_shm_buffer_ref_pool(struct wl_shm_buffer *buffer)
     * }
     */
    public static MemorySegment wl_shm_buffer_ref_pool$address() {
        return wl_shm_buffer_ref_pool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_shm_pool *wl_shm_buffer_ref_pool(struct wl_shm_buffer *buffer)
     * }
     */
    public static MemorySegment wl_shm_buffer_ref_pool(MemorySegment buffer) {
        var mh$ = wl_shm_buffer_ref_pool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_shm_buffer_ref_pool", buffer);
            }
            return (MemorySegment)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_shm_pool_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_shm_pool_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_shm_pool_unref(struct wl_shm_pool *pool)
     * }
     */
    public static FunctionDescriptor wl_shm_pool_unref$descriptor() {
        return wl_shm_pool_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_shm_pool_unref(struct wl_shm_pool *pool)
     * }
     */
    public static MethodHandle wl_shm_pool_unref$handle() {
        return wl_shm_pool_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_shm_pool_unref(struct wl_shm_pool *pool)
     * }
     */
    public static MemorySegment wl_shm_pool_unref$address() {
        return wl_shm_pool_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_shm_pool_unref(struct wl_shm_pool *pool)
     * }
     */
    public static void wl_shm_pool_unref(MemorySegment pool) {
        var mh$ = wl_shm_pool_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_shm_pool_unref", pool);
            }
            mh$.invokeExact(pool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_init_shm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_init_shm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wl_display_init_shm(struct wl_display *display)
     * }
     */
    public static FunctionDescriptor wl_display_init_shm$descriptor() {
        return wl_display_init_shm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wl_display_init_shm(struct wl_display *display)
     * }
     */
    public static MethodHandle wl_display_init_shm$handle() {
        return wl_display_init_shm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wl_display_init_shm(struct wl_display *display)
     * }
     */
    public static MemorySegment wl_display_init_shm$address() {
        return wl_display_init_shm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wl_display_init_shm(struct wl_display *display)
     * }
     */
    public static int wl_display_init_shm(MemorySegment display) {
        var mh$ = wl_display_init_shm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_init_shm", display);
            }
            return (int)mh$.invokeExact(display);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_add_shm_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_add_shm_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t *wl_display_add_shm_format(struct wl_display *display, uint32_t format)
     * }
     */
    public static FunctionDescriptor wl_display_add_shm_format$descriptor() {
        return wl_display_add_shm_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t *wl_display_add_shm_format(struct wl_display *display, uint32_t format)
     * }
     */
    public static MethodHandle wl_display_add_shm_format$handle() {
        return wl_display_add_shm_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t *wl_display_add_shm_format(struct wl_display *display, uint32_t format)
     * }
     */
    public static MemorySegment wl_display_add_shm_format$address() {
        return wl_display_add_shm_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t *wl_display_add_shm_format(struct wl_display *display, uint32_t format)
     * }
     */
    public static MemorySegment wl_display_add_shm_format(MemorySegment display, int format) {
        var mh$ = wl_display_add_shm_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_add_shm_format", display, format);
            }
            return (MemorySegment)mh$.invokeExact(display, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_shm_buffer_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT,
            C.C_INT
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_shm_buffer_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_shm_buffer *wl_shm_buffer_create(struct wl_client *client, uint32_t id, int32_t width, int32_t height, int32_t stride, uint32_t format)
     * }
     */
    public static FunctionDescriptor wl_shm_buffer_create$descriptor() {
        return wl_shm_buffer_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_shm_buffer *wl_shm_buffer_create(struct wl_client *client, uint32_t id, int32_t width, int32_t height, int32_t stride, uint32_t format)
     * }
     */
    public static MethodHandle wl_shm_buffer_create$handle() {
        return wl_shm_buffer_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_shm_buffer *wl_shm_buffer_create(struct wl_client *client, uint32_t id, int32_t width, int32_t height, int32_t stride, uint32_t format)
     * }
     */
    public static MemorySegment wl_shm_buffer_create$address() {
        return wl_shm_buffer_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_shm_buffer *wl_shm_buffer_create(struct wl_client *client, uint32_t id, int32_t width, int32_t height, int32_t stride, uint32_t format)
     * }
     */
    public static MemorySegment wl_shm_buffer_create(MemorySegment client, int id, int width, int height, int stride, int format) {
        var mh$ = wl_shm_buffer_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_shm_buffer_create", client, id, width, height, stride, format);
            }
            return (MemorySegment)mh$.invokeExact(client, id, width, height, stride, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_log_set_handler_server {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_log_set_handler_server");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_log_set_handler_server(wl_log_func_t handler)
     * }
     */
    public static FunctionDescriptor wl_log_set_handler_server$descriptor() {
        return wl_log_set_handler_server.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_log_set_handler_server(wl_log_func_t handler)
     * }
     */
    public static MethodHandle wl_log_set_handler_server$handle() {
        return wl_log_set_handler_server.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_log_set_handler_server(wl_log_func_t handler)
     * }
     */
    public static MemorySegment wl_log_set_handler_server$address() {
        return wl_log_set_handler_server.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_log_set_handler_server(wl_log_func_t handler)
     * }
     */
    public static void wl_log_set_handler_server(MemorySegment handler) {
        var mh$ = wl_log_set_handler_server.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_log_set_handler_server", handler);
            }
            mh$.invokeExact(handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int WL_PROTOCOL_LOGGER_REQUEST = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_protocol_logger_type.WL_PROTOCOL_LOGGER_REQUEST = 0
     * }
     */
    public static int WL_PROTOCOL_LOGGER_REQUEST() {
        return WL_PROTOCOL_LOGGER_REQUEST;
    }
    private static final int WL_PROTOCOL_LOGGER_EVENT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_protocol_logger_type.WL_PROTOCOL_LOGGER_EVENT = 1
     * }
     */
    public static int WL_PROTOCOL_LOGGER_EVENT() {
        return WL_PROTOCOL_LOGGER_EVENT;
    }

    private static class wl_display_add_protocol_logger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_add_protocol_logger");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_protocol_logger *wl_display_add_protocol_logger(struct wl_display *display, wl_protocol_logger_func_t, void *user_data)
     * }
     */
    public static FunctionDescriptor wl_display_add_protocol_logger$descriptor() {
        return wl_display_add_protocol_logger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_protocol_logger *wl_display_add_protocol_logger(struct wl_display *display, wl_protocol_logger_func_t, void *user_data)
     * }
     */
    public static MethodHandle wl_display_add_protocol_logger$handle() {
        return wl_display_add_protocol_logger.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_protocol_logger *wl_display_add_protocol_logger(struct wl_display *display, wl_protocol_logger_func_t, void *user_data)
     * }
     */
    public static MemorySegment wl_display_add_protocol_logger$address() {
        return wl_display_add_protocol_logger.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_protocol_logger *wl_display_add_protocol_logger(struct wl_display *display, wl_protocol_logger_func_t, void *user_data)
     * }
     */
    public static MemorySegment wl_display_add_protocol_logger(MemorySegment display, MemorySegment x1, MemorySegment user_data) {
        var mh$ = wl_display_add_protocol_logger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_add_protocol_logger", display, x1, user_data);
            }
            return (MemorySegment)mh$.invokeExact(display, x1, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_protocol_logger_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_protocol_logger_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_protocol_logger_destroy(struct wl_protocol_logger *logger)
     * }
     */
    public static FunctionDescriptor wl_protocol_logger_destroy$descriptor() {
        return wl_protocol_logger_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_protocol_logger_destroy(struct wl_protocol_logger *logger)
     * }
     */
    public static MethodHandle wl_protocol_logger_destroy$handle() {
        return wl_protocol_logger_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_protocol_logger_destroy(struct wl_protocol_logger *logger)
     * }
     */
    public static MemorySegment wl_protocol_logger_destroy$address() {
        return wl_protocol_logger_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_protocol_logger_destroy(struct wl_protocol_logger *logger)
     * }
     */
    public static void wl_protocol_logger_destroy(MemorySegment logger) {
        var mh$ = wl_protocol_logger_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_protocol_logger_destroy", logger);
            }
            mh$.invokeExact(logger);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_client_add_resource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_INT,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_client_add_resource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t wl_client_add_resource(struct wl_client *client, struct wl_resource *resource)
     * }
     */
    public static FunctionDescriptor wl_client_add_resource$descriptor() {
        return wl_client_add_resource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t wl_client_add_resource(struct wl_client *client, struct wl_resource *resource)
     * }
     */
    public static MethodHandle wl_client_add_resource$handle() {
        return wl_client_add_resource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t wl_client_add_resource(struct wl_client *client, struct wl_resource *resource)
     * }
     */
    public static MemorySegment wl_client_add_resource$address() {
        return wl_client_add_resource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t wl_client_add_resource(struct wl_client *client, struct wl_resource *resource)
     * }
     */
    public static int wl_client_add_resource(MemorySegment client, MemorySegment resource) {
        var mh$ = wl_client_add_resource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_client_add_resource", client, resource);
            }
            return (int)mh$.invokeExact(client, resource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_client_add_object {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_INT,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_client_add_object");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_resource *wl_client_add_object(struct wl_client *client, const struct wl_interface *interface, const void *implementation, uint32_t id, void *data)
     * }
     */
    public static FunctionDescriptor wl_client_add_object$descriptor() {
        return wl_client_add_object.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_resource *wl_client_add_object(struct wl_client *client, const struct wl_interface *interface, const void *implementation, uint32_t id, void *data)
     * }
     */
    public static MethodHandle wl_client_add_object$handle() {
        return wl_client_add_object.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_resource *wl_client_add_object(struct wl_client *client, const struct wl_interface *interface, const void *implementation, uint32_t id, void *data)
     * }
     */
    public static MemorySegment wl_client_add_object$address() {
        return wl_client_add_object.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_resource *wl_client_add_object(struct wl_client *client, const struct wl_interface *interface, const void *implementation, uint32_t id, void *data)
     * }
     */
    public static MemorySegment wl_client_add_object(MemorySegment client, MemorySegment interface_, MemorySegment implementation, int id, MemorySegment data) {
        var mh$ = wl_client_add_object.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_client_add_object", client, interface_, implementation, id, data);
            }
            return (MemorySegment)mh$.invokeExact(client, interface_, implementation, id, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_client_new_object {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_client_new_object");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_resource *wl_client_new_object(struct wl_client *client, const struct wl_interface *interface, const void *implementation, void *data)
     * }
     */
    public static FunctionDescriptor wl_client_new_object$descriptor() {
        return wl_client_new_object.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_resource *wl_client_new_object(struct wl_client *client, const struct wl_interface *interface, const void *implementation, void *data)
     * }
     */
    public static MethodHandle wl_client_new_object$handle() {
        return wl_client_new_object.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_resource *wl_client_new_object(struct wl_client *client, const struct wl_interface *interface, const void *implementation, void *data)
     * }
     */
    public static MemorySegment wl_client_new_object$address() {
        return wl_client_new_object.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_resource *wl_client_new_object(struct wl_client *client, const struct wl_interface *interface, const void *implementation, void *data)
     * }
     */
    public static MemorySegment wl_client_new_object(MemorySegment client, MemorySegment interface_, MemorySegment implementation, MemorySegment data) {
        var mh$ = wl_client_new_object.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_client_new_object", client, interface_, implementation, data);
            }
            return (MemorySegment)mh$.invokeExact(client, interface_, implementation, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_add_global {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_add_global");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct wl_global *wl_display_add_global(struct wl_display *display, const struct wl_interface *interface, void *data, wl_global_bind_func_t bind)
     * }
     */
    public static FunctionDescriptor wl_display_add_global$descriptor() {
        return wl_display_add_global.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct wl_global *wl_display_add_global(struct wl_display *display, const struct wl_interface *interface, void *data, wl_global_bind_func_t bind)
     * }
     */
    public static MethodHandle wl_display_add_global$handle() {
        return wl_display_add_global.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct wl_global *wl_display_add_global(struct wl_display *display, const struct wl_interface *interface, void *data, wl_global_bind_func_t bind)
     * }
     */
    public static MemorySegment wl_display_add_global$address() {
        return wl_display_add_global.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct wl_global *wl_display_add_global(struct wl_display *display, const struct wl_interface *interface, void *data, wl_global_bind_func_t bind)
     * }
     */
    public static MemorySegment wl_display_add_global(MemorySegment display, MemorySegment interface_, MemorySegment data, MemorySegment bind) {
        var mh$ = wl_display_add_global.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_add_global", display, interface_, data, bind);
            }
            return (MemorySegment)mh$.invokeExact(display, interface_, data, bind);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_remove_global {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C.C_POINTER,
            C.C_POINTER
        );

        public static final MemorySegment ADDR = C.findOrThrow("wl_display_remove_global");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void wl_display_remove_global(struct wl_display *display, struct wl_global *global)
     * }
     */
    public static FunctionDescriptor wl_display_remove_global$descriptor() {
        return wl_display_remove_global.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void wl_display_remove_global(struct wl_display *display, struct wl_global *global)
     * }
     */
    public static MethodHandle wl_display_remove_global$handle() {
        return wl_display_remove_global.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void wl_display_remove_global(struct wl_display *display, struct wl_global *global)
     * }
     */
    public static MemorySegment wl_display_remove_global$address() {
        return wl_display_remove_global.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void wl_display_remove_global(struct wl_display *display, struct wl_global *global)
     * }
     */
    public static void wl_display_remove_global(MemorySegment display, MemorySegment global) {
        var mh$ = wl_display_remove_global.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wl_display_remove_global", display, global);
            }
            mh$.invokeExact(display, global);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wl_display_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_display_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_display_interface
     * }
     */
    public static GroupLayout wl_display_interface$layout() {
        return wl_display_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_display_interface
     * }
     */
    public static MemorySegment wl_display_interface() {
        return wl_display_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_display_interface
     * }
     */
    public static void wl_display_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_display_interface$constants.SEGMENT, 0L, wl_display_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_registry_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_registry_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_registry_interface
     * }
     */
    public static GroupLayout wl_registry_interface$layout() {
        return wl_registry_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_registry_interface
     * }
     */
    public static MemorySegment wl_registry_interface() {
        return wl_registry_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_registry_interface
     * }
     */
    public static void wl_registry_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_registry_interface$constants.SEGMENT, 0L, wl_registry_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_callback_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_callback_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_callback_interface
     * }
     */
    public static GroupLayout wl_callback_interface$layout() {
        return wl_callback_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_callback_interface
     * }
     */
    public static MemorySegment wl_callback_interface() {
        return wl_callback_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_callback_interface
     * }
     */
    public static void wl_callback_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_callback_interface$constants.SEGMENT, 0L, wl_callback_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_compositor_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_compositor_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_compositor_interface
     * }
     */
    public static GroupLayout wl_compositor_interface$layout() {
        return wl_compositor_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_compositor_interface
     * }
     */
    public static MemorySegment wl_compositor_interface() {
        return wl_compositor_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_compositor_interface
     * }
     */
    public static void wl_compositor_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_compositor_interface$constants.SEGMENT, 0L, wl_compositor_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_shm_pool_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_shm_pool_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_shm_pool_interface
     * }
     */
    public static GroupLayout wl_shm_pool_interface$layout() {
        return wl_shm_pool_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_shm_pool_interface
     * }
     */
    public static MemorySegment wl_shm_pool_interface() {
        return wl_shm_pool_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_shm_pool_interface
     * }
     */
    public static void wl_shm_pool_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_shm_pool_interface$constants.SEGMENT, 0L, wl_shm_pool_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_shm_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_shm_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_shm_interface
     * }
     */
    public static GroupLayout wl_shm_interface$layout() {
        return wl_shm_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_shm_interface
     * }
     */
    public static MemorySegment wl_shm_interface() {
        return wl_shm_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_shm_interface
     * }
     */
    public static void wl_shm_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_shm_interface$constants.SEGMENT, 0L, wl_shm_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_buffer_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_buffer_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_buffer_interface
     * }
     */
    public static GroupLayout wl_buffer_interface$layout() {
        return wl_buffer_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_buffer_interface
     * }
     */
    public static MemorySegment wl_buffer_interface() {
        return wl_buffer_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_buffer_interface
     * }
     */
    public static void wl_buffer_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_buffer_interface$constants.SEGMENT, 0L, wl_buffer_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_data_offer_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_data_offer_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_data_offer_interface
     * }
     */
    public static GroupLayout wl_data_offer_interface$layout() {
        return wl_data_offer_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_data_offer_interface
     * }
     */
    public static MemorySegment wl_data_offer_interface() {
        return wl_data_offer_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_data_offer_interface
     * }
     */
    public static void wl_data_offer_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_data_offer_interface$constants.SEGMENT, 0L, wl_data_offer_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_data_source_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_data_source_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_data_source_interface
     * }
     */
    public static GroupLayout wl_data_source_interface$layout() {
        return wl_data_source_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_data_source_interface
     * }
     */
    public static MemorySegment wl_data_source_interface() {
        return wl_data_source_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_data_source_interface
     * }
     */
    public static void wl_data_source_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_data_source_interface$constants.SEGMENT, 0L, wl_data_source_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_data_device_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_data_device_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_data_device_interface
     * }
     */
    public static GroupLayout wl_data_device_interface$layout() {
        return wl_data_device_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_data_device_interface
     * }
     */
    public static MemorySegment wl_data_device_interface() {
        return wl_data_device_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_data_device_interface
     * }
     */
    public static void wl_data_device_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_data_device_interface$constants.SEGMENT, 0L, wl_data_device_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_data_device_manager_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_data_device_manager_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_data_device_manager_interface
     * }
     */
    public static GroupLayout wl_data_device_manager_interface$layout() {
        return wl_data_device_manager_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_data_device_manager_interface
     * }
     */
    public static MemorySegment wl_data_device_manager_interface() {
        return wl_data_device_manager_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_data_device_manager_interface
     * }
     */
    public static void wl_data_device_manager_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_data_device_manager_interface$constants.SEGMENT, 0L, wl_data_device_manager_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_shell_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_shell_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_shell_interface
     * }
     */
    public static GroupLayout wl_shell_interface$layout() {
        return wl_shell_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_shell_interface
     * }
     */
    public static MemorySegment wl_shell_interface() {
        return wl_shell_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_shell_interface
     * }
     */
    public static void wl_shell_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_shell_interface$constants.SEGMENT, 0L, wl_shell_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_shell_surface_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_shell_surface_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_shell_surface_interface
     * }
     */
    public static GroupLayout wl_shell_surface_interface$layout() {
        return wl_shell_surface_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_shell_surface_interface
     * }
     */
    public static MemorySegment wl_shell_surface_interface() {
        return wl_shell_surface_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_shell_surface_interface
     * }
     */
    public static void wl_shell_surface_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_shell_surface_interface$constants.SEGMENT, 0L, wl_shell_surface_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_surface_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_surface_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_surface_interface
     * }
     */
    public static GroupLayout wl_surface_interface$layout() {
        return wl_surface_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_surface_interface
     * }
     */
    public static MemorySegment wl_surface_interface() {
        return wl_surface_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_surface_interface
     * }
     */
    public static void wl_surface_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_surface_interface$constants.SEGMENT, 0L, wl_surface_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_seat_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_seat_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_seat_interface
     * }
     */
    public static GroupLayout wl_seat_interface$layout() {
        return wl_seat_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_seat_interface
     * }
     */
    public static MemorySegment wl_seat_interface() {
        return wl_seat_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_seat_interface
     * }
     */
    public static void wl_seat_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_seat_interface$constants.SEGMENT, 0L, wl_seat_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_pointer_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_pointer_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_pointer_interface
     * }
     */
    public static GroupLayout wl_pointer_interface$layout() {
        return wl_pointer_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_pointer_interface
     * }
     */
    public static MemorySegment wl_pointer_interface() {
        return wl_pointer_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_pointer_interface
     * }
     */
    public static void wl_pointer_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_pointer_interface$constants.SEGMENT, 0L, wl_pointer_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_keyboard_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_keyboard_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_keyboard_interface
     * }
     */
    public static GroupLayout wl_keyboard_interface$layout() {
        return wl_keyboard_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_keyboard_interface
     * }
     */
    public static MemorySegment wl_keyboard_interface() {
        return wl_keyboard_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_keyboard_interface
     * }
     */
    public static void wl_keyboard_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_keyboard_interface$constants.SEGMENT, 0L, wl_keyboard_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_touch_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_touch_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_touch_interface
     * }
     */
    public static GroupLayout wl_touch_interface$layout() {
        return wl_touch_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_touch_interface
     * }
     */
    public static MemorySegment wl_touch_interface() {
        return wl_touch_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_touch_interface
     * }
     */
    public static void wl_touch_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_touch_interface$constants.SEGMENT, 0L, wl_touch_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_output_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_output_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_output_interface
     * }
     */
    public static GroupLayout wl_output_interface$layout() {
        return wl_output_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_output_interface
     * }
     */
    public static MemorySegment wl_output_interface() {
        return wl_output_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_output_interface
     * }
     */
    public static void wl_output_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_output_interface$constants.SEGMENT, 0L, wl_output_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_region_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_region_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_region_interface
     * }
     */
    public static GroupLayout wl_region_interface$layout() {
        return wl_region_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_region_interface
     * }
     */
    public static MemorySegment wl_region_interface() {
        return wl_region_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_region_interface
     * }
     */
    public static void wl_region_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_region_interface$constants.SEGMENT, 0L, wl_region_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_subcompositor_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_subcompositor_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_subcompositor_interface
     * }
     */
    public static GroupLayout wl_subcompositor_interface$layout() {
        return wl_subcompositor_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_subcompositor_interface
     * }
     */
    public static MemorySegment wl_subcompositor_interface() {
        return wl_subcompositor_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_subcompositor_interface
     * }
     */
    public static void wl_subcompositor_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_subcompositor_interface$constants.SEGMENT, 0L, wl_subcompositor_interface$constants.LAYOUT.byteSize());
    }

    private static class wl_subsurface_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("wl_subsurface_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_subsurface_interface
     * }
     */
    public static GroupLayout wl_subsurface_interface$layout() {
        return wl_subsurface_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_subsurface_interface
     * }
     */
    public static MemorySegment wl_subsurface_interface() {
        return wl_subsurface_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface wl_subsurface_interface
     * }
     */
    public static void wl_subsurface_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, wl_subsurface_interface$constants.SEGMENT, 0L, wl_subsurface_interface$constants.LAYOUT.byteSize());
    }
    private static final int WL_DISPLAY_ERROR_INVALID_OBJECT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_display_error.WL_DISPLAY_ERROR_INVALID_OBJECT = 0
     * }
     */
    public static int WL_DISPLAY_ERROR_INVALID_OBJECT() {
        return WL_DISPLAY_ERROR_INVALID_OBJECT;
    }
    private static final int WL_DISPLAY_ERROR_INVALID_METHOD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_display_error.WL_DISPLAY_ERROR_INVALID_METHOD = 1
     * }
     */
    public static int WL_DISPLAY_ERROR_INVALID_METHOD() {
        return WL_DISPLAY_ERROR_INVALID_METHOD;
    }
    private static final int WL_DISPLAY_ERROR_NO_MEMORY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wl_display_error.WL_DISPLAY_ERROR_NO_MEMORY = 2
     * }
     */
    public static int WL_DISPLAY_ERROR_NO_MEMORY() {
        return WL_DISPLAY_ERROR_NO_MEMORY;
    }
    private static final int WL_DISPLAY_ERROR_IMPLEMENTATION = (int)3L;
    /**
     * {@snippet lang=c :
     * enum wl_display_error.WL_DISPLAY_ERROR_IMPLEMENTATION = 3
     * }
     */
    public static int WL_DISPLAY_ERROR_IMPLEMENTATION() {
        return WL_DISPLAY_ERROR_IMPLEMENTATION;
    }
    private static final int WL_SHM_ERROR_INVALID_FORMAT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_error.WL_SHM_ERROR_INVALID_FORMAT = 0
     * }
     */
    public static int WL_SHM_ERROR_INVALID_FORMAT() {
        return WL_SHM_ERROR_INVALID_FORMAT;
    }
    private static final int WL_SHM_ERROR_INVALID_STRIDE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_error.WL_SHM_ERROR_INVALID_STRIDE = 1
     * }
     */
    public static int WL_SHM_ERROR_INVALID_STRIDE() {
        return WL_SHM_ERROR_INVALID_STRIDE;
    }
    private static final int WL_SHM_ERROR_INVALID_FD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_error.WL_SHM_ERROR_INVALID_FD = 2
     * }
     */
    public static int WL_SHM_ERROR_INVALID_FD() {
        return WL_SHM_ERROR_INVALID_FD;
    }
    private static final int WL_SHM_FORMAT_ARGB8888 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_ARGB8888 = 0
     * }
     */
    public static int WL_SHM_FORMAT_ARGB8888() {
        return WL_SHM_FORMAT_ARGB8888;
    }
    private static final int WL_SHM_FORMAT_XRGB8888 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_XRGB8888 = 1
     * }
     */
    public static int WL_SHM_FORMAT_XRGB8888() {
        return WL_SHM_FORMAT_XRGB8888;
    }
    private static final int WL_SHM_FORMAT_C8 = (int)538982467L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_C8 = 538982467
     * }
     */
    public static int WL_SHM_FORMAT_C8() {
        return WL_SHM_FORMAT_C8;
    }
    private static final int WL_SHM_FORMAT_RGB332 = (int)943867730L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_RGB332 = 943867730
     * }
     */
    public static int WL_SHM_FORMAT_RGB332() {
        return WL_SHM_FORMAT_RGB332;
    }
    private static final int WL_SHM_FORMAT_BGR233 = (int)944916290L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_BGR233 = 944916290
     * }
     */
    public static int WL_SHM_FORMAT_BGR233() {
        return WL_SHM_FORMAT_BGR233;
    }
    private static final int WL_SHM_FORMAT_XRGB4444 = (int)842093144L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_XRGB4444 = 842093144
     * }
     */
    public static int WL_SHM_FORMAT_XRGB4444() {
        return WL_SHM_FORMAT_XRGB4444;
    }
    private static final int WL_SHM_FORMAT_XBGR4444 = (int)842089048L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_XBGR4444 = 842089048
     * }
     */
    public static int WL_SHM_FORMAT_XBGR4444() {
        return WL_SHM_FORMAT_XBGR4444;
    }
    private static final int WL_SHM_FORMAT_RGBX4444 = (int)842094674L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_RGBX4444 = 842094674
     * }
     */
    public static int WL_SHM_FORMAT_RGBX4444() {
        return WL_SHM_FORMAT_RGBX4444;
    }
    private static final int WL_SHM_FORMAT_BGRX4444 = (int)842094658L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_BGRX4444 = 842094658
     * }
     */
    public static int WL_SHM_FORMAT_BGRX4444() {
        return WL_SHM_FORMAT_BGRX4444;
    }
    private static final int WL_SHM_FORMAT_ARGB4444 = (int)842093121L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_ARGB4444 = 842093121
     * }
     */
    public static int WL_SHM_FORMAT_ARGB4444() {
        return WL_SHM_FORMAT_ARGB4444;
    }
    private static final int WL_SHM_FORMAT_ABGR4444 = (int)842089025L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_ABGR4444 = 842089025
     * }
     */
    public static int WL_SHM_FORMAT_ABGR4444() {
        return WL_SHM_FORMAT_ABGR4444;
    }
    private static final int WL_SHM_FORMAT_RGBA4444 = (int)842088786L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_RGBA4444 = 842088786
     * }
     */
    public static int WL_SHM_FORMAT_RGBA4444() {
        return WL_SHM_FORMAT_RGBA4444;
    }
    private static final int WL_SHM_FORMAT_BGRA4444 = (int)842088770L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_BGRA4444 = 842088770
     * }
     */
    public static int WL_SHM_FORMAT_BGRA4444() {
        return WL_SHM_FORMAT_BGRA4444;
    }
    private static final int WL_SHM_FORMAT_XRGB1555 = (int)892424792L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_XRGB1555 = 892424792
     * }
     */
    public static int WL_SHM_FORMAT_XRGB1555() {
        return WL_SHM_FORMAT_XRGB1555;
    }
    private static final int WL_SHM_FORMAT_XBGR1555 = (int)892420696L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_XBGR1555 = 892420696
     * }
     */
    public static int WL_SHM_FORMAT_XBGR1555() {
        return WL_SHM_FORMAT_XBGR1555;
    }
    private static final int WL_SHM_FORMAT_RGBX5551 = (int)892426322L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_RGBX5551 = 892426322
     * }
     */
    public static int WL_SHM_FORMAT_RGBX5551() {
        return WL_SHM_FORMAT_RGBX5551;
    }
    private static final int WL_SHM_FORMAT_BGRX5551 = (int)892426306L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_BGRX5551 = 892426306
     * }
     */
    public static int WL_SHM_FORMAT_BGRX5551() {
        return WL_SHM_FORMAT_BGRX5551;
    }
    private static final int WL_SHM_FORMAT_ARGB1555 = (int)892424769L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_ARGB1555 = 892424769
     * }
     */
    public static int WL_SHM_FORMAT_ARGB1555() {
        return WL_SHM_FORMAT_ARGB1555;
    }
    private static final int WL_SHM_FORMAT_ABGR1555 = (int)892420673L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_ABGR1555 = 892420673
     * }
     */
    public static int WL_SHM_FORMAT_ABGR1555() {
        return WL_SHM_FORMAT_ABGR1555;
    }
    private static final int WL_SHM_FORMAT_RGBA5551 = (int)892420434L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_RGBA5551 = 892420434
     * }
     */
    public static int WL_SHM_FORMAT_RGBA5551() {
        return WL_SHM_FORMAT_RGBA5551;
    }
    private static final int WL_SHM_FORMAT_BGRA5551 = (int)892420418L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_BGRA5551 = 892420418
     * }
     */
    public static int WL_SHM_FORMAT_BGRA5551() {
        return WL_SHM_FORMAT_BGRA5551;
    }
    private static final int WL_SHM_FORMAT_RGB565 = (int)909199186L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_RGB565 = 909199186
     * }
     */
    public static int WL_SHM_FORMAT_RGB565() {
        return WL_SHM_FORMAT_RGB565;
    }
    private static final int WL_SHM_FORMAT_BGR565 = (int)909199170L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_BGR565 = 909199170
     * }
     */
    public static int WL_SHM_FORMAT_BGR565() {
        return WL_SHM_FORMAT_BGR565;
    }
    private static final int WL_SHM_FORMAT_RGB888 = (int)875710290L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_RGB888 = 875710290
     * }
     */
    public static int WL_SHM_FORMAT_RGB888() {
        return WL_SHM_FORMAT_RGB888;
    }
    private static final int WL_SHM_FORMAT_BGR888 = (int)875710274L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_BGR888 = 875710274
     * }
     */
    public static int WL_SHM_FORMAT_BGR888() {
        return WL_SHM_FORMAT_BGR888;
    }
    private static final int WL_SHM_FORMAT_XBGR8888 = (int)875709016L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_XBGR8888 = 875709016
     * }
     */
    public static int WL_SHM_FORMAT_XBGR8888() {
        return WL_SHM_FORMAT_XBGR8888;
    }
    private static final int WL_SHM_FORMAT_RGBX8888 = (int)875714642L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_RGBX8888 = 875714642
     * }
     */
    public static int WL_SHM_FORMAT_RGBX8888() {
        return WL_SHM_FORMAT_RGBX8888;
    }
    private static final int WL_SHM_FORMAT_BGRX8888 = (int)875714626L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_BGRX8888 = 875714626
     * }
     */
    public static int WL_SHM_FORMAT_BGRX8888() {
        return WL_SHM_FORMAT_BGRX8888;
    }
    private static final int WL_SHM_FORMAT_ABGR8888 = (int)875708993L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_ABGR8888 = 875708993
     * }
     */
    public static int WL_SHM_FORMAT_ABGR8888() {
        return WL_SHM_FORMAT_ABGR8888;
    }
    private static final int WL_SHM_FORMAT_RGBA8888 = (int)875708754L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_RGBA8888 = 875708754
     * }
     */
    public static int WL_SHM_FORMAT_RGBA8888() {
        return WL_SHM_FORMAT_RGBA8888;
    }
    private static final int WL_SHM_FORMAT_BGRA8888 = (int)875708738L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_BGRA8888 = 875708738
     * }
     */
    public static int WL_SHM_FORMAT_BGRA8888() {
        return WL_SHM_FORMAT_BGRA8888;
    }
    private static final int WL_SHM_FORMAT_XRGB2101010 = (int)808669784L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_XRGB2101010 = 808669784
     * }
     */
    public static int WL_SHM_FORMAT_XRGB2101010() {
        return WL_SHM_FORMAT_XRGB2101010;
    }
    private static final int WL_SHM_FORMAT_XBGR2101010 = (int)808665688L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_XBGR2101010 = 808665688
     * }
     */
    public static int WL_SHM_FORMAT_XBGR2101010() {
        return WL_SHM_FORMAT_XBGR2101010;
    }
    private static final int WL_SHM_FORMAT_RGBX1010102 = (int)808671314L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_RGBX1010102 = 808671314
     * }
     */
    public static int WL_SHM_FORMAT_RGBX1010102() {
        return WL_SHM_FORMAT_RGBX1010102;
    }
    private static final int WL_SHM_FORMAT_BGRX1010102 = (int)808671298L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_BGRX1010102 = 808671298
     * }
     */
    public static int WL_SHM_FORMAT_BGRX1010102() {
        return WL_SHM_FORMAT_BGRX1010102;
    }
    private static final int WL_SHM_FORMAT_ARGB2101010 = (int)808669761L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_ARGB2101010 = 808669761
     * }
     */
    public static int WL_SHM_FORMAT_ARGB2101010() {
        return WL_SHM_FORMAT_ARGB2101010;
    }
    private static final int WL_SHM_FORMAT_ABGR2101010 = (int)808665665L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_ABGR2101010 = 808665665
     * }
     */
    public static int WL_SHM_FORMAT_ABGR2101010() {
        return WL_SHM_FORMAT_ABGR2101010;
    }
    private static final int WL_SHM_FORMAT_RGBA1010102 = (int)808665426L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_RGBA1010102 = 808665426
     * }
     */
    public static int WL_SHM_FORMAT_RGBA1010102() {
        return WL_SHM_FORMAT_RGBA1010102;
    }
    private static final int WL_SHM_FORMAT_BGRA1010102 = (int)808665410L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_BGRA1010102 = 808665410
     * }
     */
    public static int WL_SHM_FORMAT_BGRA1010102() {
        return WL_SHM_FORMAT_BGRA1010102;
    }
    private static final int WL_SHM_FORMAT_YUYV = (int)1448695129L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_YUYV = 1448695129
     * }
     */
    public static int WL_SHM_FORMAT_YUYV() {
        return WL_SHM_FORMAT_YUYV;
    }
    private static final int WL_SHM_FORMAT_YVYU = (int)1431918169L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_YVYU = 1431918169
     * }
     */
    public static int WL_SHM_FORMAT_YVYU() {
        return WL_SHM_FORMAT_YVYU;
    }
    private static final int WL_SHM_FORMAT_UYVY = (int)1498831189L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_UYVY = 1498831189
     * }
     */
    public static int WL_SHM_FORMAT_UYVY() {
        return WL_SHM_FORMAT_UYVY;
    }
    private static final int WL_SHM_FORMAT_VYUY = (int)1498765654L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_VYUY = 1498765654
     * }
     */
    public static int WL_SHM_FORMAT_VYUY() {
        return WL_SHM_FORMAT_VYUY;
    }
    private static final int WL_SHM_FORMAT_AYUV = (int)1448433985L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_AYUV = 1448433985
     * }
     */
    public static int WL_SHM_FORMAT_AYUV() {
        return WL_SHM_FORMAT_AYUV;
    }
    private static final int WL_SHM_FORMAT_NV12 = (int)842094158L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_NV12 = 842094158
     * }
     */
    public static int WL_SHM_FORMAT_NV12() {
        return WL_SHM_FORMAT_NV12;
    }
    private static final int WL_SHM_FORMAT_NV21 = (int)825382478L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_NV21 = 825382478
     * }
     */
    public static int WL_SHM_FORMAT_NV21() {
        return WL_SHM_FORMAT_NV21;
    }
    private static final int WL_SHM_FORMAT_NV16 = (int)909203022L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_NV16 = 909203022
     * }
     */
    public static int WL_SHM_FORMAT_NV16() {
        return WL_SHM_FORMAT_NV16;
    }
    private static final int WL_SHM_FORMAT_NV61 = (int)825644622L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_NV61 = 825644622
     * }
     */
    public static int WL_SHM_FORMAT_NV61() {
        return WL_SHM_FORMAT_NV61;
    }
    private static final int WL_SHM_FORMAT_YUV410 = (int)961959257L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_YUV410 = 961959257
     * }
     */
    public static int WL_SHM_FORMAT_YUV410() {
        return WL_SHM_FORMAT_YUV410;
    }
    private static final int WL_SHM_FORMAT_YVU410 = (int)961893977L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_YVU410 = 961893977
     * }
     */
    public static int WL_SHM_FORMAT_YVU410() {
        return WL_SHM_FORMAT_YVU410;
    }
    private static final int WL_SHM_FORMAT_YUV411 = (int)825316697L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_YUV411 = 825316697
     * }
     */
    public static int WL_SHM_FORMAT_YUV411() {
        return WL_SHM_FORMAT_YUV411;
    }
    private static final int WL_SHM_FORMAT_YVU411 = (int)825316953L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_YVU411 = 825316953
     * }
     */
    public static int WL_SHM_FORMAT_YVU411() {
        return WL_SHM_FORMAT_YVU411;
    }
    private static final int WL_SHM_FORMAT_YUV420 = (int)842093913L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_YUV420 = 842093913
     * }
     */
    public static int WL_SHM_FORMAT_YUV420() {
        return WL_SHM_FORMAT_YUV420;
    }
    private static final int WL_SHM_FORMAT_YVU420 = (int)842094169L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_YVU420 = 842094169
     * }
     */
    public static int WL_SHM_FORMAT_YVU420() {
        return WL_SHM_FORMAT_YVU420;
    }
    private static final int WL_SHM_FORMAT_YUV422 = (int)909202777L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_YUV422 = 909202777
     * }
     */
    public static int WL_SHM_FORMAT_YUV422() {
        return WL_SHM_FORMAT_YUV422;
    }
    private static final int WL_SHM_FORMAT_YVU422 = (int)909203033L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_YVU422 = 909203033
     * }
     */
    public static int WL_SHM_FORMAT_YVU422() {
        return WL_SHM_FORMAT_YVU422;
    }
    private static final int WL_SHM_FORMAT_YUV444 = (int)875713881L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_YUV444 = 875713881
     * }
     */
    public static int WL_SHM_FORMAT_YUV444() {
        return WL_SHM_FORMAT_YUV444;
    }
    private static final int WL_SHM_FORMAT_YVU444 = (int)875714137L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_YVU444 = 875714137
     * }
     */
    public static int WL_SHM_FORMAT_YVU444() {
        return WL_SHM_FORMAT_YVU444;
    }
    private static final int WL_SHM_FORMAT_R8 = (int)538982482L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_R8 = 538982482
     * }
     */
    public static int WL_SHM_FORMAT_R8() {
        return WL_SHM_FORMAT_R8;
    }
    private static final int WL_SHM_FORMAT_R16 = (int)540422482L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_R16 = 540422482
     * }
     */
    public static int WL_SHM_FORMAT_R16() {
        return WL_SHM_FORMAT_R16;
    }
    private static final int WL_SHM_FORMAT_RG88 = (int)943212370L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_RG88 = 943212370
     * }
     */
    public static int WL_SHM_FORMAT_RG88() {
        return WL_SHM_FORMAT_RG88;
    }
    private static final int WL_SHM_FORMAT_GR88 = (int)943215175L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_GR88 = 943215175
     * }
     */
    public static int WL_SHM_FORMAT_GR88() {
        return WL_SHM_FORMAT_GR88;
    }
    private static final int WL_SHM_FORMAT_RG1616 = (int)842221394L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_RG1616 = 842221394
     * }
     */
    public static int WL_SHM_FORMAT_RG1616() {
        return WL_SHM_FORMAT_RG1616;
    }
    private static final int WL_SHM_FORMAT_GR1616 = (int)842224199L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_GR1616 = 842224199
     * }
     */
    public static int WL_SHM_FORMAT_GR1616() {
        return WL_SHM_FORMAT_GR1616;
    }
    private static final int WL_SHM_FORMAT_XRGB16161616F = (int)1211388504L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_XRGB16161616F = 1211388504
     * }
     */
    public static int WL_SHM_FORMAT_XRGB16161616F() {
        return WL_SHM_FORMAT_XRGB16161616F;
    }
    private static final int WL_SHM_FORMAT_XBGR16161616F = (int)1211384408L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_XBGR16161616F = 1211384408
     * }
     */
    public static int WL_SHM_FORMAT_XBGR16161616F() {
        return WL_SHM_FORMAT_XBGR16161616F;
    }
    private static final int WL_SHM_FORMAT_ARGB16161616F = (int)1211388481L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_ARGB16161616F = 1211388481
     * }
     */
    public static int WL_SHM_FORMAT_ARGB16161616F() {
        return WL_SHM_FORMAT_ARGB16161616F;
    }
    private static final int WL_SHM_FORMAT_ABGR16161616F = (int)1211384385L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_ABGR16161616F = 1211384385
     * }
     */
    public static int WL_SHM_FORMAT_ABGR16161616F() {
        return WL_SHM_FORMAT_ABGR16161616F;
    }
    private static final int WL_SHM_FORMAT_XYUV8888 = (int)1448434008L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_XYUV8888 = 1448434008
     * }
     */
    public static int WL_SHM_FORMAT_XYUV8888() {
        return WL_SHM_FORMAT_XYUV8888;
    }
    private static final int WL_SHM_FORMAT_VUY888 = (int)875713878L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_VUY888 = 875713878
     * }
     */
    public static int WL_SHM_FORMAT_VUY888() {
        return WL_SHM_FORMAT_VUY888;
    }
    private static final int WL_SHM_FORMAT_VUY101010 = (int)808670550L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_VUY101010 = 808670550
     * }
     */
    public static int WL_SHM_FORMAT_VUY101010() {
        return WL_SHM_FORMAT_VUY101010;
    }
    private static final int WL_SHM_FORMAT_Y210 = (int)808530521L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_Y210 = 808530521
     * }
     */
    public static int WL_SHM_FORMAT_Y210() {
        return WL_SHM_FORMAT_Y210;
    }
    private static final int WL_SHM_FORMAT_Y212 = (int)842084953L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_Y212 = 842084953
     * }
     */
    public static int WL_SHM_FORMAT_Y212() {
        return WL_SHM_FORMAT_Y212;
    }
    private static final int WL_SHM_FORMAT_Y216 = (int)909193817L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_Y216 = 909193817
     * }
     */
    public static int WL_SHM_FORMAT_Y216() {
        return WL_SHM_FORMAT_Y216;
    }
    private static final int WL_SHM_FORMAT_Y410 = (int)808531033L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_Y410 = 808531033
     * }
     */
    public static int WL_SHM_FORMAT_Y410() {
        return WL_SHM_FORMAT_Y410;
    }
    private static final int WL_SHM_FORMAT_Y412 = (int)842085465L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_Y412 = 842085465
     * }
     */
    public static int WL_SHM_FORMAT_Y412() {
        return WL_SHM_FORMAT_Y412;
    }
    private static final int WL_SHM_FORMAT_Y416 = (int)909194329L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_Y416 = 909194329
     * }
     */
    public static int WL_SHM_FORMAT_Y416() {
        return WL_SHM_FORMAT_Y416;
    }
    private static final int WL_SHM_FORMAT_XVYU2101010 = (int)808670808L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_XVYU2101010 = 808670808
     * }
     */
    public static int WL_SHM_FORMAT_XVYU2101010() {
        return WL_SHM_FORMAT_XVYU2101010;
    }
    private static final int WL_SHM_FORMAT_XVYU12_16161616 = (int)909334104L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_XVYU12_16161616 = 909334104
     * }
     */
    public static int WL_SHM_FORMAT_XVYU12_16161616() {
        return WL_SHM_FORMAT_XVYU12_16161616;
    }
    private static final int WL_SHM_FORMAT_XVYU16161616 = (int)942954072L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_XVYU16161616 = 942954072
     * }
     */
    public static int WL_SHM_FORMAT_XVYU16161616() {
        return WL_SHM_FORMAT_XVYU16161616;
    }
    private static final int WL_SHM_FORMAT_Y0L0 = (int)810299481L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_Y0L0 = 810299481
     * }
     */
    public static int WL_SHM_FORMAT_Y0L0() {
        return WL_SHM_FORMAT_Y0L0;
    }
    private static final int WL_SHM_FORMAT_X0L0 = (int)810299480L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_X0L0 = 810299480
     * }
     */
    public static int WL_SHM_FORMAT_X0L0() {
        return WL_SHM_FORMAT_X0L0;
    }
    private static final int WL_SHM_FORMAT_Y0L2 = (int)843853913L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_Y0L2 = 843853913
     * }
     */
    public static int WL_SHM_FORMAT_Y0L2() {
        return WL_SHM_FORMAT_Y0L2;
    }
    private static final int WL_SHM_FORMAT_X0L2 = (int)843853912L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_X0L2 = 843853912
     * }
     */
    public static int WL_SHM_FORMAT_X0L2() {
        return WL_SHM_FORMAT_X0L2;
    }
    private static final int WL_SHM_FORMAT_YUV420_8BIT = (int)942691673L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_YUV420_8BIT = 942691673
     * }
     */
    public static int WL_SHM_FORMAT_YUV420_8BIT() {
        return WL_SHM_FORMAT_YUV420_8BIT;
    }
    private static final int WL_SHM_FORMAT_YUV420_10BIT = (int)808539481L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_YUV420_10BIT = 808539481
     * }
     */
    public static int WL_SHM_FORMAT_YUV420_10BIT() {
        return WL_SHM_FORMAT_YUV420_10BIT;
    }
    private static final int WL_SHM_FORMAT_XRGB8888_A8 = (int)943805016L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_XRGB8888_A8 = 943805016
     * }
     */
    public static int WL_SHM_FORMAT_XRGB8888_A8() {
        return WL_SHM_FORMAT_XRGB8888_A8;
    }
    private static final int WL_SHM_FORMAT_XBGR8888_A8 = (int)943800920L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_XBGR8888_A8 = 943800920
     * }
     */
    public static int WL_SHM_FORMAT_XBGR8888_A8() {
        return WL_SHM_FORMAT_XBGR8888_A8;
    }
    private static final int WL_SHM_FORMAT_RGBX8888_A8 = (int)943806546L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_RGBX8888_A8 = 943806546
     * }
     */
    public static int WL_SHM_FORMAT_RGBX8888_A8() {
        return WL_SHM_FORMAT_RGBX8888_A8;
    }
    private static final int WL_SHM_FORMAT_BGRX8888_A8 = (int)943806530L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_BGRX8888_A8 = 943806530
     * }
     */
    public static int WL_SHM_FORMAT_BGRX8888_A8() {
        return WL_SHM_FORMAT_BGRX8888_A8;
    }
    private static final int WL_SHM_FORMAT_RGB888_A8 = (int)943798354L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_RGB888_A8 = 943798354
     * }
     */
    public static int WL_SHM_FORMAT_RGB888_A8() {
        return WL_SHM_FORMAT_RGB888_A8;
    }
    private static final int WL_SHM_FORMAT_BGR888_A8 = (int)943798338L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_BGR888_A8 = 943798338
     * }
     */
    public static int WL_SHM_FORMAT_BGR888_A8() {
        return WL_SHM_FORMAT_BGR888_A8;
    }
    private static final int WL_SHM_FORMAT_RGB565_A8 = (int)943797586L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_RGB565_A8 = 943797586
     * }
     */
    public static int WL_SHM_FORMAT_RGB565_A8() {
        return WL_SHM_FORMAT_RGB565_A8;
    }
    private static final int WL_SHM_FORMAT_BGR565_A8 = (int)943797570L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_BGR565_A8 = 943797570
     * }
     */
    public static int WL_SHM_FORMAT_BGR565_A8() {
        return WL_SHM_FORMAT_BGR565_A8;
    }
    private static final int WL_SHM_FORMAT_NV24 = (int)875714126L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_NV24 = 875714126
     * }
     */
    public static int WL_SHM_FORMAT_NV24() {
        return WL_SHM_FORMAT_NV24;
    }
    private static final int WL_SHM_FORMAT_NV42 = (int)842290766L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_NV42 = 842290766
     * }
     */
    public static int WL_SHM_FORMAT_NV42() {
        return WL_SHM_FORMAT_NV42;
    }
    private static final int WL_SHM_FORMAT_P210 = (int)808530512L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_P210 = 808530512
     * }
     */
    public static int WL_SHM_FORMAT_P210() {
        return WL_SHM_FORMAT_P210;
    }
    private static final int WL_SHM_FORMAT_P010 = (int)808530000L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_P010 = 808530000
     * }
     */
    public static int WL_SHM_FORMAT_P010() {
        return WL_SHM_FORMAT_P010;
    }
    private static final int WL_SHM_FORMAT_P012 = (int)842084432L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_P012 = 842084432
     * }
     */
    public static int WL_SHM_FORMAT_P012() {
        return WL_SHM_FORMAT_P012;
    }
    private static final int WL_SHM_FORMAT_P016 = (int)909193296L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_P016 = 909193296
     * }
     */
    public static int WL_SHM_FORMAT_P016() {
        return WL_SHM_FORMAT_P016;
    }
    private static final int WL_SHM_FORMAT_AXBXGXRX106106106106 = (int)808534593L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_AXBXGXRX106106106106 = 808534593
     * }
     */
    public static int WL_SHM_FORMAT_AXBXGXRX106106106106() {
        return WL_SHM_FORMAT_AXBXGXRX106106106106;
    }
    private static final int WL_SHM_FORMAT_NV15 = (int)892425806L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_NV15 = 892425806
     * }
     */
    public static int WL_SHM_FORMAT_NV15() {
        return WL_SHM_FORMAT_NV15;
    }
    private static final int WL_SHM_FORMAT_Q410 = (int)808531025L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_Q410 = 808531025
     * }
     */
    public static int WL_SHM_FORMAT_Q410() {
        return WL_SHM_FORMAT_Q410;
    }
    private static final int WL_SHM_FORMAT_Q401 = (int)825242705L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_Q401 = 825242705
     * }
     */
    public static int WL_SHM_FORMAT_Q401() {
        return WL_SHM_FORMAT_Q401;
    }
    private static final int WL_SHM_FORMAT_XRGB16161616 = (int)942953048L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_XRGB16161616 = 942953048
     * }
     */
    public static int WL_SHM_FORMAT_XRGB16161616() {
        return WL_SHM_FORMAT_XRGB16161616;
    }
    private static final int WL_SHM_FORMAT_XBGR16161616 = (int)942948952L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_XBGR16161616 = 942948952
     * }
     */
    public static int WL_SHM_FORMAT_XBGR16161616() {
        return WL_SHM_FORMAT_XBGR16161616;
    }
    private static final int WL_SHM_FORMAT_ARGB16161616 = (int)942953025L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_ARGB16161616 = 942953025
     * }
     */
    public static int WL_SHM_FORMAT_ARGB16161616() {
        return WL_SHM_FORMAT_ARGB16161616;
    }
    private static final int WL_SHM_FORMAT_ABGR16161616 = (int)942948929L;
    /**
     * {@snippet lang=c :
     * enum wl_shm_format.WL_SHM_FORMAT_ABGR16161616 = 942948929
     * }
     */
    public static int WL_SHM_FORMAT_ABGR16161616() {
        return WL_SHM_FORMAT_ABGR16161616;
    }
    private static final int WL_DATA_OFFER_ERROR_INVALID_FINISH = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_data_offer_error.WL_DATA_OFFER_ERROR_INVALID_FINISH = 0
     * }
     */
    public static int WL_DATA_OFFER_ERROR_INVALID_FINISH() {
        return WL_DATA_OFFER_ERROR_INVALID_FINISH;
    }
    private static final int WL_DATA_OFFER_ERROR_INVALID_ACTION_MASK = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_data_offer_error.WL_DATA_OFFER_ERROR_INVALID_ACTION_MASK = 1
     * }
     */
    public static int WL_DATA_OFFER_ERROR_INVALID_ACTION_MASK() {
        return WL_DATA_OFFER_ERROR_INVALID_ACTION_MASK;
    }
    private static final int WL_DATA_OFFER_ERROR_INVALID_ACTION = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wl_data_offer_error.WL_DATA_OFFER_ERROR_INVALID_ACTION = 2
     * }
     */
    public static int WL_DATA_OFFER_ERROR_INVALID_ACTION() {
        return WL_DATA_OFFER_ERROR_INVALID_ACTION;
    }
    private static final int WL_DATA_OFFER_ERROR_INVALID_OFFER = (int)3L;
    /**
     * {@snippet lang=c :
     * enum wl_data_offer_error.WL_DATA_OFFER_ERROR_INVALID_OFFER = 3
     * }
     */
    public static int WL_DATA_OFFER_ERROR_INVALID_OFFER() {
        return WL_DATA_OFFER_ERROR_INVALID_OFFER;
    }
    private static final int WL_DATA_SOURCE_ERROR_INVALID_ACTION_MASK = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_data_source_error.WL_DATA_SOURCE_ERROR_INVALID_ACTION_MASK = 0
     * }
     */
    public static int WL_DATA_SOURCE_ERROR_INVALID_ACTION_MASK() {
        return WL_DATA_SOURCE_ERROR_INVALID_ACTION_MASK;
    }
    private static final int WL_DATA_SOURCE_ERROR_INVALID_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_data_source_error.WL_DATA_SOURCE_ERROR_INVALID_SOURCE = 1
     * }
     */
    public static int WL_DATA_SOURCE_ERROR_INVALID_SOURCE() {
        return WL_DATA_SOURCE_ERROR_INVALID_SOURCE;
    }
    private static final int WL_DATA_DEVICE_ERROR_ROLE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_data_device_error.WL_DATA_DEVICE_ERROR_ROLE = 0
     * }
     */
    public static int WL_DATA_DEVICE_ERROR_ROLE() {
        return WL_DATA_DEVICE_ERROR_ROLE;
    }
    private static final int WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_data_device_manager_dnd_action.WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE = 0
     * }
     */
    public static int WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE() {
        return WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE;
    }
    private static final int WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_data_device_manager_dnd_action.WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY = 1
     * }
     */
    public static int WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY() {
        return WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY;
    }
    private static final int WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wl_data_device_manager_dnd_action.WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE = 2
     * }
     */
    public static int WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE() {
        return WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE;
    }
    private static final int WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK = (int)4L;
    /**
     * {@snippet lang=c :
     * enum wl_data_device_manager_dnd_action.WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK = 4
     * }
     */
    public static int WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK() {
        return WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK;
    }
    private static final int WL_SHELL_ERROR_ROLE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_shell_error.WL_SHELL_ERROR_ROLE = 0
     * }
     */
    public static int WL_SHELL_ERROR_ROLE() {
        return WL_SHELL_ERROR_ROLE;
    }
    private static final int WL_SHELL_SURFACE_RESIZE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_shell_surface_resize.WL_SHELL_SURFACE_RESIZE_NONE = 0
     * }
     */
    public static int WL_SHELL_SURFACE_RESIZE_NONE() {
        return WL_SHELL_SURFACE_RESIZE_NONE;
    }
    private static final int WL_SHELL_SURFACE_RESIZE_TOP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_shell_surface_resize.WL_SHELL_SURFACE_RESIZE_TOP = 1
     * }
     */
    public static int WL_SHELL_SURFACE_RESIZE_TOP() {
        return WL_SHELL_SURFACE_RESIZE_TOP;
    }
    private static final int WL_SHELL_SURFACE_RESIZE_BOTTOM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wl_shell_surface_resize.WL_SHELL_SURFACE_RESIZE_BOTTOM = 2
     * }
     */
    public static int WL_SHELL_SURFACE_RESIZE_BOTTOM() {
        return WL_SHELL_SURFACE_RESIZE_BOTTOM;
    }
    private static final int WL_SHELL_SURFACE_RESIZE_LEFT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum wl_shell_surface_resize.WL_SHELL_SURFACE_RESIZE_LEFT = 4
     * }
     */
    public static int WL_SHELL_SURFACE_RESIZE_LEFT() {
        return WL_SHELL_SURFACE_RESIZE_LEFT;
    }
    private static final int WL_SHELL_SURFACE_RESIZE_TOP_LEFT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum wl_shell_surface_resize.WL_SHELL_SURFACE_RESIZE_TOP_LEFT = 5
     * }
     */
    public static int WL_SHELL_SURFACE_RESIZE_TOP_LEFT() {
        return WL_SHELL_SURFACE_RESIZE_TOP_LEFT;
    }
    private static final int WL_SHELL_SURFACE_RESIZE_BOTTOM_LEFT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum wl_shell_surface_resize.WL_SHELL_SURFACE_RESIZE_BOTTOM_LEFT = 6
     * }
     */
    public static int WL_SHELL_SURFACE_RESIZE_BOTTOM_LEFT() {
        return WL_SHELL_SURFACE_RESIZE_BOTTOM_LEFT;
    }
    private static final int WL_SHELL_SURFACE_RESIZE_RIGHT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum wl_shell_surface_resize.WL_SHELL_SURFACE_RESIZE_RIGHT = 8
     * }
     */
    public static int WL_SHELL_SURFACE_RESIZE_RIGHT() {
        return WL_SHELL_SURFACE_RESIZE_RIGHT;
    }
    private static final int WL_SHELL_SURFACE_RESIZE_TOP_RIGHT = (int)9L;
    /**
     * {@snippet lang=c :
     * enum wl_shell_surface_resize.WL_SHELL_SURFACE_RESIZE_TOP_RIGHT = 9
     * }
     */
    public static int WL_SHELL_SURFACE_RESIZE_TOP_RIGHT() {
        return WL_SHELL_SURFACE_RESIZE_TOP_RIGHT;
    }
    private static final int WL_SHELL_SURFACE_RESIZE_BOTTOM_RIGHT = (int)10L;
    /**
     * {@snippet lang=c :
     * enum wl_shell_surface_resize.WL_SHELL_SURFACE_RESIZE_BOTTOM_RIGHT = 10
     * }
     */
    public static int WL_SHELL_SURFACE_RESIZE_BOTTOM_RIGHT() {
        return WL_SHELL_SURFACE_RESIZE_BOTTOM_RIGHT;
    }
    private static final int WL_SHELL_SURFACE_TRANSIENT_INACTIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_shell_surface_transient.WL_SHELL_SURFACE_TRANSIENT_INACTIVE = 1
     * }
     */
    public static int WL_SHELL_SURFACE_TRANSIENT_INACTIVE() {
        return WL_SHELL_SURFACE_TRANSIENT_INACTIVE;
    }
    private static final int WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_shell_surface_fullscreen_method.WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT = 0
     * }
     */
    public static int WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT() {
        return WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT;
    }
    private static final int WL_SHELL_SURFACE_FULLSCREEN_METHOD_SCALE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_shell_surface_fullscreen_method.WL_SHELL_SURFACE_FULLSCREEN_METHOD_SCALE = 1
     * }
     */
    public static int WL_SHELL_SURFACE_FULLSCREEN_METHOD_SCALE() {
        return WL_SHELL_SURFACE_FULLSCREEN_METHOD_SCALE;
    }
    private static final int WL_SHELL_SURFACE_FULLSCREEN_METHOD_DRIVER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wl_shell_surface_fullscreen_method.WL_SHELL_SURFACE_FULLSCREEN_METHOD_DRIVER = 2
     * }
     */
    public static int WL_SHELL_SURFACE_FULLSCREEN_METHOD_DRIVER() {
        return WL_SHELL_SURFACE_FULLSCREEN_METHOD_DRIVER;
    }
    private static final int WL_SHELL_SURFACE_FULLSCREEN_METHOD_FILL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum wl_shell_surface_fullscreen_method.WL_SHELL_SURFACE_FULLSCREEN_METHOD_FILL = 3
     * }
     */
    public static int WL_SHELL_SURFACE_FULLSCREEN_METHOD_FILL() {
        return WL_SHELL_SURFACE_FULLSCREEN_METHOD_FILL;
    }
    private static final int WL_SURFACE_ERROR_INVALID_SCALE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_surface_error.WL_SURFACE_ERROR_INVALID_SCALE = 0
     * }
     */
    public static int WL_SURFACE_ERROR_INVALID_SCALE() {
        return WL_SURFACE_ERROR_INVALID_SCALE;
    }
    private static final int WL_SURFACE_ERROR_INVALID_TRANSFORM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_surface_error.WL_SURFACE_ERROR_INVALID_TRANSFORM = 1
     * }
     */
    public static int WL_SURFACE_ERROR_INVALID_TRANSFORM() {
        return WL_SURFACE_ERROR_INVALID_TRANSFORM;
    }
    private static final int WL_SURFACE_ERROR_INVALID_SIZE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wl_surface_error.WL_SURFACE_ERROR_INVALID_SIZE = 2
     * }
     */
    public static int WL_SURFACE_ERROR_INVALID_SIZE() {
        return WL_SURFACE_ERROR_INVALID_SIZE;
    }
    private static final int WL_SURFACE_ERROR_INVALID_OFFSET = (int)3L;
    /**
     * {@snippet lang=c :
     * enum wl_surface_error.WL_SURFACE_ERROR_INVALID_OFFSET = 3
     * }
     */
    public static int WL_SURFACE_ERROR_INVALID_OFFSET() {
        return WL_SURFACE_ERROR_INVALID_OFFSET;
    }
    private static final int WL_SURFACE_ERROR_DEFUNCT_ROLE_OBJECT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum wl_surface_error.WL_SURFACE_ERROR_DEFUNCT_ROLE_OBJECT = 4
     * }
     */
    public static int WL_SURFACE_ERROR_DEFUNCT_ROLE_OBJECT() {
        return WL_SURFACE_ERROR_DEFUNCT_ROLE_OBJECT;
    }
    private static final int WL_SEAT_CAPABILITY_POINTER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_seat_capability.WL_SEAT_CAPABILITY_POINTER = 1
     * }
     */
    public static int WL_SEAT_CAPABILITY_POINTER() {
        return WL_SEAT_CAPABILITY_POINTER;
    }
    private static final int WL_SEAT_CAPABILITY_KEYBOARD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wl_seat_capability.WL_SEAT_CAPABILITY_KEYBOARD = 2
     * }
     */
    public static int WL_SEAT_CAPABILITY_KEYBOARD() {
        return WL_SEAT_CAPABILITY_KEYBOARD;
    }
    private static final int WL_SEAT_CAPABILITY_TOUCH = (int)4L;
    /**
     * {@snippet lang=c :
     * enum wl_seat_capability.WL_SEAT_CAPABILITY_TOUCH = 4
     * }
     */
    public static int WL_SEAT_CAPABILITY_TOUCH() {
        return WL_SEAT_CAPABILITY_TOUCH;
    }
    private static final int WL_SEAT_ERROR_MISSING_CAPABILITY = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_seat_error.WL_SEAT_ERROR_MISSING_CAPABILITY = 0
     * }
     */
    public static int WL_SEAT_ERROR_MISSING_CAPABILITY() {
        return WL_SEAT_ERROR_MISSING_CAPABILITY;
    }
    private static final int WL_POINTER_ERROR_ROLE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_pointer_error.WL_POINTER_ERROR_ROLE = 0
     * }
     */
    public static int WL_POINTER_ERROR_ROLE() {
        return WL_POINTER_ERROR_ROLE;
    }
    private static final int WL_POINTER_BUTTON_STATE_RELEASED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_pointer_button_state.WL_POINTER_BUTTON_STATE_RELEASED = 0
     * }
     */
    public static int WL_POINTER_BUTTON_STATE_RELEASED() {
        return WL_POINTER_BUTTON_STATE_RELEASED;
    }
    private static final int WL_POINTER_BUTTON_STATE_PRESSED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_pointer_button_state.WL_POINTER_BUTTON_STATE_PRESSED = 1
     * }
     */
    public static int WL_POINTER_BUTTON_STATE_PRESSED() {
        return WL_POINTER_BUTTON_STATE_PRESSED;
    }
    private static final int WL_POINTER_AXIS_VERTICAL_SCROLL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_pointer_axis.WL_POINTER_AXIS_VERTICAL_SCROLL = 0
     * }
     */
    public static int WL_POINTER_AXIS_VERTICAL_SCROLL() {
        return WL_POINTER_AXIS_VERTICAL_SCROLL;
    }
    private static final int WL_POINTER_AXIS_HORIZONTAL_SCROLL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_pointer_axis.WL_POINTER_AXIS_HORIZONTAL_SCROLL = 1
     * }
     */
    public static int WL_POINTER_AXIS_HORIZONTAL_SCROLL() {
        return WL_POINTER_AXIS_HORIZONTAL_SCROLL;
    }
    private static final int WL_POINTER_AXIS_SOURCE_WHEEL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_pointer_axis_source.WL_POINTER_AXIS_SOURCE_WHEEL = 0
     * }
     */
    public static int WL_POINTER_AXIS_SOURCE_WHEEL() {
        return WL_POINTER_AXIS_SOURCE_WHEEL;
    }
    private static final int WL_POINTER_AXIS_SOURCE_FINGER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_pointer_axis_source.WL_POINTER_AXIS_SOURCE_FINGER = 1
     * }
     */
    public static int WL_POINTER_AXIS_SOURCE_FINGER() {
        return WL_POINTER_AXIS_SOURCE_FINGER;
    }
    private static final int WL_POINTER_AXIS_SOURCE_CONTINUOUS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wl_pointer_axis_source.WL_POINTER_AXIS_SOURCE_CONTINUOUS = 2
     * }
     */
    public static int WL_POINTER_AXIS_SOURCE_CONTINUOUS() {
        return WL_POINTER_AXIS_SOURCE_CONTINUOUS;
    }
    private static final int WL_POINTER_AXIS_SOURCE_WHEEL_TILT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum wl_pointer_axis_source.WL_POINTER_AXIS_SOURCE_WHEEL_TILT = 3
     * }
     */
    public static int WL_POINTER_AXIS_SOURCE_WHEEL_TILT() {
        return WL_POINTER_AXIS_SOURCE_WHEEL_TILT;
    }
    private static final int WL_POINTER_AXIS_RELATIVE_DIRECTION_IDENTICAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_pointer_axis_relative_direction.WL_POINTER_AXIS_RELATIVE_DIRECTION_IDENTICAL = 0
     * }
     */
    public static int WL_POINTER_AXIS_RELATIVE_DIRECTION_IDENTICAL() {
        return WL_POINTER_AXIS_RELATIVE_DIRECTION_IDENTICAL;
    }
    private static final int WL_POINTER_AXIS_RELATIVE_DIRECTION_INVERTED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_pointer_axis_relative_direction.WL_POINTER_AXIS_RELATIVE_DIRECTION_INVERTED = 1
     * }
     */
    public static int WL_POINTER_AXIS_RELATIVE_DIRECTION_INVERTED() {
        return WL_POINTER_AXIS_RELATIVE_DIRECTION_INVERTED;
    }
    private static final int WL_KEYBOARD_KEYMAP_FORMAT_NO_KEYMAP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_keyboard_keymap_format.WL_KEYBOARD_KEYMAP_FORMAT_NO_KEYMAP = 0
     * }
     */
    public static int WL_KEYBOARD_KEYMAP_FORMAT_NO_KEYMAP() {
        return WL_KEYBOARD_KEYMAP_FORMAT_NO_KEYMAP;
    }
    private static final int WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_keyboard_keymap_format.WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1 = 1
     * }
     */
    public static int WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1() {
        return WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1;
    }
    private static final int WL_KEYBOARD_KEY_STATE_RELEASED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_keyboard_key_state.WL_KEYBOARD_KEY_STATE_RELEASED = 0
     * }
     */
    public static int WL_KEYBOARD_KEY_STATE_RELEASED() {
        return WL_KEYBOARD_KEY_STATE_RELEASED;
    }
    private static final int WL_KEYBOARD_KEY_STATE_PRESSED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_keyboard_key_state.WL_KEYBOARD_KEY_STATE_PRESSED = 1
     * }
     */
    public static int WL_KEYBOARD_KEY_STATE_PRESSED() {
        return WL_KEYBOARD_KEY_STATE_PRESSED;
    }
    private static final int WL_OUTPUT_SUBPIXEL_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_output_subpixel.WL_OUTPUT_SUBPIXEL_UNKNOWN = 0
     * }
     */
    public static int WL_OUTPUT_SUBPIXEL_UNKNOWN() {
        return WL_OUTPUT_SUBPIXEL_UNKNOWN;
    }
    private static final int WL_OUTPUT_SUBPIXEL_NONE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_output_subpixel.WL_OUTPUT_SUBPIXEL_NONE = 1
     * }
     */
    public static int WL_OUTPUT_SUBPIXEL_NONE() {
        return WL_OUTPUT_SUBPIXEL_NONE;
    }
    private static final int WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wl_output_subpixel.WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB = 2
     * }
     */
    public static int WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB() {
        return WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB;
    }
    private static final int WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum wl_output_subpixel.WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR = 3
     * }
     */
    public static int WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR() {
        return WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR;
    }
    private static final int WL_OUTPUT_SUBPIXEL_VERTICAL_RGB = (int)4L;
    /**
     * {@snippet lang=c :
     * enum wl_output_subpixel.WL_OUTPUT_SUBPIXEL_VERTICAL_RGB = 4
     * }
     */
    public static int WL_OUTPUT_SUBPIXEL_VERTICAL_RGB() {
        return WL_OUTPUT_SUBPIXEL_VERTICAL_RGB;
    }
    private static final int WL_OUTPUT_SUBPIXEL_VERTICAL_BGR = (int)5L;
    /**
     * {@snippet lang=c :
     * enum wl_output_subpixel.WL_OUTPUT_SUBPIXEL_VERTICAL_BGR = 5
     * }
     */
    public static int WL_OUTPUT_SUBPIXEL_VERTICAL_BGR() {
        return WL_OUTPUT_SUBPIXEL_VERTICAL_BGR;
    }
    private static final int WL_OUTPUT_TRANSFORM_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_output_transform.WL_OUTPUT_TRANSFORM_NORMAL = 0
     * }
     */
    public static int WL_OUTPUT_TRANSFORM_NORMAL() {
        return WL_OUTPUT_TRANSFORM_NORMAL;
    }
    private static final int WL_OUTPUT_TRANSFORM_90 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_output_transform.WL_OUTPUT_TRANSFORM_90 = 1
     * }
     */
    public static int WL_OUTPUT_TRANSFORM_90() {
        return WL_OUTPUT_TRANSFORM_90;
    }
    private static final int WL_OUTPUT_TRANSFORM_180 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wl_output_transform.WL_OUTPUT_TRANSFORM_180 = 2
     * }
     */
    public static int WL_OUTPUT_TRANSFORM_180() {
        return WL_OUTPUT_TRANSFORM_180;
    }
    private static final int WL_OUTPUT_TRANSFORM_270 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum wl_output_transform.WL_OUTPUT_TRANSFORM_270 = 3
     * }
     */
    public static int WL_OUTPUT_TRANSFORM_270() {
        return WL_OUTPUT_TRANSFORM_270;
    }
    private static final int WL_OUTPUT_TRANSFORM_FLIPPED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum wl_output_transform.WL_OUTPUT_TRANSFORM_FLIPPED = 4
     * }
     */
    public static int WL_OUTPUT_TRANSFORM_FLIPPED() {
        return WL_OUTPUT_TRANSFORM_FLIPPED;
    }
    private static final int WL_OUTPUT_TRANSFORM_FLIPPED_90 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum wl_output_transform.WL_OUTPUT_TRANSFORM_FLIPPED_90 = 5
     * }
     */
    public static int WL_OUTPUT_TRANSFORM_FLIPPED_90() {
        return WL_OUTPUT_TRANSFORM_FLIPPED_90;
    }
    private static final int WL_OUTPUT_TRANSFORM_FLIPPED_180 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum wl_output_transform.WL_OUTPUT_TRANSFORM_FLIPPED_180 = 6
     * }
     */
    public static int WL_OUTPUT_TRANSFORM_FLIPPED_180() {
        return WL_OUTPUT_TRANSFORM_FLIPPED_180;
    }
    private static final int WL_OUTPUT_TRANSFORM_FLIPPED_270 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum wl_output_transform.WL_OUTPUT_TRANSFORM_FLIPPED_270 = 7
     * }
     */
    public static int WL_OUTPUT_TRANSFORM_FLIPPED_270() {
        return WL_OUTPUT_TRANSFORM_FLIPPED_270;
    }
    private static final int WL_OUTPUT_MODE_CURRENT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_output_mode.WL_OUTPUT_MODE_CURRENT = 1
     * }
     */
    public static int WL_OUTPUT_MODE_CURRENT() {
        return WL_OUTPUT_MODE_CURRENT;
    }
    private static final int WL_OUTPUT_MODE_PREFERRED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum wl_output_mode.WL_OUTPUT_MODE_PREFERRED = 2
     * }
     */
    public static int WL_OUTPUT_MODE_PREFERRED() {
        return WL_OUTPUT_MODE_PREFERRED;
    }
    private static final int WL_SUBCOMPOSITOR_ERROR_BAD_SURFACE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_subcompositor_error.WL_SUBCOMPOSITOR_ERROR_BAD_SURFACE = 0
     * }
     */
    public static int WL_SUBCOMPOSITOR_ERROR_BAD_SURFACE() {
        return WL_SUBCOMPOSITOR_ERROR_BAD_SURFACE;
    }
    private static final int WL_SUBCOMPOSITOR_ERROR_BAD_PARENT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum wl_subcompositor_error.WL_SUBCOMPOSITOR_ERROR_BAD_PARENT = 1
     * }
     */
    public static int WL_SUBCOMPOSITOR_ERROR_BAD_PARENT() {
        return WL_SUBCOMPOSITOR_ERROR_BAD_PARENT;
    }
    private static final int WL_SUBSURFACE_ERROR_BAD_SURFACE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum wl_subsurface_error.WL_SUBSURFACE_ERROR_BAD_SURFACE = 0
     * }
     */
    public static int WL_SUBSURFACE_ERROR_BAD_SURFACE() {
        return WL_SUBSURFACE_ERROR_BAD_SURFACE;
    }

    private static class xdg_wm_base_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("xdg_wm_base_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface xdg_wm_base_interface
     * }
     */
    public static GroupLayout xdg_wm_base_interface$layout() {
        return xdg_wm_base_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface xdg_wm_base_interface
     * }
     */
    public static MemorySegment xdg_wm_base_interface() {
        return xdg_wm_base_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface xdg_wm_base_interface
     * }
     */
    public static void xdg_wm_base_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, xdg_wm_base_interface$constants.SEGMENT, 0L, xdg_wm_base_interface$constants.LAYOUT.byteSize());
    }

    private static class xdg_positioner_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("xdg_positioner_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface xdg_positioner_interface
     * }
     */
    public static GroupLayout xdg_positioner_interface$layout() {
        return xdg_positioner_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface xdg_positioner_interface
     * }
     */
    public static MemorySegment xdg_positioner_interface() {
        return xdg_positioner_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface xdg_positioner_interface
     * }
     */
    public static void xdg_positioner_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, xdg_positioner_interface$constants.SEGMENT, 0L, xdg_positioner_interface$constants.LAYOUT.byteSize());
    }

    private static class xdg_surface_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("xdg_surface_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface xdg_surface_interface
     * }
     */
    public static GroupLayout xdg_surface_interface$layout() {
        return xdg_surface_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface xdg_surface_interface
     * }
     */
    public static MemorySegment xdg_surface_interface() {
        return xdg_surface_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface xdg_surface_interface
     * }
     */
    public static void xdg_surface_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, xdg_surface_interface$constants.SEGMENT, 0L, xdg_surface_interface$constants.LAYOUT.byteSize());
    }

    private static class xdg_toplevel_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("xdg_toplevel_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface xdg_toplevel_interface
     * }
     */
    public static GroupLayout xdg_toplevel_interface$layout() {
        return xdg_toplevel_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface xdg_toplevel_interface
     * }
     */
    public static MemorySegment xdg_toplevel_interface() {
        return xdg_toplevel_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface xdg_toplevel_interface
     * }
     */
    public static void xdg_toplevel_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, xdg_toplevel_interface$constants.SEGMENT, 0L, xdg_toplevel_interface$constants.LAYOUT.byteSize());
    }

    private static class xdg_popup_interface$constants {
        public static final GroupLayout LAYOUT = wl_interface.layout();
        public static final MemorySegment SEGMENT = C.findOrThrow("xdg_popup_interface").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface xdg_popup_interface
     * }
     */
    public static GroupLayout xdg_popup_interface$layout() {
        return xdg_popup_interface$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface xdg_popup_interface
     * }
     */
    public static MemorySegment xdg_popup_interface() {
        return xdg_popup_interface$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct wl_interface xdg_popup_interface
     * }
     */
    public static void xdg_popup_interface(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, xdg_popup_interface$constants.SEGMENT, 0L, xdg_popup_interface$constants.LAYOUT.byteSize());
    }
    private static final int XDG_WM_BASE_ERROR_ROLE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum xdg_wm_base_error.XDG_WM_BASE_ERROR_ROLE = 0
     * }
     */
    public static int XDG_WM_BASE_ERROR_ROLE() {
        return XDG_WM_BASE_ERROR_ROLE;
    }
    private static final int XDG_WM_BASE_ERROR_DEFUNCT_SURFACES = (int)1L;
    /**
     * {@snippet lang=c :
     * enum xdg_wm_base_error.XDG_WM_BASE_ERROR_DEFUNCT_SURFACES = 1
     * }
     */
    public static int XDG_WM_BASE_ERROR_DEFUNCT_SURFACES() {
        return XDG_WM_BASE_ERROR_DEFUNCT_SURFACES;
    }
    private static final int XDG_WM_BASE_ERROR_NOT_THE_TOPMOST_POPUP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum xdg_wm_base_error.XDG_WM_BASE_ERROR_NOT_THE_TOPMOST_POPUP = 2
     * }
     */
    public static int XDG_WM_BASE_ERROR_NOT_THE_TOPMOST_POPUP() {
        return XDG_WM_BASE_ERROR_NOT_THE_TOPMOST_POPUP;
    }
    private static final int XDG_WM_BASE_ERROR_INVALID_POPUP_PARENT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum xdg_wm_base_error.XDG_WM_BASE_ERROR_INVALID_POPUP_PARENT = 3
     * }
     */
    public static int XDG_WM_BASE_ERROR_INVALID_POPUP_PARENT() {
        return XDG_WM_BASE_ERROR_INVALID_POPUP_PARENT;
    }
    private static final int XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum xdg_wm_base_error.XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE = 4
     * }
     */
    public static int XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE() {
        return XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE;
    }
    private static final int XDG_WM_BASE_ERROR_INVALID_POSITIONER = (int)5L;
    /**
     * {@snippet lang=c :
     * enum xdg_wm_base_error.XDG_WM_BASE_ERROR_INVALID_POSITIONER = 5
     * }
     */
    public static int XDG_WM_BASE_ERROR_INVALID_POSITIONER() {
        return XDG_WM_BASE_ERROR_INVALID_POSITIONER;
    }
    private static final int XDG_WM_BASE_ERROR_UNRESPONSIVE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum xdg_wm_base_error.XDG_WM_BASE_ERROR_UNRESPONSIVE = 6
     * }
     */
    public static int XDG_WM_BASE_ERROR_UNRESPONSIVE() {
        return XDG_WM_BASE_ERROR_UNRESPONSIVE;
    }
    private static final int XDG_POSITIONER_ERROR_INVALID_INPUT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_error.XDG_POSITIONER_ERROR_INVALID_INPUT = 0
     * }
     */
    public static int XDG_POSITIONER_ERROR_INVALID_INPUT() {
        return XDG_POSITIONER_ERROR_INVALID_INPUT;
    }
    private static final int XDG_POSITIONER_ANCHOR_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_anchor.XDG_POSITIONER_ANCHOR_NONE = 0
     * }
     */
    public static int XDG_POSITIONER_ANCHOR_NONE() {
        return XDG_POSITIONER_ANCHOR_NONE;
    }
    private static final int XDG_POSITIONER_ANCHOR_TOP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_anchor.XDG_POSITIONER_ANCHOR_TOP = 1
     * }
     */
    public static int XDG_POSITIONER_ANCHOR_TOP() {
        return XDG_POSITIONER_ANCHOR_TOP;
    }
    private static final int XDG_POSITIONER_ANCHOR_BOTTOM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_anchor.XDG_POSITIONER_ANCHOR_BOTTOM = 2
     * }
     */
    public static int XDG_POSITIONER_ANCHOR_BOTTOM() {
        return XDG_POSITIONER_ANCHOR_BOTTOM;
    }
    private static final int XDG_POSITIONER_ANCHOR_LEFT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_anchor.XDG_POSITIONER_ANCHOR_LEFT = 3
     * }
     */
    public static int XDG_POSITIONER_ANCHOR_LEFT() {
        return XDG_POSITIONER_ANCHOR_LEFT;
    }
    private static final int XDG_POSITIONER_ANCHOR_RIGHT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_anchor.XDG_POSITIONER_ANCHOR_RIGHT = 4
     * }
     */
    public static int XDG_POSITIONER_ANCHOR_RIGHT() {
        return XDG_POSITIONER_ANCHOR_RIGHT;
    }
    private static final int XDG_POSITIONER_ANCHOR_TOP_LEFT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_anchor.XDG_POSITIONER_ANCHOR_TOP_LEFT = 5
     * }
     */
    public static int XDG_POSITIONER_ANCHOR_TOP_LEFT() {
        return XDG_POSITIONER_ANCHOR_TOP_LEFT;
    }
    private static final int XDG_POSITIONER_ANCHOR_BOTTOM_LEFT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_anchor.XDG_POSITIONER_ANCHOR_BOTTOM_LEFT = 6
     * }
     */
    public static int XDG_POSITIONER_ANCHOR_BOTTOM_LEFT() {
        return XDG_POSITIONER_ANCHOR_BOTTOM_LEFT;
    }
    private static final int XDG_POSITIONER_ANCHOR_TOP_RIGHT = (int)7L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_anchor.XDG_POSITIONER_ANCHOR_TOP_RIGHT = 7
     * }
     */
    public static int XDG_POSITIONER_ANCHOR_TOP_RIGHT() {
        return XDG_POSITIONER_ANCHOR_TOP_RIGHT;
    }
    private static final int XDG_POSITIONER_ANCHOR_BOTTOM_RIGHT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_anchor.XDG_POSITIONER_ANCHOR_BOTTOM_RIGHT = 8
     * }
     */
    public static int XDG_POSITIONER_ANCHOR_BOTTOM_RIGHT() {
        return XDG_POSITIONER_ANCHOR_BOTTOM_RIGHT;
    }
    private static final int XDG_POSITIONER_GRAVITY_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_gravity.XDG_POSITIONER_GRAVITY_NONE = 0
     * }
     */
    public static int XDG_POSITIONER_GRAVITY_NONE() {
        return XDG_POSITIONER_GRAVITY_NONE;
    }
    private static final int XDG_POSITIONER_GRAVITY_TOP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_gravity.XDG_POSITIONER_GRAVITY_TOP = 1
     * }
     */
    public static int XDG_POSITIONER_GRAVITY_TOP() {
        return XDG_POSITIONER_GRAVITY_TOP;
    }
    private static final int XDG_POSITIONER_GRAVITY_BOTTOM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_gravity.XDG_POSITIONER_GRAVITY_BOTTOM = 2
     * }
     */
    public static int XDG_POSITIONER_GRAVITY_BOTTOM() {
        return XDG_POSITIONER_GRAVITY_BOTTOM;
    }
    private static final int XDG_POSITIONER_GRAVITY_LEFT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_gravity.XDG_POSITIONER_GRAVITY_LEFT = 3
     * }
     */
    public static int XDG_POSITIONER_GRAVITY_LEFT() {
        return XDG_POSITIONER_GRAVITY_LEFT;
    }
    private static final int XDG_POSITIONER_GRAVITY_RIGHT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_gravity.XDG_POSITIONER_GRAVITY_RIGHT = 4
     * }
     */
    public static int XDG_POSITIONER_GRAVITY_RIGHT() {
        return XDG_POSITIONER_GRAVITY_RIGHT;
    }
    private static final int XDG_POSITIONER_GRAVITY_TOP_LEFT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_gravity.XDG_POSITIONER_GRAVITY_TOP_LEFT = 5
     * }
     */
    public static int XDG_POSITIONER_GRAVITY_TOP_LEFT() {
        return XDG_POSITIONER_GRAVITY_TOP_LEFT;
    }
    private static final int XDG_POSITIONER_GRAVITY_BOTTOM_LEFT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_gravity.XDG_POSITIONER_GRAVITY_BOTTOM_LEFT = 6
     * }
     */
    public static int XDG_POSITIONER_GRAVITY_BOTTOM_LEFT() {
        return XDG_POSITIONER_GRAVITY_BOTTOM_LEFT;
    }
    private static final int XDG_POSITIONER_GRAVITY_TOP_RIGHT = (int)7L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_gravity.XDG_POSITIONER_GRAVITY_TOP_RIGHT = 7
     * }
     */
    public static int XDG_POSITIONER_GRAVITY_TOP_RIGHT() {
        return XDG_POSITIONER_GRAVITY_TOP_RIGHT;
    }
    private static final int XDG_POSITIONER_GRAVITY_BOTTOM_RIGHT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_gravity.XDG_POSITIONER_GRAVITY_BOTTOM_RIGHT = 8
     * }
     */
    public static int XDG_POSITIONER_GRAVITY_BOTTOM_RIGHT() {
        return XDG_POSITIONER_GRAVITY_BOTTOM_RIGHT;
    }
    private static final int XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_constraint_adjustment.XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_NONE = 0
     * }
     */
    public static int XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_NONE() {
        return XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_NONE;
    }
    private static final int XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_X = (int)1L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_constraint_adjustment.XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_X = 1
     * }
     */
    public static int XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_X() {
        return XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_X;
    }
    private static final int XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_Y = (int)2L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_constraint_adjustment.XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_Y = 2
     * }
     */
    public static int XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_Y() {
        return XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_Y;
    }
    private static final int XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_X = (int)4L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_constraint_adjustment.XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_X = 4
     * }
     */
    public static int XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_X() {
        return XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_X;
    }
    private static final int XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_Y = (int)8L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_constraint_adjustment.XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_Y = 8
     * }
     */
    public static int XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_Y() {
        return XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_Y;
    }
    private static final int XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_X = (int)16L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_constraint_adjustment.XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_X = 16
     * }
     */
    public static int XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_X() {
        return XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_X;
    }
    private static final int XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_Y = (int)32L;
    /**
     * {@snippet lang=c :
     * enum xdg_positioner_constraint_adjustment.XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_Y = 32
     * }
     */
    public static int XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_Y() {
        return XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_Y;
    }
    private static final int XDG_SURFACE_ERROR_NOT_CONSTRUCTED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum xdg_surface_error.XDG_SURFACE_ERROR_NOT_CONSTRUCTED = 1
     * }
     */
    public static int XDG_SURFACE_ERROR_NOT_CONSTRUCTED() {
        return XDG_SURFACE_ERROR_NOT_CONSTRUCTED;
    }
    private static final int XDG_SURFACE_ERROR_ALREADY_CONSTRUCTED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum xdg_surface_error.XDG_SURFACE_ERROR_ALREADY_CONSTRUCTED = 2
     * }
     */
    public static int XDG_SURFACE_ERROR_ALREADY_CONSTRUCTED() {
        return XDG_SURFACE_ERROR_ALREADY_CONSTRUCTED;
    }
    private static final int XDG_SURFACE_ERROR_UNCONFIGURED_BUFFER = (int)3L;
    /**
     * {@snippet lang=c :
     * enum xdg_surface_error.XDG_SURFACE_ERROR_UNCONFIGURED_BUFFER = 3
     * }
     */
    public static int XDG_SURFACE_ERROR_UNCONFIGURED_BUFFER() {
        return XDG_SURFACE_ERROR_UNCONFIGURED_BUFFER;
    }
    private static final int XDG_SURFACE_ERROR_INVALID_SERIAL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum xdg_surface_error.XDG_SURFACE_ERROR_INVALID_SERIAL = 4
     * }
     */
    public static int XDG_SURFACE_ERROR_INVALID_SERIAL() {
        return XDG_SURFACE_ERROR_INVALID_SERIAL;
    }
    private static final int XDG_SURFACE_ERROR_INVALID_SIZE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum xdg_surface_error.XDG_SURFACE_ERROR_INVALID_SIZE = 5
     * }
     */
    public static int XDG_SURFACE_ERROR_INVALID_SIZE() {
        return XDG_SURFACE_ERROR_INVALID_SIZE;
    }
    private static final int XDG_SURFACE_ERROR_DEFUNCT_ROLE_OBJECT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum xdg_surface_error.XDG_SURFACE_ERROR_DEFUNCT_ROLE_OBJECT = 6
     * }
     */
    public static int XDG_SURFACE_ERROR_DEFUNCT_ROLE_OBJECT() {
        return XDG_SURFACE_ERROR_DEFUNCT_ROLE_OBJECT;
    }
    private static final int XDG_TOPLEVEL_ERROR_INVALID_RESIZE_EDGE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_error.XDG_TOPLEVEL_ERROR_INVALID_RESIZE_EDGE = 0
     * }
     */
    public static int XDG_TOPLEVEL_ERROR_INVALID_RESIZE_EDGE() {
        return XDG_TOPLEVEL_ERROR_INVALID_RESIZE_EDGE;
    }
    private static final int XDG_TOPLEVEL_ERROR_INVALID_PARENT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_error.XDG_TOPLEVEL_ERROR_INVALID_PARENT = 1
     * }
     */
    public static int XDG_TOPLEVEL_ERROR_INVALID_PARENT() {
        return XDG_TOPLEVEL_ERROR_INVALID_PARENT;
    }
    private static final int XDG_TOPLEVEL_ERROR_INVALID_SIZE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_error.XDG_TOPLEVEL_ERROR_INVALID_SIZE = 2
     * }
     */
    public static int XDG_TOPLEVEL_ERROR_INVALID_SIZE() {
        return XDG_TOPLEVEL_ERROR_INVALID_SIZE;
    }
    private static final int XDG_TOPLEVEL_RESIZE_EDGE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_resize_edge.XDG_TOPLEVEL_RESIZE_EDGE_NONE = 0
     * }
     */
    public static int XDG_TOPLEVEL_RESIZE_EDGE_NONE() {
        return XDG_TOPLEVEL_RESIZE_EDGE_NONE;
    }
    private static final int XDG_TOPLEVEL_RESIZE_EDGE_TOP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_resize_edge.XDG_TOPLEVEL_RESIZE_EDGE_TOP = 1
     * }
     */
    public static int XDG_TOPLEVEL_RESIZE_EDGE_TOP() {
        return XDG_TOPLEVEL_RESIZE_EDGE_TOP;
    }
    private static final int XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_resize_edge.XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM = 2
     * }
     */
    public static int XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM() {
        return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM;
    }
    private static final int XDG_TOPLEVEL_RESIZE_EDGE_LEFT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_resize_edge.XDG_TOPLEVEL_RESIZE_EDGE_LEFT = 4
     * }
     */
    public static int XDG_TOPLEVEL_RESIZE_EDGE_LEFT() {
        return XDG_TOPLEVEL_RESIZE_EDGE_LEFT;
    }
    private static final int XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_resize_edge.XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT = 5
     * }
     */
    public static int XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT() {
        return XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT;
    }
    private static final int XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_resize_edge.XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT = 6
     * }
     */
    public static int XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT() {
        return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT;
    }
    private static final int XDG_TOPLEVEL_RESIZE_EDGE_RIGHT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_resize_edge.XDG_TOPLEVEL_RESIZE_EDGE_RIGHT = 8
     * }
     */
    public static int XDG_TOPLEVEL_RESIZE_EDGE_RIGHT() {
        return XDG_TOPLEVEL_RESIZE_EDGE_RIGHT;
    }
    private static final int XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT = (int)9L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_resize_edge.XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT = 9
     * }
     */
    public static int XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT() {
        return XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT;
    }
    private static final int XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT = (int)10L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_resize_edge.XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT = 10
     * }
     */
    public static int XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT() {
        return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT;
    }
    private static final int XDG_TOPLEVEL_STATE_MAXIMIZED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_state.XDG_TOPLEVEL_STATE_MAXIMIZED = 1
     * }
     */
    public static int XDG_TOPLEVEL_STATE_MAXIMIZED() {
        return XDG_TOPLEVEL_STATE_MAXIMIZED;
    }
    private static final int XDG_TOPLEVEL_STATE_FULLSCREEN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_state.XDG_TOPLEVEL_STATE_FULLSCREEN = 2
     * }
     */
    public static int XDG_TOPLEVEL_STATE_FULLSCREEN() {
        return XDG_TOPLEVEL_STATE_FULLSCREEN;
    }
    private static final int XDG_TOPLEVEL_STATE_RESIZING = (int)3L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_state.XDG_TOPLEVEL_STATE_RESIZING = 3
     * }
     */
    public static int XDG_TOPLEVEL_STATE_RESIZING() {
        return XDG_TOPLEVEL_STATE_RESIZING;
    }
    private static final int XDG_TOPLEVEL_STATE_ACTIVATED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_state.XDG_TOPLEVEL_STATE_ACTIVATED = 4
     * }
     */
    public static int XDG_TOPLEVEL_STATE_ACTIVATED() {
        return XDG_TOPLEVEL_STATE_ACTIVATED;
    }
    private static final int XDG_TOPLEVEL_STATE_TILED_LEFT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_state.XDG_TOPLEVEL_STATE_TILED_LEFT = 5
     * }
     */
    public static int XDG_TOPLEVEL_STATE_TILED_LEFT() {
        return XDG_TOPLEVEL_STATE_TILED_LEFT;
    }
    private static final int XDG_TOPLEVEL_STATE_TILED_RIGHT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_state.XDG_TOPLEVEL_STATE_TILED_RIGHT = 6
     * }
     */
    public static int XDG_TOPLEVEL_STATE_TILED_RIGHT() {
        return XDG_TOPLEVEL_STATE_TILED_RIGHT;
    }
    private static final int XDG_TOPLEVEL_STATE_TILED_TOP = (int)7L;
    /**
     * {@snippet lang=c :
     * enum xdg_toplevel_state.XDG_TOPLEVEL_STATE_TILED_TOP = 7
     * }
     */
    public static int XDG_TOPLEVEL_STATE_TILED_TOP() {
        return XDG_TOPLEVEL_STATE_TILED_TOP;
    }
}

