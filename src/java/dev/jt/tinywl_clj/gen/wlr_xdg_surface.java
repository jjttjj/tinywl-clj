// Generated by jextract

package dev.jt.tinywl_clj.gen;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct wlr_xdg_surface {
 *     struct wlr_xdg_client *client;
 *     struct wl_resource *resource;
 *     struct wlr_surface *surface;
 *     struct wl_list link;
 *     enum wlr_xdg_surface_role role;
 *     struct wl_resource *role_resource;
 *     union {
 *         struct wlr_xdg_toplevel *toplevel;
 *         struct wlr_xdg_popup *popup;
 *     };
 *     struct wl_list popups;
 *     bool added;
 *     bool configured;
 *     struct wl_event_source *configure_idle;
 *     uint32_t scheduled_serial;
 *     struct wl_list configure_list;
 *     struct wlr_xdg_surface_state current;
 *     struct wlr_xdg_surface_state pending;
 *     bool initialized;
 *     bool initial_commit;
 *     struct {
 *         struct wl_signal destroy;
 *         struct wl_signal ping_timeout;
 *         struct wl_signal new_popup;
 *         struct wl_signal configure;
 *         struct wl_signal ack_configure;
 *     } events;
 *     void *data;
 *     struct wl_listener role_resource_destroy;
 * }
 * }
 */
public class wlr_xdg_surface {

    wlr_xdg_surface() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        C.C_POINTER.withName("client"),
        C.C_POINTER.withName("resource"),
        C.C_POINTER.withName("surface"),
        wl_list.layout().withName("link"),
        C.C_INT.withName("role"),
        MemoryLayout.paddingLayout(4),
        C.C_POINTER.withName("role_resource"),
        MemoryLayout.unionLayout(
            C.C_POINTER.withName("toplevel"),
            C.C_POINTER.withName("popup")
        ).withName("$anon$245:2"),
        wl_list.layout().withName("popups"),
        C.C_BOOL.withName("added"),
        C.C_BOOL.withName("configured"),
        MemoryLayout.paddingLayout(6),
        C.C_POINTER.withName("configure_idle"),
        C.C_INT.withName("scheduled_serial"),
        MemoryLayout.paddingLayout(4),
        wl_list.layout().withName("configure_list"),
        wlr_xdg_surface_state.layout().withName("current"),
        wlr_xdg_surface_state.layout().withName("pending"),
        C.C_BOOL.withName("initialized"),
        C.C_BOOL.withName("initial_commit"),
        MemoryLayout.paddingLayout(6),
        wlr_xdg_surface.events.layout().withName("events"),
        C.C_POINTER.withName("data"),
        wl_listener.layout().withName("role_resource_destroy")
    ).withName("wlr_xdg_surface");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final AddressLayout client$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("client"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct wlr_xdg_client *client
     * }
     */
    public static final AddressLayout client$layout() {
        return client$LAYOUT;
    }

    private static final long client$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct wlr_xdg_client *client
     * }
     */
    public static final long client$offset() {
        return client$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct wlr_xdg_client *client
     * }
     */
    public static MemorySegment client(MemorySegment struct) {
        return struct.get(client$LAYOUT, client$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct wlr_xdg_client *client
     * }
     */
    public static void client(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(client$LAYOUT, client$OFFSET, fieldValue);
    }

    private static final AddressLayout resource$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("resource"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct wl_resource *resource
     * }
     */
    public static final AddressLayout resource$layout() {
        return resource$LAYOUT;
    }

    private static final long resource$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct wl_resource *resource
     * }
     */
    public static final long resource$offset() {
        return resource$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct wl_resource *resource
     * }
     */
    public static MemorySegment resource(MemorySegment struct) {
        return struct.get(resource$LAYOUT, resource$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct wl_resource *resource
     * }
     */
    public static void resource(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(resource$LAYOUT, resource$OFFSET, fieldValue);
    }

    private static final AddressLayout surface$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("surface"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct wlr_surface *surface
     * }
     */
    public static final AddressLayout surface$layout() {
        return surface$LAYOUT;
    }

    private static final long surface$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct wlr_surface *surface
     * }
     */
    public static final long surface$offset() {
        return surface$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct wlr_surface *surface
     * }
     */
    public static MemorySegment surface(MemorySegment struct) {
        return struct.get(surface$LAYOUT, surface$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct wlr_surface *surface
     * }
     */
    public static void surface(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(surface$LAYOUT, surface$OFFSET, fieldValue);
    }

    private static final GroupLayout link$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("link"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct wl_list link
     * }
     */
    public static final GroupLayout link$layout() {
        return link$LAYOUT;
    }

    private static final long link$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct wl_list link
     * }
     */
    public static final long link$offset() {
        return link$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct wl_list link
     * }
     */
    public static MemorySegment link(MemorySegment struct) {
        return struct.asSlice(link$OFFSET, link$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct wl_list link
     * }
     */
    public static void link(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, link$OFFSET, link$LAYOUT.byteSize());
    }

    private static final OfInt role$LAYOUT = (OfInt)$LAYOUT.select(groupElement("role"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum wlr_xdg_surface_role role
     * }
     */
    public static final OfInt role$layout() {
        return role$LAYOUT;
    }

    private static final long role$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum wlr_xdg_surface_role role
     * }
     */
    public static final long role$offset() {
        return role$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum wlr_xdg_surface_role role
     * }
     */
    public static int role(MemorySegment struct) {
        return struct.get(role$LAYOUT, role$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum wlr_xdg_surface_role role
     * }
     */
    public static void role(MemorySegment struct, int fieldValue) {
        struct.set(role$LAYOUT, role$OFFSET, fieldValue);
    }

    private static final AddressLayout role_resource$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("role_resource"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct wl_resource *role_resource
     * }
     */
    public static final AddressLayout role_resource$layout() {
        return role_resource$LAYOUT;
    }

    private static final long role_resource$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct wl_resource *role_resource
     * }
     */
    public static final long role_resource$offset() {
        return role_resource$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct wl_resource *role_resource
     * }
     */
    public static MemorySegment role_resource(MemorySegment struct) {
        return struct.get(role_resource$LAYOUT, role_resource$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct wl_resource *role_resource
     * }
     */
    public static void role_resource(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(role_resource$LAYOUT, role_resource$OFFSET, fieldValue);
    }

    private static final AddressLayout toplevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("$anon$245:2"), groupElement("toplevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct wlr_xdg_toplevel *toplevel
     * }
     */
    public static final AddressLayout toplevel$layout() {
        return toplevel$LAYOUT;
    }

    private static final long toplevel$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct wlr_xdg_toplevel *toplevel
     * }
     */
    public static final long toplevel$offset() {
        return toplevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct wlr_xdg_toplevel *toplevel
     * }
     */
    public static MemorySegment toplevel(MemorySegment struct) {
        return struct.get(toplevel$LAYOUT, toplevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct wlr_xdg_toplevel *toplevel
     * }
     */
    public static void toplevel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(toplevel$LAYOUT, toplevel$OFFSET, fieldValue);
    }

    private static final AddressLayout popup$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("$anon$245:2"), groupElement("popup"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct wlr_xdg_popup *popup
     * }
     */
    public static final AddressLayout popup$layout() {
        return popup$LAYOUT;
    }

    private static final long popup$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct wlr_xdg_popup *popup
     * }
     */
    public static final long popup$offset() {
        return popup$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct wlr_xdg_popup *popup
     * }
     */
    public static MemorySegment popup(MemorySegment struct) {
        return struct.get(popup$LAYOUT, popup$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct wlr_xdg_popup *popup
     * }
     */
    public static void popup(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(popup$LAYOUT, popup$OFFSET, fieldValue);
    }

    private static final GroupLayout popups$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("popups"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct wl_list popups
     * }
     */
    public static final GroupLayout popups$layout() {
        return popups$LAYOUT;
    }

    private static final long popups$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct wl_list popups
     * }
     */
    public static final long popups$offset() {
        return popups$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct wl_list popups
     * }
     */
    public static MemorySegment popups(MemorySegment struct) {
        return struct.asSlice(popups$OFFSET, popups$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct wl_list popups
     * }
     */
    public static void popups(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, popups$OFFSET, popups$LAYOUT.byteSize());
    }

    private static final OfBoolean added$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("added"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool added
     * }
     */
    public static final OfBoolean added$layout() {
        return added$LAYOUT;
    }

    private static final long added$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool added
     * }
     */
    public static final long added$offset() {
        return added$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool added
     * }
     */
    public static boolean added(MemorySegment struct) {
        return struct.get(added$LAYOUT, added$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool added
     * }
     */
    public static void added(MemorySegment struct, boolean fieldValue) {
        struct.set(added$LAYOUT, added$OFFSET, fieldValue);
    }

    private static final OfBoolean configured$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("configured"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool configured
     * }
     */
    public static final OfBoolean configured$layout() {
        return configured$LAYOUT;
    }

    private static final long configured$OFFSET = 81;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool configured
     * }
     */
    public static final long configured$offset() {
        return configured$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool configured
     * }
     */
    public static boolean configured(MemorySegment struct) {
        return struct.get(configured$LAYOUT, configured$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool configured
     * }
     */
    public static void configured(MemorySegment struct, boolean fieldValue) {
        struct.set(configured$LAYOUT, configured$OFFSET, fieldValue);
    }

    private static final AddressLayout configure_idle$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("configure_idle"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct wl_event_source *configure_idle
     * }
     */
    public static final AddressLayout configure_idle$layout() {
        return configure_idle$LAYOUT;
    }

    private static final long configure_idle$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct wl_event_source *configure_idle
     * }
     */
    public static final long configure_idle$offset() {
        return configure_idle$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct wl_event_source *configure_idle
     * }
     */
    public static MemorySegment configure_idle(MemorySegment struct) {
        return struct.get(configure_idle$LAYOUT, configure_idle$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct wl_event_source *configure_idle
     * }
     */
    public static void configure_idle(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(configure_idle$LAYOUT, configure_idle$OFFSET, fieldValue);
    }

    private static final OfInt scheduled_serial$LAYOUT = (OfInt)$LAYOUT.select(groupElement("scheduled_serial"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t scheduled_serial
     * }
     */
    public static final OfInt scheduled_serial$layout() {
        return scheduled_serial$LAYOUT;
    }

    private static final long scheduled_serial$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t scheduled_serial
     * }
     */
    public static final long scheduled_serial$offset() {
        return scheduled_serial$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t scheduled_serial
     * }
     */
    public static int scheduled_serial(MemorySegment struct) {
        return struct.get(scheduled_serial$LAYOUT, scheduled_serial$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t scheduled_serial
     * }
     */
    public static void scheduled_serial(MemorySegment struct, int fieldValue) {
        struct.set(scheduled_serial$LAYOUT, scheduled_serial$OFFSET, fieldValue);
    }

    private static final GroupLayout configure_list$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("configure_list"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct wl_list configure_list
     * }
     */
    public static final GroupLayout configure_list$layout() {
        return configure_list$LAYOUT;
    }

    private static final long configure_list$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct wl_list configure_list
     * }
     */
    public static final long configure_list$offset() {
        return configure_list$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct wl_list configure_list
     * }
     */
    public static MemorySegment configure_list(MemorySegment struct) {
        return struct.asSlice(configure_list$OFFSET, configure_list$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct wl_list configure_list
     * }
     */
    public static void configure_list(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, configure_list$OFFSET, configure_list$LAYOUT.byteSize());
    }

    private static final GroupLayout current$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("current"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct wlr_xdg_surface_state current
     * }
     */
    public static final GroupLayout current$layout() {
        return current$LAYOUT;
    }

    private static final long current$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct wlr_xdg_surface_state current
     * }
     */
    public static final long current$offset() {
        return current$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct wlr_xdg_surface_state current
     * }
     */
    public static MemorySegment current(MemorySegment struct) {
        return struct.asSlice(current$OFFSET, current$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct wlr_xdg_surface_state current
     * }
     */
    public static void current(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, current$OFFSET, current$LAYOUT.byteSize());
    }

    private static final GroupLayout pending$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("pending"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct wlr_xdg_surface_state pending
     * }
     */
    public static final GroupLayout pending$layout() {
        return pending$LAYOUT;
    }

    private static final long pending$OFFSET = 140;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct wlr_xdg_surface_state pending
     * }
     */
    public static final long pending$offset() {
        return pending$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct wlr_xdg_surface_state pending
     * }
     */
    public static MemorySegment pending(MemorySegment struct) {
        return struct.asSlice(pending$OFFSET, pending$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct wlr_xdg_surface_state pending
     * }
     */
    public static void pending(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, pending$OFFSET, pending$LAYOUT.byteSize());
    }

    private static final OfBoolean initialized$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("initialized"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool initialized
     * }
     */
    public static final OfBoolean initialized$layout() {
        return initialized$LAYOUT;
    }

    private static final long initialized$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool initialized
     * }
     */
    public static final long initialized$offset() {
        return initialized$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool initialized
     * }
     */
    public static boolean initialized(MemorySegment struct) {
        return struct.get(initialized$LAYOUT, initialized$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool initialized
     * }
     */
    public static void initialized(MemorySegment struct, boolean fieldValue) {
        struct.set(initialized$LAYOUT, initialized$OFFSET, fieldValue);
    }

    private static final OfBoolean initial_commit$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("initial_commit"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool initial_commit
     * }
     */
    public static final OfBoolean initial_commit$layout() {
        return initial_commit$LAYOUT;
    }

    private static final long initial_commit$OFFSET = 161;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool initial_commit
     * }
     */
    public static final long initial_commit$offset() {
        return initial_commit$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool initial_commit
     * }
     */
    public static boolean initial_commit(MemorySegment struct) {
        return struct.get(initial_commit$LAYOUT, initial_commit$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool initial_commit
     * }
     */
    public static void initial_commit(MemorySegment struct, boolean fieldValue) {
        struct.set(initial_commit$LAYOUT, initial_commit$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     struct wl_signal destroy;
     *     struct wl_signal ping_timeout;
     *     struct wl_signal new_popup;
     *     struct wl_signal configure;
     *     struct wl_signal ack_configure;
     * }
     * }
     */
    public static class events {

        events() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            wl_signal.layout().withName("destroy"),
            wl_signal.layout().withName("ping_timeout"),
            wl_signal.layout().withName("new_popup"),
            wl_signal.layout().withName("configure"),
            wl_signal.layout().withName("ack_configure")
        ).withName("$anon$264:2");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final GroupLayout destroy$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("destroy"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct wl_signal destroy
         * }
         */
        public static final GroupLayout destroy$layout() {
            return destroy$LAYOUT;
        }

        private static final long destroy$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct wl_signal destroy
         * }
         */
        public static final long destroy$offset() {
            return destroy$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct wl_signal destroy
         * }
         */
        public static MemorySegment destroy(MemorySegment struct) {
            return struct.asSlice(destroy$OFFSET, destroy$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct wl_signal destroy
         * }
         */
        public static void destroy(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, destroy$OFFSET, destroy$LAYOUT.byteSize());
        }

        private static final GroupLayout ping_timeout$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("ping_timeout"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct wl_signal ping_timeout
         * }
         */
        public static final GroupLayout ping_timeout$layout() {
            return ping_timeout$LAYOUT;
        }

        private static final long ping_timeout$OFFSET = 16;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct wl_signal ping_timeout
         * }
         */
        public static final long ping_timeout$offset() {
            return ping_timeout$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct wl_signal ping_timeout
         * }
         */
        public static MemorySegment ping_timeout(MemorySegment struct) {
            return struct.asSlice(ping_timeout$OFFSET, ping_timeout$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct wl_signal ping_timeout
         * }
         */
        public static void ping_timeout(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, ping_timeout$OFFSET, ping_timeout$LAYOUT.byteSize());
        }

        private static final GroupLayout new_popup$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("new_popup"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct wl_signal new_popup
         * }
         */
        public static final GroupLayout new_popup$layout() {
            return new_popup$LAYOUT;
        }

        private static final long new_popup$OFFSET = 32;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct wl_signal new_popup
         * }
         */
        public static final long new_popup$offset() {
            return new_popup$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct wl_signal new_popup
         * }
         */
        public static MemorySegment new_popup(MemorySegment struct) {
            return struct.asSlice(new_popup$OFFSET, new_popup$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct wl_signal new_popup
         * }
         */
        public static void new_popup(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, new_popup$OFFSET, new_popup$LAYOUT.byteSize());
        }

        private static final GroupLayout configure$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("configure"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct wl_signal configure
         * }
         */
        public static final GroupLayout configure$layout() {
            return configure$LAYOUT;
        }

        private static final long configure$OFFSET = 48;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct wl_signal configure
         * }
         */
        public static final long configure$offset() {
            return configure$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct wl_signal configure
         * }
         */
        public static MemorySegment configure(MemorySegment struct) {
            return struct.asSlice(configure$OFFSET, configure$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct wl_signal configure
         * }
         */
        public static void configure(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, configure$OFFSET, configure$LAYOUT.byteSize());
        }

        private static final GroupLayout ack_configure$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("ack_configure"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct wl_signal ack_configure
         * }
         */
        public static final GroupLayout ack_configure$layout() {
            return ack_configure$LAYOUT;
        }

        private static final long ack_configure$OFFSET = 64;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct wl_signal ack_configure
         * }
         */
        public static final long ack_configure$offset() {
            return ack_configure$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct wl_signal ack_configure
         * }
         */
        public static MemorySegment ack_configure(MemorySegment struct) {
            return struct.asSlice(ack_configure$OFFSET, ack_configure$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct wl_signal ack_configure
         * }
         */
        public static void ack_configure(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, ack_configure$OFFSET, ack_configure$LAYOUT.byteSize());
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout events$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("events"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     struct wl_signal destroy;
     *     struct wl_signal ping_timeout;
     *     struct wl_signal new_popup;
     *     struct wl_signal configure;
     *     struct wl_signal ack_configure;
     * } events
     * }
     */
    public static final GroupLayout events$layout() {
        return events$LAYOUT;
    }

    private static final long events$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     struct wl_signal destroy;
     *     struct wl_signal ping_timeout;
     *     struct wl_signal new_popup;
     *     struct wl_signal configure;
     *     struct wl_signal ack_configure;
     * } events
     * }
     */
    public static final long events$offset() {
        return events$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     struct wl_signal destroy;
     *     struct wl_signal ping_timeout;
     *     struct wl_signal new_popup;
     *     struct wl_signal configure;
     *     struct wl_signal ack_configure;
     * } events
     * }
     */
    public static MemorySegment events(MemorySegment struct) {
        return struct.asSlice(events$OFFSET, events$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     struct wl_signal destroy;
     *     struct wl_signal ping_timeout;
     *     struct wl_signal new_popup;
     *     struct wl_signal configure;
     *     struct wl_signal ack_configure;
     * } events
     * }
     */
    public static void events(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, events$OFFSET, events$LAYOUT.byteSize());
    }

    private static final AddressLayout data$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("data"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *data
     * }
     */
    public static final AddressLayout data$layout() {
        return data$LAYOUT;
    }

    private static final long data$OFFSET = 248;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *data
     * }
     */
    public static final long data$offset() {
        return data$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *data
     * }
     */
    public static MemorySegment data(MemorySegment struct) {
        return struct.get(data$LAYOUT, data$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *data
     * }
     */
    public static void data(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(data$LAYOUT, data$OFFSET, fieldValue);
    }

    private static final GroupLayout role_resource_destroy$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("role_resource_destroy"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct wl_listener role_resource_destroy
     * }
     */
    public static final GroupLayout role_resource_destroy$layout() {
        return role_resource_destroy$LAYOUT;
    }

    private static final long role_resource_destroy$OFFSET = 256;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct wl_listener role_resource_destroy
     * }
     */
    public static final long role_resource_destroy$offset() {
        return role_resource_destroy$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct wl_listener role_resource_destroy
     * }
     */
    public static MemorySegment role_resource_destroy(MemorySegment struct) {
        return struct.asSlice(role_resource_destroy$OFFSET, role_resource_destroy$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct wl_listener role_resource_destroy
     * }
     */
    public static void role_resource_destroy(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, role_resource_destroy$OFFSET, role_resource_destroy$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

